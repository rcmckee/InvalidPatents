<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><title>Patent US7082438 - Algorithm for tree traversals using left links - Google Patents</title><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){var d=void 0!=b?b:(new Date).getTime();this.t[a]=[d,c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(e){}};this.tick("start",null,a)}var a;window.performance&&(a=window.performance.timing);var f=a?new e(a.responseStart):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart,d=a.responseStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_",
"_wtsrt",d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();})();
</script><link rel="stylesheet" href="/patents/css/_8a2b04e7bf975d5171d8e4c0b6365c7a/kl_intl_patents_bundle.css" type="text/css" /><script src="/books/javascript/atb_8a2b04e7bf975d5171d8e4c0b6365c7a__en.js"></script><script>function googleTranslateElementInit() {new google.translate.TranslateElement({pageLanguage: "en",gaTrack: true,gaId: "UA-27188110-1",multilanguagePage: true});}</script><script src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script><meta name="DC.type" content="Patent"><meta name="DC.title" content="Algorithm for tree traversals using left links"><meta name="DC.contributor" content="Marc A. Najork" scheme="inventor"><meta name="DC.contributor" content="Chandramohan A. Thekkath" scheme="inventor"><meta name="DC.contributor" content="Microsoft Corporation" scheme="assignee"><meta name="DC.date" content="2005-9-1" scheme="dateSubmitted"><meta name="DC.description" content="An information management system includes a computer and a database comprising a B-Tree data structure comprising a plurality of nodes associated with disk blocks and handles stored in the nodes. At least one left-link handle, hleft, stored in each node points to a left sibling of that node. A mechanism for performing a lookup operation with respect to a key, k, traverses the B-Tree and refers to the left-link handle, hleft, of a node to access a left sibling of the node if the key k is less than or equal to a value kmin stored in the node. Mechanisms are also provided for performing insert and delete operations, and the lookup, insert, and delete operations detect if the key range of an index node, A, does not include the key k that the operation is trying to locate, and follow a handle A.hleft to the left sibling when k≦A.kmin."><meta name="DC.date" content="2006-7-25" scheme="issued"><meta name="citation_reference" content="Antoshenkov, G., &quot;Random Sampling from Pseudo-Ranked B+ Trees,&quot; VLDB, 1992, 375-382."><meta name="citation_reference" content="Arnow, D.M. et al., &quot;An Empirical Comparison of B-Trees, Compact B-Trees and Multiway Trees,&quot; SIGMOD Conference, 1984, 33-46."><meta name="citation_reference" content="Baeza-Yates, R.A. et al., &quot;Performance of B+-Trees with Partial Expansions,&quot; TKDE, 1989, 1(2), 248-257."><meta name="citation_reference" content="Baeza-Yates, R.A., &quot;An Adaptive Overflow Technique for B-Trees,&quot; EDBT, 1990, 16-28."><meta name="citation_reference" content="Baeza-Yates, R.A., &quot;Modeling Spits in File Structures,&quot; Acta Informatica, 1989, 26(4), 349-362."><meta name="citation_reference" content="Baeza-Yates, R.A., &quot;The Expected Behavior of B+-Trees,&quot; Acta Informatica, 1989, 26(5), 439-471."><meta name="citation_reference" content="Bayer, R. et al., &quot;Concurrency of Operations on B-trees,&quot; Acta Informatica, 1977, 9, 1-21."><meta name="citation_reference" content="Bayer, R. et al., &quot;Organization and Maintenance of Large Ordered Indexes&quot;, Acta Informatica, 1972, 1, 173-189."><meta name="citation_reference" content="Bayer, R. et al., &quot;Prefix B-Trees,&quot; TODS, 1977, 2(1), 11-26."><meta name="citation_reference" content="Biliris, A., &quot;A Comparative Study of Concurrency Control Methods in B-Trees,&quot; Aegean Workshop on Computing, 1986, 305-316."><meta name="citation_reference" content="Biliris, A., &quot;Operation Specific Locking in B-Trees,&quot; PODS, 1987, 159-169."><meta name="citation_reference" content="Boswell, W. et al., &quot;Alternatives to the B+-Trees,&quot; ICCI, 1990, 266-274."><meta name="citation_reference" content="Chen, S. et al., &quot;Fractal prefetching B*-Trees: optimizing both cache and disk performance&quot;, ACM Press, N.Y., N.Y., 2002, 157-168."><meta name="citation_reference" content="Chu, J-H. et al., &quot;AN Analysis of B-Trees and Their Variants,&quot; IS, 1989, 14(5), 359-370."><meta name="citation_reference" content="Comer, D., &quot;The Ubiquitous B-Tree&quot;, Computing Surveys, Jun. 1979, 11(2), 121-137."><meta name="citation_reference" content="Diehr, G. et al., &quot;Optimal Pagination of B-Trees with Variable-Length Items,&quot; CACM, 1984, 27(3), 241-247."><meta name="citation_reference" content="Eisenbarth, B. et al., &quot;The Theory of Fringe Analysis and its Application to 2-3 Trees and B-Trees,&quot; Information and Control, 1982, 55(1-3), 125-174."><meta name="citation_reference" content="Eiter, T. et al., &quot;Sperrverfahren fur B-Baume im Vergleich,&quot; Informatik Spektrum, 1991, 14(4), 183-200."><meta name="citation_reference" content="Ellis C., &quot;Concurrent Search and Insertion in 2-3 trees,&quot; Acta Informatica, 1980, 14,63-86."><meta name="citation_reference" content="Faloutsos, C. et al., &quot;On B-Tree Indices for Skewed Distributions,&quot; VLDB, 1992, 363-374."><meta name="citation_reference" content="Ferguson, D.E., &quot;Bit-Tree, A Data Structure for Fast File Processing,&quot; CACM, 1992, 35(6), 114-120."><meta name="citation_reference" content="Fu, A. et al., &quot;Concurrency Control of Nested Transactions Accessing B-Trees&quot;, ACM, 1989, 270-285."><meta name="citation_reference" content="Fujimura, K. et al., &quot;On Robustness of B-Trees,&quot; TKDE, 1993, 5(3), 530-534."><meta name="citation_reference" content="Goh, C.H. et al., &quot;Indexing Temporal Data Using Existing B-30 -Trees,&quot; DKE, 1996, 18(2), 147-165."><meta name="citation_reference" content="Goodman, N. et al., &quot;Semantically-based Concurrency Control for Search Structures,&quot; Principles Of Database Systems, 1985, 8-19."><meta name="citation_reference" content="Gupta, G.K., &quot;A Self-Assessment Procedure Dealing with Binary Trees and B-Trees,&quot; Communications of the ACM, 1984, 27(5), 435-443."><meta name="citation_reference" content="Gupta, U.I. et al., &quot;Ranking and Unranking of B-Trees,&quot; Journal of Algorithms, 1983, 4(1), 51-60."><meta name="citation_reference" content="Hardjono, T. et al., Search Key Substitution in the Encipherment of B-Trees, VLDB, 1990, 50-58."><meta name="citation_reference" content="Held, G. et al., &quot;B-Trees Re-Examined,&quot; Communications of the ACM, 1978, 21(2), 139-143."><meta name="citation_reference" content="Hellerstein, J.M. et al., &quot;Generalized Search Trees for Database Systems,&quot; VLDB, 1995, 1-12."><meta name="citation_reference" content="Ishak, R., &quot;Semantically Consistent Schedules for Efficient and Concurrent B-Tree Restructuring,&quot; ICDE, 1992, 184-191."><meta name="citation_reference" content="Jannink, J., &quot;Implementing Deletion in B+-Trees,&quot; SIGMOD Record, 1995, 24(1), 33-38."><meta name="citation_reference" content="Johnson, T. et al., &quot;A Framework for the Performance Analysis of Concurrent B-Tree Algorithms,&quot; PODS, 1990, 273-287."><meta name="citation_reference" content="Johnson, T. et al., &quot;B-Trees with Inserts and Deletes: Why Free-at-Empty is Better than Merge-at-Half,&quot; Journal of Computer and System Sciences, 1993, 47(1), 45-76."><meta name="citation_reference" content="Johnson, T. et al., &quot;The Performance of Current B-Tree Algorithms,&quot; ACM Transactions On Database Systems, 1993, 18(1), 51-101."><meta name="citation_reference" content="Johnson, T. et al., &quot;Utilization of B-Trees with Inserts, Deletes and Modifies,&quot; PODS, 1989, 235-246."><meta name="citation_reference" content="Keller, A.M. et al., &quot;Concurrent Use of B-Trees with Variable-Length Entries,&quot; SIGMOD Record, 1988, 17(2), 89-90."><meta name="citation_reference" content="Kersten, M. et al., &quot;Application of an Optimistic Concurrency Control Method,&quot; Software Practice and Experience, 1984, 14(2), 153-168."><meta name="citation_reference" content="Kuspert, K., &quot;Storage Utilization in B*-Trees with a Generalized Overflow Technique,&quot; Acta Informatica, 1983, 19, 35-55."><meta name="citation_reference" content="Kwong, Y. et al., &quot;A New Method for Concurrency in B-Trees,&quot; IEE Transaction on Software Engineering, 1982, 8(3), 211-222."><meta name="citation_reference" content="Kwong, Y. et al., &quot;Approaches to Concurrency in B-trees,&quot; MFCS, 1980, 402-413."><meta name="citation_reference" content="Kwong, Y. et al., &quot;Concurrent Operations in Large Ordered Indices,&quot; Lecture Notes in Computer Science, 1980, 83, 207-222."><meta name="citation_reference" content="Kwong, Y-S. et al., &quot;On B-Trees: Routing Schemes and Concurrency,&quot; SIGMOD Conference, 1980, 207-213."><meta name="citation_reference" content="Langenhop, C. et al., &quot;A Model of the Dynamic Behavior of B-Trees,&quot; Acta Informatica, 1989, 27(1), 41-59."><meta name="citation_reference" content="Lanin, V. et al., &quot;A Symmetric Concurrent B-Tree Algorithm,&quot; FJCC, 1986, 380-389."><meta name="citation_reference" content="Lanka, S. et al., &quot;Fully Persistent B+-Trees,&quot; SIGMOD Conference,1991, 426-435."><meta name="citation_reference" content="Lausen, G., &quot;Integrated Concurrency Control Shared B-Trees,&quot; Computing, 1984, 33(1), 13-26."><meta name="citation_reference" content="Lehman, P.L. et al., &quot;Efficient Locking for Concurrent Operations on B-Trees&quot;, ACM Transactions on Database Systems, Dec. 1981, 6(4), 650-670."><meta name="citation_reference" content="Leung, C., &quot;Approximate Storage Utilisation of B-Trees: A Simple Derivation and Generalisation,&quot; Information Processing Letters, 1984, 19(4), 199-201."><meta name="citation_reference" content="Lomet, D.B. et al., &quot;Access Method Concurrency with Recovery,&quot; SIGMOD Conference, 1992, 351-360."><meta name="citation_reference" content="Lomet, D.B., &quot;Multi-Table Search for B-Tree Files,&quot; SIGMOD Conference, 1979, 35-42."><meta name="citation_reference" content="Lomet, D.B., &quot;Partial Expansions for File Organizations with an Index,&quot; ACM Transactions on Database Systems, 1987, 12(1), 65-84."><meta name="citation_reference" content="Lum, V.Y., &quot;Multi-Attribute Retrieval with Combined Indexes,&quot; Communications of the ACM, 1970, 13(11), 660-665."><meta name="citation_reference" content="Maelbrancke, R. et al., &quot;Optimizing Jan Jannink&#39;s Implementation of B+-Tree Deletion,&quot; SIGMOD Record, 1995, 24(3), 5-7."><meta name="citation_reference" content="McCreight, E.M., &quot;Pagination of B*-Trees with Variable-Length Records,&quot; Communications of the ACM, 1977, 20(9), 670-674."><meta name="citation_reference" content="Mohan, C. et al., &quot;Algorithms for Creating Indexes for Very Large Tables Without Quiescing Updates,&quot; SIGMOD Conference, 1992, 361-370."><meta name="citation_reference" content="Mohan, C. et al., &quot;ARIES/IM: An Efficient and High Concurrency Index Management Method Using Write-Ahead Logging,&quot; SIGMOD Conference, 1992, 371-380."><meta name="citation_reference" content="Mohan, C., &quot;ARIES/KVL: A Key-Value Locking Method for Concurrency Control of Multiaction Transactions Operating on B-Tree Indexes,&quot; Proceedings of the 16&lt;SUP&gt;th &lt;/SUP&gt;VLDB Conference, 1990, 392-405."><meta name="citation_reference" content="Mond, Y. et al., &quot;Concurrency Control in B-Trees+-Trees Database Using Preparatory Operations,&quot; VLDB, 1985, 331-334."><meta name="citation_reference" content="Nakamura, T. et al., &quot;An Analysis of Storage Utilization Factor in Block Split Data Structuring Scheme,&quot; VLDB, 1978, 489-495."><meta name="citation_reference" content="Nurmi, O. et al., &quot;Concurrency Control in Databse Structures with Relaxed Balance,&quot; PODS, 1987, 170-176."><meta name="citation_reference" content="Olken, F. et al., &quot;Random Sampling from B+ Trees,&quot; Proceedings of the 15&lt;SUP&gt;th &lt;/SUP&gt;International Conference on Very Large Data Bases, 1989, 269-277."><meta name="citation_reference" content="O&#39;Neil, P.E., &quot;The SB-Tree: An Index-Sequential Structure for High-Performance Sequential Access,&quot; Acta Informatica, 1992, 29(3), 241-265."><meta name="citation_reference" content="Ouksel, M. et al., &quot;Multidimensional B-Trees: Analysis of Dynamic Behavior,&quot; BIT, 1981, 21, 401-418."><meta name="citation_reference" content="Phuc, N.H. et al., &quot;Performance Comparison Between B*-Tree and Prefix Binary Tree Index Organizations,&quot; International Conference On Databases, 1983, vol. 19, 358-376."><meta name="citation_reference" content="Pinchuk, A.P. et al., &quot;Maintaining Dictionaries: Space-Saving Modifications of B-Trees,&quot; ICDT, 1992, 421-435."><meta name="citation_reference" content="Pollari-Malmi, K. et al., &quot;Concurrency Control in B-Trees with Batch updates&quot;, IEEE Transactions on Knowledge and Data Engineering, Dec. 1996, 8(6), 975-984."><meta name="citation_reference" content="Rosenberg, A.L. et al., &quot;Compact B-Trees,&quot; SIGMOD Conference, 1979, 43-51."><meta name="citation_reference" content="Rosenberg, A.L. et al., &quot;Time- and Space Optimality in B-Trees,&quot; ACM Transactions on Database Systems, 1981, 6(1), 174-193."><meta name="citation_reference" content="Sagiv, Y. &quot;Concurrent Operations on B*-Trees with Overtaking&quot;, Journal of Computer Science, 1986, 33, 275-295."><meta name="citation_reference" content="Sagiv, Y., &quot;Concurrent Operations on B*-Trees with Overtaking&quot;, Journal of Computer and System Sciences, 1986, 33, 275-296."><meta name="citation_reference" content="Samadi, B., &quot;B-Trees in a System with Multiple users,&quot; Information Processing Letters, 1976, 5(4), 107-112."><meta name="citation_reference" content="Scheuermann, P. et al., &quot;Multidimensional B-Trees for Associative Searching in Database Systems,&quot; Information Systems, 1982, 7(2), 123-137."><meta name="citation_reference" content="Seeger, B. et al., &quot;Multi-Disk B-Trees,&quot; SIGMOD Conference, 1991, 436-445."><meta name="citation_reference" content="Setzer, V.W. et al., &quot;New Concurrency Control Algorithms for Accessing and Compacting B-Trees,&quot; Proceedings of the 20&lt;SUP&gt;th &lt;/SUP&gt;VLDB Conference, 1994, 238-248."><meta name="citation_reference" content="Shimin Chen, &quot;Fractual prefetchig B-Trees: optimizing both cache and disk performance&quot; 2002, ACM Press, N.Y, N.Y., pp. 157-168."><meta name="citation_reference" content="Snyder, L., &quot;On B-Trees Re-Examined,&quot; Communications of the ACM, 1977, 21(7), 594."><meta name="citation_reference" content="Spirn, J.R. et al., &quot;Memory Management for B-Trees,&quot; Performance Evaluation, 1985, 5, 159-174."><meta name="citation_reference" content="Srinivasan, V. et al., &quot;Performance of B+ Tree Concurrency Algorithms,&quot; VLDB Journal., 1993, 2(4), 361-406."><meta name="citation_reference" content="Srinivasan, V. et al., &quot;Performance of B-Tree Concurrency Algorithms,&quot; SIGMOD Conference, 1991, 416-425."><meta name="citation_reference" content="Srinivasan, V. et al., &quot;Performance of On-Line Index Construction Algorithms,&quot; EDBT, 1992, 293-309."><meta name="citation_reference" content="Srivastava, J. et al., &quot;Efficient Algorithms for Maintenance of Large Database,&quot; ICDE, 1988, 402-408."><meta name="citation_reference" content="Sullivan, M. et al., &quot;An Index Implementation Supporting Fast Recovery for the POSTGRES Storage System,&quot; ICDE, 1992, 293-300."><meta name="citation_reference" content="Tharp, A.L. et al., &quot;B+ Trees, Bounded Disorder and Adaptive Hashing,&quot; IS, 1991, 16(1), 65-71."><meta name="citation_reference" content="Wang, P., &quot;An In-Depth Analysis of Concurrent B-tree Algorithms&quot;, Report is a Minor Revision of a Master&#39;s Thesis of the Same Title submitted to the Department of Electrical Engineering and Computer Science, Jan. 10, 1991, 131 pages."><meta name="citation_reference" content="Wedekind, H., &quot;On the Selection of Access Paths in a Data Base System&quot;, Data Base Management, 1974, 385-397."><meta name="citation_reference" content="Wright, W.E., &quot;Some Average Performance Measures for the B-Tree,&quot; Acta Informatica, 1985, 21, 541-557."><meta name="citation_reference" content="Zhang, B. et al., &quot;Unsafe Operations in B-Trees,&quot; Acta Informatica, 1989, 26(5), 421-438."><meta name="citation_patent_number" content="US:7082438"><meta name="citation_patent_application_number" content="US:11/219,140"><link rel="canonical" href="http://www.google.com/patents/US7082438"/><meta property="og:url" content="http://www.google.com/patents/US7082438"/><meta name="title" content="Patent US7082438 - Algorithm for tree traversals using left links"/><meta name="description" content="An information management system includes a computer and a database comprising a B-Tree data structure comprising a plurality of nodes associated with disk blocks and handles stored in the nodes. At least one left-link handle, hleft, stored in each node points to a left sibling of that node. A mechanism for performing a lookup operation with respect to a key, k, traverses the B-Tree and refers to the left-link handle, hleft, of a node to access a left sibling of the node if the key k is less than or equal to a value kmin stored in the node. Mechanisms are also provided for performing insert and delete operations, and the lookup, insert, and delete operations detect if the key range of an index node, A, does not include the key k that the operation is trying to locate, and follow a handle A.hleft to the left sibling when k≦A.kmin."/><meta property="og:title" content="Patent US7082438 - Algorithm for tree traversals using left links"/><meta property="og:type" content="book"/><meta property="og:site_name" content="Google Books"/><meta property="og:image" content="http://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"/><link rel="image_src" href="http://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"/><script>(function(){try{var aa=function(a,b,c,d){d=d||{};d._sn=["cfg",b,c].join(".");window.gbar.logger.ml(a,d)};var g=window.gbar=window.gbar||{},l=window.gbar.i=window.gbar.i||{},m={},n;function _tvn(a,b){var c=parseInt(a,10);return isNaN(c)?b:c}function _tvf(a,b){var c=parseFloat(a);return isNaN(c)?b:c}function _tvv(a){return!!a}function p(a,b,c){(c||g)[a]=b}g.bv={n:_tvn("2",0),r:"",f:".67.",e:"0",m:_tvn("0",1)};
function q(a,b,c){var d="on"+b;if(a.addEventListener)a.addEventListener(b,c,!1);else if(a.attachEvent)a.attachEvent(d,c);else{var f=a[d];a[d]=function(){var a=f.apply(this,arguments),b=c.apply(this,arguments);return void 0==a?b:void 0==b?a:b&&a}}}var s=function(a){return function(){return g.bv.m==a}},ba=s(1),ca=s(2);p("sb",ba);p("kn",ca);l.a=_tvv;l.b=_tvf;l.c=_tvn;l.i=aa;var da=window.gbar.i.i;var t,u,v,w;function ea(a){v=a}function fa(a){var b;if(b=v&&window.encodeURIComponent)b=a.href,b=!b.match(/^http[s]?:\/\/accounts\.google\.[^/]*\/ClearSID/i)&&!b.match(/^http[s]?:\/\/[^/]*\/accounts\/ClearSID/i);if(b=b&&encodeURIComponent(v()))a.href=a.href.replace(/([?&]continue=)[^&]*/,"$1"+b)}function ga(a){window.gApplication&&(a.href=window.gApplication.getTabUrl(a.href))}
function ha(a){var b=document.forms[0].q,c=window.encodeURIComponent&&b&&b.value,b=b&&b.placeholder;c&&c!=b&&(a.href=a.href.replace(/([?&])q=[^&]*|$/,function(a,b){return(b||"&")+"q="+encodeURIComponent(c)}))}n=l.a("")?ga:ha;
function x(a,b,c,d,f,e){var h=document.getElementById(a);if(h){var k=h.style;k.left=d?"auto":b+"px";k.right=d?b+"px":"auto";k.top=c+"px";k.visibility=u?"hidden":"visible";f&&e?(k.width=f+"px",k.height=e+"px"):(x(t,b,c,d,h.offsetWidth,h.offsetHeight),u=u?"":a)}}
var y=[],ia=function(a,b){y.push(b)},ja=function(a){a=a||window.event;var b=a.target||a.srcElement;a.cancelBubble=!0;null==t&&(a=document.createElement(Array.every||window.createPopup?"iframe":"div"),a.frameBorder="0",t=a.id="gbs",a.src="javascript:''",b.parentNode.appendChild(a),q(document,"click",z));var c=b,b=0;"gb3"!=c.className&&(c=c.parentNode);a=c.getAttribute("aria-owns")||"gbi";var d=c.offsetWidth,f=20<c.offsetTop?46:24;document.getElementById("tphdr")&&(f-=3);var e=!1;do b+=c.offsetLeft||
0;while(c=c.offsetParent);var c=(document.documentElement.clientWidth||document.body.clientWidth)-b-d,h,d=document.body,k=document.defaultView;k&&k.getComputedStyle?(d=k.getComputedStyle(d,""))&&(h=d.direction):h=d.currentStyle?d.currentStyle.direction:d.style.direction;h="rtl"==h;if("gbi"==a){for(d=0;k=y[d++];)k();A(null,window.navExtra);h&&(b=c,e=!0)}else h||(b=c,e=!0);u!=a&&z();x(a,b,f,e)},z=function(){u&&x(u,0,0)},A=function(a,b){var c,d=document.getElementById("gbi"),f=a;f||(f=d.firstChild);
for(;b&&(c=b.pop());){var e=d,h=c,k=f;w||(w="gb2");e.insertBefore(h,k).className=w}},ka=function(a,b,c){if((b=document.getElementById(b))&&a){a.className="gb4";var d=document.createElement("span");d.appendChild(a);d.appendChild(document.createTextNode(" | "));d.id=c;b.appendChild(d)}},la=function(){return document.getElementById("gb_70")},ma=function(){return!!u};p("qs",n);p("setContinueCb",ea);p("pc",fa);p("tg",ja);p("close",z);p("addLink",ka);p("almm",A);p("si",la);p("adh",ia);p("op",ma);var B=function(){},C=function(){},F=function(a){var b=new Image,c=D;b.onerror=b.onload=b.onabort=function(){try{delete E[c]}catch(a){}};E[c]=b;b.src=a;D=c+1},E=[],D=0;p("logger",{il:C,ml:B,log:F});var G=window.gbar.logger;var H={},na={},I=[],oa=l.b("0.1",.1),pa=l.a("1",!0),qa=function(a,b){I.push([a,b])},ra=function(a,b){H[a]=b},sa=function(a){return a in H},J={},K=function(a,b){J[a]||(J[a]=[]);J[a].push(b)},ta=function(a){K("m",a)},L=function(a,b){var c=document.createElement("script");c.src=a;c.async=pa;Math.random()<oa&&(c.onerror=function(){c.onerror=null;B(Error("Bundle load failed: name="+(b||"UNK")+" url="+a))});(document.getElementById("xjsc")||document.getElementsByTagName("body")[0]||
document.getElementsByTagName("head")[0]).appendChild(c)},N=function(a){for(var b=0,c;(c=I[b])&&c[0]!=a;++b);!c||c[1].l||c[1].s||(c[1].s=!0,M(2,a),c[1].url&&L(c[1].url,a),c[1].libs&&m.d&&m.d(c[1].libs))},O=function(a){K("gc",a)},P=null,ua=function(a){P=a},M=function(a,b,c){if(P){a={t:a,b:b};if(c)for(var d in c)a[d]=c[d];try{P(a)}catch(f){}}};p("mdc",H);p("mdi",na);p("bnc",I);p("qGC",O);p("qm",ta);p("qd",J);p("lb",N);p("mcf",ra);p("bcf",qa);p("aq",K);p("mdd","");p("has",sa);
p("trh",ua);p("tev",M);var Q=l.b("0.1",.001),R=0;
function _mlToken(a,b){try{if(1>R){R++;var c,d=a,f=b||{},e=encodeURIComponent,h=["//www.google.com/gen_204?atyp=i&zx=",(new Date).getTime(),"&jexpid=",e("17483"),"&srcpg=",e("prop=22"),"&jsr=",Math.round(1/Q),"&ogev=",e("dqntU7XtA9W_sQTy7oKwDg"),"&ogf=",g.bv.f,"&ogrp=",e("1"),"&ogv=",e("1407723702.0"),"&oggv="+e("es_plusone_gc_20140723.0_p0"),"&ogd=",e("com"),"&ogc=",e("NOR"),"&ogl=",e("en")];f._sn&&(f._sn="og."+
f._sn);for(var k in f)h.push("&"),h.push(e(k)),h.push("="),h.push(e(f[k]));h.push("&emsg=");h.push(e(d.name+":"+d.message));var r=h.join("");S(r)&&(r=r.substr(0,2E3));c=r;var Aa=window.gbar.logger._aem(a,c);F(Aa)}}catch(Na){}}var S=function(a){return 2E3<=a.length},va=function(a,b){return b};function T(a){B=a;p("_itl",S,G);p("_aem",va,G);p("ml",B,G);a={};H.er=a}l.a("")?T(function(a){throw a;}):l.a("1")&&Math.random()<Q&&T(_mlToken);I.push(["m",{url:"//ssl.gstatic.com/gb/js/scm_7385cc5883250b43a39405734c1bea59.js"}]);g.mcf("c",{});g.sg={c:""};if(l.a("1")){var wa=l.a("");I.push(["gc",{auto:wa,url:"//ssl.gstatic.com/gb/js/abc/gci_91f30755d6a6b787dcc2a4062e6e9824.js",libs:"googleapis.client:plusone:gapi.iframes"}]);var xa={version:"gci_91f30755d6a6b787dcc2a4062e6e9824.js",index:"",lang:"en"};H.gc=xa;var U=function(a){window.googleapis&&window.iframes?a&&a():(a&&O(a),N("gc"))};p("lGC",U);l.a("1")&&p("lPWF",U)};window.__PVT="";if(l.a("1")&&l.a("1")){var V=function(a){U(function(){K("pw",a);N("pw")})};p("lPW",V);I.push(["pw",{url:"//ssl.gstatic.com/gb/js/abc/pwm_45f73e4df07a0e388b0fa1f3d30e7280.js"}]);var W=[],ya=function(a){W[0]=a},za=function(a,b){var c=b||{};c._sn="pw";B(a,c)},Ba={signed:W,elog:za,base:"https://plusone.google.com/u/0",loadTime:(new Date).getTime()};H.pw=Ba;var X=function(a,b){for(var c=b.split("."),d=function(){var b=arguments;a(function(){for(var a=g,d=0,e=c.length-1;d<e;++d)a=a[c[d]];a[c[d]].apply(a,b)})},f=g,e=0,h=c.length-1;e<h;++e)f=
f[c[e]]=f[c[e]]||{};return f[c[e]]=d};X(V,"pw.clk");X(V,"pw.hvr");p("su",ya,g.pw)};function Ca(){function a(){for(var b;(b=e[h++])&&"m"!=b[0]&&!b[1].auto;);b&&(M(2,b[0]),b[1].url&&L(b[1].url,b[0]),b[1].libs&&m.d&&m.d(b[1].libs));h<e.length&&setTimeout(a,0)}function b(){0<f--?setTimeout(b,0):a()}var c=l.a("1"),d=l.a(""),f=3,e=I,h=0,k=window.gbarOnReady;if(k)try{k()}catch(r){da(r,"ml","or")}d?p("ldb",a):c?q(window,"load",b):b()}p("rdl",Ca);var Da={D:1,H:2,da:3,p:4,W:5,M:6,F:7,g:8,ha:9,U:10,L:11,T:12,S:13,N:14,Q:15,P:16,fa:17,w:18,O:19,ga:20,ea:21,u:22,G:23,ja:24,ka:25,ia:26,A:27,j:28,o:29,k:30,ca:31,Z:32,$:33,J:34,K:35,ba:36,aa:37,Y:38,B:39,R:40,v:41,X:42,V:43,h:48,C:49,I:500},Y=[1,2,3,4,5,6,9,10,11,13,14,28,29,30,34,35,37,38,39,40,41,42,43,48,49,500];var Z=l.b("0.001",1E-4),Ea=l.b("1",1),Fa=!1,Ga=!1;if(l.a("1")){var Ha=Math.random();Ha<=Z&&(Fa=!0);Ha<=Ea&&(Ga=!0)}var Ia=Da,$=null;function Ja(){var a=0,b=function(b,d){l.a(d)&&(a|=b)};b(1,"");b(2,"");b(4,"");b(8,"");return a}
function Ka(a,b){var c=Z,d=Fa,f;f=a;if(!$){$={};for(var e=0;e<Y.length;e++){var h=Y[e];$[h]=!0}}if(f=!!$[f])c=Ea,d=Ga;if(d){d=encodeURIComponent;g.rp?(f=g.rp(),f="-1"!=f?f:"1"):f="1";c=["//www.google.com/gen_204?atyp=i&zx=",(new Date).getTime(),"&oge=",a,"&ogex=",d("17483"),"&ogev=",d("dqntU7XtA9W_sQTy7oKwDg"),"&ogf=",g.bv.f,"&ogp=",d("22"),"&ogrp=",d(f),"&ogsr=",Math.round(1/c),"&ogv=",d("1407723702.0"),"&oggv="+
d("es_plusone_gc_20140723.0_p0"),"&ogd=",d("com"),"&ogl=",d("en"),"&ogc=",d("NOR"),"&ogus=",Ja()];if(b){"ogw"in b&&(c.push("&ogw="+b.ogw),delete b.ogw);var k;f=b;e=[];for(k in f)0!=e.length&&e.push(","),e.push(La(k)),e.push("."),e.push(La(f[k]));k=e.join("");""!=k&&(c.push("&ogad="),c.push(d(k)))}F(c.join(""))}}function La(a){"number"==typeof a&&(a+="");return"string"==typeof a?a.replace(".","%2E").replace(",","%2C"):a}C=Ka;p("il",C,G);var Ma={};H.il=Ma;setTimeout(function(){C(Ia.g)},0);}catch(e){window.gbar&&gbar.logger&&gbar.logger.ml(e,{"_sn":"cfg.init"});}})();
(function(){try{var b=window.gbar.i.i;var c=window.gbar;var f=function(d){try{var a=document.getElementById("gbom");a&&d.appendChild(a.cloneNode(!0))}catch(e){b(e,"omas","aomc")}};c.aomc=f;}catch(e){window.gbar&&gbar.logger&&gbar.logger.ml(e,{"_sn":"cfg.init"});}})();
(function(){try{var a=window.gbar;a.mcf("pm",{p:""});}catch(e){window.gbar&&gbar.logger&&gbar.logger.ml(e,{"_sn":"cfg.init"});}})();
(function(){try{window.gbar.rdl();}catch(e){window.gbar&&gbar.logger&&gbar.logger.ml(e,{"_sn":"cfg.init"});}})();
if (window['_OC_timingAction']) {window['_OC_timingAction']('patents_refpage');}</script><style>#gbar,#guser{font-size:13px;padding-top:1px !important;}#gbar{float:left;height:22px}#guser{padding-bottom:7px !important;text-align:right}.gbh,.gbd{border-top:1px solid #c9d7f1;font-size:1px}.gbh{height:0;position:absolute;top:24px;width:100%}#gbs,.gbm{background:#fff;left:0;position:absolute;text-align:left;visibility:hidden;z-index:1000}.gbm{border:1px solid;border-color:#c9d7f1 #36c #36c #a2bae7;z-index:1001}.gb1{margin-right:.5em}.gb1,.gb3{zoom:1}.gb2{display:block;padding:.2em .5em}.gb2,.gb3{text-decoration:none !important;border-bottom:none}a.gb1,a.gb4{text-decoration:underline !important}a.gb1,a.gb2,a.gb3,a.gb4{color:#00c !important}.gbi .gb3,.gbi .gb2,.gbi .gb4{color:#dd8e27 !important}.gbf .gb3,.gbf .gb2,.gbf .gb4{color:#900 !important}a.gb2:hover{background:#36c;color:#fff !important}#gbar .gbz0l{color:#000 !important;cursor:default;font-weight:bold;text-decoration:none !important}
#gbar { padding:.3em .6em !important;}</style></head><body  topmargin="3" marginheight="3"><div id=gbar><nobr><a onclick=gbar.qs(this);gbar.logger.il(1,{t:1}); class=gb1 id=gb_1 href="https://www.google.com/search?sa=N&tab=tw">Search</a> <a onclick=gbar.qs(this);gbar.logger.il(1,{t:2}); class=gb1 id=gb_2 href="http://www.google.com/search?hl=en&tbm=isch&source=og&sa=N&tab=ti">Images</a> <a onclick=gbar.qs(this);gbar.logger.il(1,{t:8}); class=gb1 id=gb_8 href="http://maps.google.com/maps?hl=en&sa=N&tab=tl">Maps</a> <a onclick=gbar.qs(this);gbar.logger.il(1,{t:78}); class=gb1 id=gb_78 href="https://play.google.com/?hl=en&sa=N&tab=t8">Play</a> <a onclick=gbar.qs(this);gbar.logger.il(1,{t:36}); class=gb1 id=gb_36 href="http://www.youtube.com/results?sa=N&tab=t1">YouTube</a> <a onclick=gbar.logger.il(1,{t:5}); class=gb1 id=gb_5 href="http://news.google.com/nwshp?hl=en&tab=tn">News</a> <a onclick=gbar.logger.il(1,{t:23}); class=gb1 id=gb_23 href="https://mail.google.com/mail/?tab=tm">Gmail</a> <a onclick=gbar.logger.il(1,{t:25}); class=gb1 id=gb_25 href="https://drive.google.com/?tab=to">Drive</a> <a class=gb3 href="http://www.google.com/intl/en/options/" onclick="this.blur();gbar.tg(event);return !1" aria-haspopup=true><u>More</u> <small>&#9660;</small></a><div class=gbm id=gbi><a onclick=gbar.logger.il(1,{t:24}); class=gb2 id=gb_24 href="https://www.google.com/calendar?tab=tc">Calendar</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:51}); class=gb2 id=gb_51 href="http://translate.google.com/?hl=en&sa=N&tab=tT">Translate</a><a onclick=gbar.logger.il(1,{t:17}); class=gb2 id=gb_17 href="http://www.google.com/mobile/?hl=en&tab=tD">Mobile</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:10}); class=gb2 id=gb_10 href="http://www.google.com/search?hl=en&tbo=u&tbm=bks&source=og&sa=N&tab=tp">Books</a><a onclick=gbar.logger.il(1,{t:212}); class=gb2 id=gb_212 href="https://wallet.google.com/manage/?tab=ta">Wallet</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:6}); class=gb2 id=gb_6 href="http://www.google.com/search?hl=en&tbo=u&tbm=shop&source=og&sa=N&tab=tf">Shopping</a><a onclick=gbar.logger.il(1,{t:30}); class=gb2 id=gb_30 href="http://www.blogger.com/?tab=tj">Blogger</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:27}); class=gb2 id=gb_27 href="http://www.google.com/finance?sa=N&tab=te">Finance</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:31}); class=gb2 id=gb_31 href="https://plus.google.com/photos?sa=N&tab=tq">Photos</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:12}); class=gb2 id=gb_12 href="http://www.google.com/search?hl=en&tbo=u&tbm=vid&source=og&sa=N&tab=tv">Videos</a><div class=gb2><div class=gbd></div></div><a onclick=gbar.logger.il(1,{t:66}); href="http://www.google.com/intl/en/options/" class=gb2>Even more &raquo;</a></div></nobr></div><div id=guser width=100%><nobr><span id=gbn class=gbi></span><span id=gbf class=gbf></span><span id=gbe></span><a target=_top id=gb_70 href="https://www.google.com/accounts/Login?service=&continue=http://www.google.com/patents%3Fhl%3Den&hl=en" class=gb4>Sign in</a><div style="display: none"><div class=gbm id=gbd5 aria-owner=gbg5><div class=gbmc><ol id=gbom class=gbmcc></ol></div></div></div></nobr></div><div class=gbh style=left:0></div><div class=gbh style=right:0></div><div role="alert" style="position: absolute; left: 0; right: 0;"><a href="http://www.google.com/patents/us7082438?hl=en&amp;output=html_text" title="Screen reader users: click this link for accessible mode. Accessible mode has the same essential features but works better with your reader."><img border="0" src="http://www.google.com/images/cleardot.gif"alt="Screen reader users: click this link for accessible mode. Accessible mode has the same essential features but works better with your reader."></a></div><div id="guser"><nobr></nobr></div><div style="clear:both;"></div><div id="gb-top-search-box" class="gb-top-search-box-small gb-reset"><table><tr><td class="logo"><a href="http://www.google.com/patents" class="logo-link"><img class="logo-img" src="/intl/en/images/logos/google_logo_41.png" alt="Go to Google Books Home" height="41"/></a></td><td><form action="http://www.google.com/search" name="f" id="vheadf" method="get"><span id="hf"></span><input type="hidden" name="tbm" value="pts"/><input type="hidden" name="tbo" value="1"/><input type="hidden" name="hl" value="en"/><table><tr><td><div class="inputs"><table><tr><td><div class="text-input"><input type="text" name="q" id="vheadq" class="text" maxlength="2048" size="31" value="" title="Search Patents" accesskey="s" autocomplete="off"/><script>window._OC_autoDir &&window._OC_autoDir('vheadq', 'tia-vheadq');</script></div></td><td><div class="submit-input"><input name="btnG" class="submit" type="submit" value=""/></div></td></tr></table></div></td><td class="col-ext-links"><div class="ext-links"><a href="http://www.google.com/advanced_patent_search">&lt;nobr&gt;Advanced Patent Search&lt;/nobr&gt;</a></div></td></tr></table></form></td></tr></table></div><div class="kd-appbar"><h2 class="kd-appname"><a href="/patents">Patents</a></h2><div class="kd-buttonbar left" id="left-toolbar-buttons"><a id="appbar-write-review-link" href=""></a><a id="appbar-view-print-sample-link" href=""></a><a id="appbar-view-ebook-sample-link" href=""></a><a id="appbar-patents-prior-art-finder-link" href="https://www.google.com/patents/related/US7082438"></a><a id="appbar-patents-discuss-this-link" href="http://www.google.com/url?id=sIB1BAABERAJ&amp;q=http://patents.stackexchange.com/redirect/google-patents%3Fpatent%3DUS7082438&amp;usg=AFQjCNGS9paUPmQ2ZKsSQETOZkDVYOZq7A" data-is-grant="true"></a><a id="appbar-read-patent-link" href="//docs.google.com/viewer?url=patentimages.storage.googleapis.com/pdfs/US7082438.pdf"></a><a id="appbar-download-pdf-link" href="//patentimages.storage.googleapis.com/pdfs/US7082438.pdf"></a><a class="appbar-application-grant-link" data-label="Application" href="/patents/US20060026188"></a><a class="appbar-application-grant-link" data-selected="true" data-label="Grant" href="/patents/US7082438"></a></div><div class="kd-buttonbar right" id="right-toolbar-buttons"></div></div><div id="books-microdata" itemscope=""itemtype="http://schema.org/Book"itemid="http://www.google.com/patents/US7082438" style="display:none"><span itemprop="description">An information management system includes a computer and a database comprising a B-Tree data structure comprising a plurality of nodes associated with disk blocks and handles stored in the nodes. At least one left-link handle, hleft, stored in each node points to a left sibling of that node. A mechanism...</span><span itemprop="url">http://www.google.com/patents/US7082438?utm_source=gb-gplus-share</span><span class="main-title" itemprop="name">Patent US7082438 - Algorithm for tree traversals using left links</span><img itemprop="image" src="http://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"alt="Patent US7082438 - Algorithm for tree traversals using left links" title="Patent US7082438 - Algorithm for tree traversals using left links"></div><div style="display: none"><ol id="ofe-gear-menu-contents" class="gbmcc"><li class="gbe gbmtc"><a class="gbmt goog-menuitem-content" id="" href="http://www.google.com/advanced_patent_search">Advanced Patent Search</a></li></ol></div><table id="viewport_table" cellpadding="0" style="clear:both" cellspacing="0"><tr><td id="viewport_td"><div class=vertical_module_list_row><div id=intl_patents class=about_content><div id=intl_patents_v><table class="patent-bibdata"><tr><td class="patent-bibdata-heading">Publication number</td><td class="single-patent-bibdata">US7082438 B2</td></tr><tr><td class="patent-bibdata-heading">Publication type</td><td class="single-patent-bibdata">Grant</td></tr><tr><td class="patent-bibdata-heading">Application number</td><td class="single-patent-bibdata">US 11/219,140</td></tr><tr><td class="patent-bibdata-heading">Publication date</td><td class="single-patent-bibdata">Jul 25, 2006</td></tr><tr><td class="patent-bibdata-heading">Filing date</td><td class="single-patent-bibdata">Sep 1, 2005</td></tr><tr><td class="patent-bibdata-heading">Priority date<span class="patent-tooltip-anchor patent-question-icon"data-tooltip-text="The priority date is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the date listed."></span></td><td class="single-patent-bibdata">Dec 2, 2002</td></tr><tr><td class="patent-bibdata-heading">Fee status<span class="patent-tooltip-anchor patent-question-icon"data-tooltip-text="The fee status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status or dates listed."></span></td><td class="single-patent-bibdata">Paid</td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">Also published as</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="/patents/EP1426878A2">EP1426878A2</a>, </span><span class="patent-bibdata-value"><a href="/patents/EP1426878A3">EP1426878A3</a>, </span><span class="patent-bibdata-value"><a href="/patents/US7007027">US7007027</a>, </span><span class="patent-bibdata-value"><a href="/patents/US20040107186">US20040107186</a>, </span><span class="patent-bibdata-value"><a href="/patents/US20060026188">US20060026188</a></span></span></td></tr><tr class="patent-bibdata-list-row alternate-patent-number"><td class="patent-bibdata-heading">Publication number</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value">11219140, </span><span class="patent-bibdata-value">219140, </span><span class="patent-bibdata-value">US 7082438 B2, </span><span class="patent-bibdata-value">US 7082438B2, </span><span class="patent-bibdata-value">US-B2-7082438, </span><span class="patent-bibdata-value">US7082438 B2, </span><span class="patent-bibdata-value">US7082438B2</span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">Inventors</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="http://www.google.com/search?tbo=p&tbm=pts&hl=en&q=ininventor:%22Marc+A.+Najork%22">Marc A. Najork</a>, </span><span class="patent-bibdata-value"><a href="http://www.google.com/search?tbo=p&tbm=pts&hl=en&q=ininventor:%22Chandramohan+A.+Thekkath%22">Chandramohan A. Thekkath</a></span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">Original Assignee</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="http://www.google.com/search?tbo=p&tbm=pts&hl=en&q=inassignee:%22Microsoft+Corporation%22">Microsoft Corporation</a></span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">Export Citation</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="/patents/US7082438.bibtex">BiBTeX</a>, </span><span class="patent-bibdata-value"><a href="/patents/US7082438.enw">EndNote</a>, </span><span class="patent-bibdata-value"><a href="/patents/US7082438.ris">RefMan</a></span></span></td></tr><tr class="patent-internal-links"><td colspan=2><span class="patent-bibdata-value"><a href="#npl-citations">Non-Patent Citations</a> (88),</span> <span class="patent-bibdata-value"><a href="#forward-citations">Referenced by</a> (4),</span> <span class="patent-bibdata-value"><a href="#classifications">Classifications</a> (9),</span> <span class="patent-bibdata-value"><a href="#legal-events">Legal Events</a> (5)</span> </td></tr><tr><td colspan=2 class="patent-bibdata-external-link-spacer-top"></td></tr><tr class="patent-bibdata-external-link-spacer-bottom"></tr><tr><td colspan=2><span class="patent-bibdata-heading">External Links:&nbsp;</span><span><span class="patent-bibdata-value"><a href="http://www.google.com/url?id=sIB1BAABERAJ&q=http://patft.uspto.gov/netacgi/nph-Parser%3FSect2%3DPTO1%26Sect2%3DHITOFF%26p%3D1%26u%3D/netahtml/PTO/search-bool.html%26r%3D1%26f%3DG%26l%3D50%26d%3DPALL%26RefSrch%3Dyes%26Query%3DPN/7082438&usg=AFQjCNG6V8NCo-gekwkOAYVEI6DM4z6XLA">USPTO</a>, </span><span class="patent-bibdata-value"><a href="http://www.google.com/url?id=sIB1BAABERAJ&q=http://assignments.uspto.gov/assignments/q%3Fdb%3Dpat%26pat%3D7082438&usg=AFQjCNG5I4aybvycfar9bHyNzUzBCJi15Q">USPTO Assignment</a>, </span><span class="patent-bibdata-value"><a href="http://www.google.com/url?id=sIB1BAABERAJ&q=http://worldwide.espacenet.com/publicationDetails/biblio%3FCC%3DUS%26NR%3D7082438B2%26KC%3DB2%26FT%3DD&usg=AFQjCNFm7B6I-c4KYCSCLgX684HWnRmssA">Espacenet</a></span></span></td></tr><tr class="patent-bibdata-group-spacer"></tr></table><div class="number-and-title"><span class="patent-title"><invention-title mxw-id="PT55615677" lang="EN" load-source="patent-office">Algorithm for tree traversals using left links</invention-title></span><br><span class="patent-number">US 7082438 B2</span></div><div class="patent-section patent-abstract-section"><div class="patent-section-header"><span class="patent-section-title">Abstract</span></div><div class="patent-text"><abstract mxw-id="PA51013773" lang="EN" load-source="patent-office"> <div num="p-0001" class="abstract">An information management system includes a computer and a database comprising a B-Tree data structure comprising a plurality of nodes associated with disk blocks and handles stored in the nodes. At least one left-link handle, h<sub>left</sub>, stored in each node points to a left sibling of that node. A mechanism for performing a lookup operation with respect to a key, k, traverses the B-Tree and refers to the left-link handle, h<sub>left</sub>, of a node to access a left sibling of the node if the key k is less than or equal to a value k<sub>min </sub>stored in the node. Mechanisms are also provided for performing insert and delete operations, and the lookup, insert, and delete operations detect if the key range of an index node, A, does not include the key k that the operation is trying to locate, and follow a handle A.h<sub>left </sub>to the left sibling when k≦A.k<sub>min</sub>.</div>
  </abstract></div></div><div class="patent-section patent-drawings-section"><div class="patent-section-header"><span class="patent-section-title">Images<span class="patent-section-count">(24)</span></span></div><div class="patent-drawings-body"><div class="patent-drawings-carousel"><div class="drawings"><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00000.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00000.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00001.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00001.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00002.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00002.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00003.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00003.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00004.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00004.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00005.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00005.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00006.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00006.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00007.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00007.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00008.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00008.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00009.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00009.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00010.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00010.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00011.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00011.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00012.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00012.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00013.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00013.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00014.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00014.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00015.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00015.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00016.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00016.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00017.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00017.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00018.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00018.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00019.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00019.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00020.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00020.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00021.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00021.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00022.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00022.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US7082438B2/US07082438-20060725-D00023.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US7082438B2/US07082438-20060725-D00023.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div></div></div><div class="patent-drawings-control patent-drawings-prev"><img class="patent-drawings-button-img" alt="Previous page"src="/googlebooks/images/kennedy/page_left.png"width="21" height="21" /></div><div class="patent-drawings-control patent-drawings-next"><img class="patent-drawings-button-img" alt="Next page"src="/googlebooks/images/kennedy/page_right.png"width="21" height="21" /></div></div></div><div class="patent-post-drawings"></div><div class="patent-section patent-claims-section"><div class="patent-section-header"><span class="patent-section-title">Claims<span class="patent-section-count">(17)</span></span></div><div class="patent-text"><div mxw-id="PCLM9055216" lang="EN" load-source="patent-office" class="claims">
  <div class="claim"> <div id="CLM-00001" num="00001" class="claim">
    <div class="claim-text">1. An information management system, comprising:
<div class="claim-text">a computer; and</div>
<div class="claim-text">a database operatively connected to said computer, wherein said database comprises a B-Tree data structure comprising a plurality of nodes associated with disk blocks and handles stored in said nodes, wherein at least one left-link handle stored in each of said plurality of nodes points to a left sibling of that node, and wherein the data structure is useful in the computer's performance of lookup, insert and/or delete operations.</div>
</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00002" num="00002" class="claim">
    <div class="claim-text">2. An information management system as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising a computer implemented mechanism for performing a lookup operation with respect to a key, k.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00003" num="00003" class="claim">
    <div class="claim-text">3. An information management system as recited in <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein, in traversing the B-Tree at a given node, said lookup operation refers to a left-link handle, h<sub>left</sub>, of that node to access a left sibling of the node if the key k is less than or equal to a value k<sub>min </sub>stored in the node.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00004" num="00004" class="claim">
    <div class="claim-text">4. An information management system as recited in <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising a mechanism for performing an insert operation.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00005" num="00005" class="claim">
    <div class="claim-text">5. An information management system as recited in <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the insert operation detects if the key range of an index node, A, does not include the key k that the operation is trying to locate, and wherein said operation follows a handle A.h<sub>left </sub>to the left sibling when k≦A.k<sub>min</sub>.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00006" num="00006" class="claim">
    <div class="claim-text">6. An information management system as recited in <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising mechanisms for performing insert and delete operations, wherein said lookup, insert and delete operations detect if the key range of an index node, A, does not include the key k that the operation is trying to locate, and wherein said operations follow a handle A.h<sub>left </sub>to the left sibling when k≦A.k<sub>min</sub>.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00007" num="00007" class="claim">
    <div class="claim-text">7. An information management system as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising a mechanism for performing a delete operation.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00008" num="00008" class="claim">
    <div class="claim-text">8. An information management system as recited in <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the delete operation detects if the key range of an index node, A, does not include the key k that the operation is trying to locate, and wherein said operation follows a handle A.h<sub>left </sub>to the left sibling when k≦A.k<sub>min</sub>.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00009" num="00009" class="claim">
    <div class="claim-text">9. An information management system as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the B-Tree data structure comprises at least one index node having the following structure:
<div class="claim-text">&lt;h<sub>left</sub>, k<sub>min</sub>, h<sub>0</sub>, k<sub>0</sub>, h<sub>1</sub>, k<sub>1</sub>, . . . , h<sub>n−1</sub>, k<sub>n−1</sub>, h<sub>n</sub>, k<sub>max</sub>, h<sub>right </sub>&gt;</div>
<div class="claim-text">wherein h<sub>left </sub>is a handle of a left sibling and the remaining data elements (k<sub>min</sub>, h<sub>0</sub>, k<sub>0</sub>, h<sub>1</sub>, k<sub>1</sub>, . . . , h<sub>n−1</sub>, k<sub>n−1</sub>, h<sub>n</sub>, k<sub>max</sub>, h<sub>right</sub>) are handles and keys according to a B-Link Tree data structure.</div>
</div>
  </div>
  </div> <div class="claim"> <div id="CLM-00010" num="00010" class="claim">
    <div class="claim-text">10. A B-Tree data structure stored on a computer readable medium, the data structure being useful in a computer's performance of lookup, insert and/or delete operations, comprising a plurality of nodes associated with disk blocks and handles stored in said nodes, wherein at least one left-link handle stored in each node points to a left sibling of that node.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00011" num="00011" class="claim">
    <div class="claim-text">11. A data structure as recited in <claim-ref idref="CLM-00010">claim 10</claim-ref>, comprising at least one index node having the following structure:
<div class="claim-text">&lt;h<sub>left</sub>, k<sub>min</sub>, h<sub>0</sub>, k<sub>0</sub>, h<sub>1</sub>, k<sub>1</sub>, . . . , h<sub>n−1</sub>, k<sub>n−1</sub>, h<sub>n</sub>, k<sub>max</sub>, h<sub>right </sub>&gt;</div>
<div class="claim-text">wherein h<sub>left</sub>, is a left-link handle of a left sibling and the remaining data elements (k<sub>min</sub>, h<sub>0</sub>, k<sub>0</sub>, h<sub>1</sub>, k<sub>1</sub>, . . . , h<sub>n−1</sub>, k<sub>n−1</sub>, h<sub>n</sub>, k<sub>max</sub>, h<sub>right</sub>) are handles and keys according to a B-Link Tree data structure.</div>
</div>
  </div>
  </div> <div class="claim"> <div id="CLM-00012" num="00012" class="claim">
    <div class="claim-text">12. A computer-implemented method, comprising maintaining, in a computer readable medium, a data structure, the data structure being useful in a computer's performance of lookup, insert and/or delete operations, comprising a plurality of nodes and handles stored in said nodes, wherein at least one left-link handle stored in each of said plurality of nodes points to a left sibling of that node.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00013" num="00013" class="claim">
    <div class="claim-text">13. A method as recited in <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising performing an insert operation.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00014" num="00014" class="claim">
    <div class="claim-text">14. A method as recited in <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the insert operation detects if the key range of an index node, A, does not include the key k that the operation is trying to locate, and wherein said operation follows a handle A.h<sub>left </sub>to the left sibling when k≦A.k<sub>min</sub>.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00015" num="00015" class="claim">
    <div class="claim-text">15. A method as recited in <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising a mechanism for performing a delete operation.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00016" num="00016" class="claim">
    <div class="claim-text">16. A method as recited in <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the delete operation detects if the key range of an index node, A, does not include the key k that the operation is trying to locate, and wherein said operation follows a handle A.h<sub>left </sub>to the left sibling when k K≦A.k<sub>min</sub>.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00017" num="00017" class="claim">
    <div class="claim-text">17. A method as recited in <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the data structure comprises at least one index node having the following structure:
<div class="claim-text">&lt;h<sub>left</sub>, k<sub>min</sub>, h<sub>0</sub>, k<sub>0</sub>, h<sub>1</sub>, k<sub>1</sub>, . . . , h<sub>n−1</sub>, k<sub>n−1</sub>, h<sub>n</sub>, k<sub>max</sub>, h<sub>right </sub>&gt;</div>
<div class="claim-text">wherein h<sub>left </sub>is a handle of a left sibling and the remaining data elements (k<sub>min</sub>, h<sub>0</sub>, k<sub>0</sub>, h<sub>1</sub>, k<sub>1</sub>, . . . , h<sub>n−1</sub>, k<sub>n−1</sub>, h<sub>n</sub>, k<sub>max</sub>, h<sub>right</sub>) are handles and keys according to a B-Link Tree data structure.</div>
</div>
  </div>
</div> </div></div></div><div class="patent-section patent-description-section"><div class="patent-section-header"><span class="patent-section-title">Description</span></div><div class="patent-text"><div mxw-id="PDES16077760" lang="EN" load-source="patent-office" class="description">
<heading>CROSS REFERENCE</heading> <p num="p-0002">This application is a continuation of U.S. application Ser. No. 10/308,293, filed Dec. 2, 2002, now pending, which is hereby incorporated by reference in its entirety. The present application is also related by subject matter to co-pending application Ser. No. 10/308,291, filed Dec. 2, 2002, entitled “Deletion and Compaction Using Versioned Nodes.”</p>
<heading>COPYRIGHT NOTICE/PERMISSION</heading> <p num="p-0003">A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent files or records, but otherwise reserves all copyright rights whatsoever.</p>
  <heading>TECHNICAL FIELD</heading> <p num="p-0004">The present invention relates generally to the field of information management systems (sometimes also called information retrieval systems) that store, organize and retrieve data, including but not limited to database management and file systems, and more particularly to novel data structures and algorithms for use in such systems. The invention is particularly suited for, but by no means limited to, uses in connection with B-Tree data structures and variants thereof, and SQL-type databases.</p>
  <heading>BACKGROUND</heading> <p num="p-0005">B-Trees are a core technology to relational and non-relational databases, as well as to file systems and other systems in which a data structure including a set of linked nodes is employed as a way to index and access large amounts of data. A database management system is one example of an information management/retrieval system of the kind for which the present invention is suited. Nevertheless, because the present invention is well suited for use in connection with a database, although by no means limited thereto, the background and exemplary embodiments will be discussed with reference to a database.</p>
  <p num="p-0006">Concurrent B-Trees with minimal locking are instrumental for building distributed databases, where a single relation may span multiple machines. Distributing relations over multiple machines makes it possible to build scalable databases, where the size of the database can be increased simply by adding more hardware.</p>
  <p num="p-0007">The present invention is concerned with ways to increase the efficiency of concurrent B-Tree algorithms. As discussed in greater detail below, the subject matter disclosed herein is directed to (a) maintaining extra data that prevents B-Tree operations from getting “lost” in the tree, which may happen in state-of-the-art algorithms due to aggressive minimization of locking operations, and (b) garbage-collecting deleted nodes without the need for any extra synchronization (the state-of-the-art algorithm uses a time-stamp-based approach to garbage collection, and requires extra synchronization to keep track of the start times of all outstanding B-Tree operations).</p>
  <p num="p-0008">Further background information about B-Trees may be found in the following documents:
</p> <ul> <li id="ul0001-0001" num="0008">1. R. Bayer and E. McCreight. Organization and Maintenance of Large Ordered Indexes. Acta Informatica, 1(3):173–189, 1972.</li> <li id="ul0001-0002" num="0009">2. D. Corner. The Ubiquitous B-Tree. ACM Computing Surveys, 11(2):121–128, June 1979.</li> <li id="ul0001-0003" num="0010">3. P. L. Lehman and S. B. Yao. Efficient Locking for Concurrent Operations on B-Trees. ACM Transactions on Information retrieval systems, 6(4):650–670, December 1981.</li> <li id="ul0001-0004" num="0011">4. Yehoshua Sagiv. Concurrent Operations on B-Trees with Overtaking. Journal of Computer and System Sciences, Vol. 3, No. 2, October 1986.</li> <li id="ul0001-0005" num="0012">5. Paul Wang. An In-Depth Analysis of Concurrent B-Tree Algorithms. Technical report MIT/LCS/TR-496, Laboratory for Computer Science, Massachusetts Institute of Technology, February 1991.</li> <li id="ul0001-0006" num="0013">6. H. Wedekind. On the selection of access paths in an information retrieval system. In J. W. Klimbie and K. L. Koffman, editors. Database Management, pages 385–397. North Holland Publishing Company, 1974.</li> </ul> <heading>SUMMARY</heading> <p num="p-0009">An information management system disclosed herein includes a computer and a database, wherein the database comprises one or more B-Tree data structure(s) each comprising a plurality of nodes associated with disk blocks (or more generally, “storage blocks,” in the event the invention is employed in connection with a storage medium other than disk) and handles stored in the nodes (and optionally version numbers associated with each of the handles and nodes). At least one left-link handle, h<sub>left</sub>, stored in each node points to a left sibling of that node. A mechanism for performing a lookup operation with respect to a key, k, traverses the B-Tree and refers to the left-link handle, h<sub>left</sub>, of a node to access a left sibling of the node if the key k is less than or equal to a value k<sub>min </sub>stored in the node. Mechanisms are also provided for performing insert and delete operations, and the lookup, insert, and delete operations detect if the key range of an index node, A, does not include the key k that the operation is trying to locate, and follow a handle A.h<sub>left </sub>to the left sibling when k≦A.k<sub>min</sub>.</p>
  <p num="p-0010">Note that a “node” may span multiple disk or storage blocks, and that links and version numbers may be logically associated with nodes as opposed to individual disk blocks.</p>
  <p num="p-0011">These and other features are described below.</p>
<description-of-drawings> <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading> <p num="p-0012"> <figref idrefs="DRAWINGS">FIGS. 1 and 2</figref> are schematic illustrations of exemplary computing environments, with <figref idrefs="DRAWINGS">FIG. 2</figref> depicting an example of a B-Link-Tree data structure stored in a persistent store such as (but not limited to) a database.</p>
    <p num="p-0013"> <figref idrefs="DRAWINGS">FIG. 3A</figref> is a simplified schematic illustration of a B-Link Tree in accordance with the prior art.</p>
    <p num="p-0014"> <figref idrefs="DRAWINGS">FIG. 3B</figref> is a schematic illustration of a B-Link Tree.</p>
    <p num="p-0015"> <figref idrefs="DRAWINGS">FIGS. 3C and 3D</figref> show examples of a Sagiv-style B-Link Tree (see discussion below) in accordance with the prior art and a B-Link Tree containing left links, respectively.</p>
    <p num="p-0016"> <figref idrefs="DRAWINGS">FIGS. 3E and 3F</figref> show examples of pseudocode for lookup procedures employing links to left siblings and version numbers, respectively.</p>
    <p num="p-0017"> <figref idrefs="DRAWINGS">FIG. 4</figref> is a flowchart of a procedure, GetNextHandle, which procedure takes an index node X and a key k and returns (h, isLink), where h is a handle and isLink is a boolean value indicating whether h is a link to a sibling of X.</p>
    <p num="p-0018"> <figref idrefs="DRAWINGS">FIG. 5</figref> is a flowchart of a procedure, InsertPair, which takes an index node X, a key k, and a handle h and inserts a key-handle pair into X.</p>
    <p num="p-0019"> <figref idrefs="DRAWINGS">FIG. 6</figref> is a flowchart of a procedure, CreateTree, which returns a prime node handle hp identifying a new tree.</p>
    <p num="p-0020"> <figref idrefs="DRAWINGS">FIG. 7</figref> is a flowchart of a procedure, Lookup, which takes a prime node handle hp and a key k and returns a data item d or null.</p>
    <p num="p-0021"> <figref idrefs="DRAWINGS">FIG. 8</figref> is a flowchart of a procedure, Delete, which takes a prime node handle hp and a key k and deletes the key and its associated data value from the tree identified by hp.</p>
    <p num="p-0022"> <figref idrefs="DRAWINGS">FIG. 9</figref>, made up of subparts <b>9</b>A, <b>9</b>B, <b>9</b>C, <b>9</b>D, and <b>9</b>E, is a flowchart of a procedure, Insert, which takes a prime node handle hp, a key value k, and a data value d and inserts the key value and the data value into the tree identified by hp.</p>
    <p num="p-0023"> <figref idrefs="DRAWINGS">FIG. 10</figref> is a flowchart of a background procedure, Compress, that takes a prime node handle hp and compresses the tree identified by hp.</p>
    <p num="p-0024"> <figref idrefs="DRAWINGS">FIG. 11</figref>, made up of subparts <b>11</b>A, <b>11</b>B, and <b>11</b>C, is a flowchart of a procedure, CompressLevel, which compresses a level.</p>
    <p num="p-0025"> <figref idrefs="DRAWINGS">FIG. 12</figref> is a flowchart of a procedure, MergeNodes, which merges two nodes.</p>
    <p num="p-0026"> <figref idrefs="DRAWINGS">FIG. 13</figref> is a flowchart of a procedure MoveToLeft that moves parts of a node to its left sibling.</p>
    <p num="p-0027"> <figref idrefs="DRAWINGS">FIG. 14</figref> is a flowchart of a procedure MoveToRight that moves parts of a node to its right sibling.</p>
  </description-of-drawings> <heading>DETAILED DESCRIPTION</heading> <p num="p-0028">We will now describe presently preferred implementations of the invention. First, in section A, we will describe an exemplary computing environment with reference to <figref idrefs="DRAWINGS">FIG. 1</figref>, primarily to show that the invention may be embodied in a wide variety of ways, e.g., in a data structure stored on a computer readable medium and/or a software-based process carried out on a general purpose computer. (It is well known that a B-tree algorithm requires two fundamental things: code and data structures that this code manipulates. The code can be embodied in a variety of places including in a process or in firmware. The data can be kept anywhere (with different degrees of persistence, e.g., RAM, disk, removable media, etc.). Following this description, we provide, in section B, an overview of two main aspects of the inventive data structures and methods disclosed herein. These two main aspects include (1) versioned nodes to facilitate deletion and compaction operations, and (2) left links to facilitate tree traversal operations. Sections C through F describe further details of exemplary ways in which the present invention may be implemented. Finally, section G provides a conclusion.</p>
  <p num="p-0029">A. Exemplary Computing Environment</p>
  <p num="p-0030"> <figref idrefs="DRAWINGS">FIG. 1</figref> illustrates an example of a suitable computing system environment <b>100</b> in which the invention may be implemented. The computing system environment <b>100</b> is only one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should the computing environment <b>100</b> be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment <b>100</b>.</p>
  <p num="p-0031">The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, disk controllers, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.</p>
  <p num="p-0032">The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment, program modules and other data may be located in both local and remote computer storage media including memory storage devices.</p>
  <p num="p-0033">With reference to <figref idrefs="DRAWINGS">FIG. 1</figref>, an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer <b>110</b>. Components of computer <b>110</b> may include, but are not limited to, a processing unit <b>120</b>, a system memory <b>130</b>, and a system bus <b>121</b> that couples various system components including the system memory to the processing unit <b>120</b>. The system bus <b>121</b> may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).</p>
  <p num="p-0034">Computer <b>110</b> typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer <b>110</b> and includes both volatile and non-volatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer <b>110</b>. Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term “modulated data signal” means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.</p>
  <p num="p-0035">The system memory <b>130</b> includes computer storage media in the form of volatile and/or non-volatile memory such as ROM <b>131</b> and RAM <b>132</b>. A basic input/output system <b>133</b> (BIOS), containing the basic routines that help to transfer information between elements within computer <b>110</b>, such as during start-up, is typically stored in ROM <b>131</b>. RAM <b>132</b> typically contains data and/or program modules that are immediately accessible to and/or presently being operated on by processing unit <b>120</b>. By way of example, and not limitation, <figref idrefs="DRAWINGS">FIG. 1</figref> illustrates operating system <b>134</b>, application programs <b>135</b>, other program modules <b>136</b>, and program data <b>137</b>.</p>
  <p num="p-0036">The computer <b>110</b> may also include other removable/non-removable, volatile/non-volatile computer storage media. By way of example only, <figref idrefs="DRAWINGS">FIG. 1</figref> illustrates a hard disk drive <b>140</b> that reads from or writes to non-removable, non-volatile magnetic media, a magnetic disk drive <b>151</b> that reads from or writes to a removable, non-volatile magnetic disk <b>152</b>, and an optical disk drive <b>155</b> that reads from or writes to a removable, non-volatile optical disk <b>156</b>, such as a CD-ROM or other optical media. Other removable/non-removable, volatile/non-volatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive <b>141</b> is typically connected to the system bus <b>121</b> through a non-removable memory interface such as interface <b>140</b>, and magnetic disk drive <b>151</b> and optical disk drive <b>155</b> are typically connected to the system bus <b>121</b> by a removable memory interface, such as interface <b>150</b>.</p>
  <p num="p-0037">The drives and their associated computer storage media, discussed above and illustrated in <figref idrefs="DRAWINGS">FIG. 1</figref>, provide storage of computer readable instructions, data structures, program modules and other data for the computer <b>110</b>. In <figref idrefs="DRAWINGS">FIG. 1</figref>, for example, hard disk drive <b>141</b> is illustrated as storing operating system <b>144</b>, application programs <b>145</b>, other program modules <b>146</b>, and program data <b>147</b>. Note that these components can either be the same as or different from operating system <b>134</b>, application programs <b>135</b>, other program modules <b>136</b>, and program data <b>137</b>. Operating system <b>144</b>, application programs <b>145</b>, other program modules <b>146</b>, and program data <b>147</b> are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer <b>110</b> through input devices such as a keyboard <b>162</b> and pointing device <b>161</b>, commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish (where the dish is used to receive signals to be input to a computer), scanner, or the like. These and other input devices are often connected to the processing unit <b>120</b> through a user input interface <b>160</b> that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor <b>191</b> or other type of display device is also connected to the system bus <b>121</b> via an interface, such as a video interface <b>190</b>. In addition to the monitor, computers may also include other peripheral output devices such as speakers <b>197</b> and printer <b>196</b>, which may be connected through an output peripheral interface <b>190</b>.</p>
  <p num="p-0038">The computer <b>110</b> may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer <b>180</b>. The remote computer <b>180</b> may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer <b>110</b>, although only a memory storage device <b>181</b> has been illustrated in <figref idrefs="DRAWINGS">FIG. 1</figref>. The logical connections depicted include a local area network (LAN) <b>171</b> and a wide area network (WAN) <b>173</b>, but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, storage area networks (SANs), intranets and the Internet.</p>
  <p num="p-0039">When used in a LAN networking environment, the computer <b>110</b> is connected to the LAN <b>171</b> through a network interface or adapter <b>170</b>. When used in a WAN networking environment, the computer <b>110</b> typically includes a modem <b>172</b> or other means for establishing communications over the WAN <b>173</b>, such as the Internet. The modem <b>172</b>, which may be internal or external, may be connected to the system bus <b>121</b> via the user input interface <b>160</b>, or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer <b>110</b>, or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation, <figref idrefs="DRAWINGS">FIG. 1</figref> illustrates remote application programs <b>185</b> as residing on memory device <b>181</b>. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.</p>
  <p num="p-0040">B. Overview: Versioned Nodes and Left Links</p>
  <p num="p-0041">The present invention generally improves on previous methods for traversing concurrent B-Trees, and in particular it improves on an algorithm by Yehoshua Sagiv (we refer to this as the “Sagiv algorithm”). As discussed above, a B-Tree is a data structure that maintains an association of “keys” (such as employee numbers) to “values” (such as employee records). B-Trees are typically stored on disk. B-Trees are at the foundation of most information retrieval systems.</p>
  <p num="p-0042"> <figref idrefs="DRAWINGS">FIG. 2</figref> depicts a typical information retrieval system <b>200</b>. As shown, such a system can include a server <b>202</b> and a persistent store, such as a database, <b>204</b>. In addition, the data residing in the store <b>204</b> may be organized in the form of a tree, e.g., a B-Link-Tree <b>206</b>. Such a data structure includes nodes, N<b>1</b>, N<b>2</b>, N<b>3</b> and so on, and, in the case of index nodes, links from each node to at least one other node (data nodes typically have only incoming links). The nodes may be sized to correspond to a disk block, or may be bigger or smaller, and may be formed as data nodes and index nodes (discussed further below in connection with <figref idrefs="DRAWINGS">FIG. 3A</figref>). Further, there is a root node (node N<b>1</b> in <figref idrefs="DRAWINGS">FIG. 2</figref>) and children nodes, with sibling nodes being those nodes that have a common parent (e.g., nodes N<b>2</b> and N<b>3</b> are siblings). Index nodes may also be linked to their right siblings, as shown.</p>
  <p num="p-0043">Information retrieval systems typically support concurrent access to and updating of the data maintained by them, which means that there may be multiple concurrent lookup and update operations on the underlying B-Tree. In order to prevent these concurrent operations from corrupting the B-Tree, some synchronization scheme is required. Typical concurrent B-Tree algorithms synchronize concurrent operations at the node-level of the tree; that is, an operation that wants to modify a node of the tree has to acquire a lock on that node, in order to guarantee that it does not interfere with another concurrent update (or other) operation on the same node.</p>
  <p num="p-0044">Lock acquisition is expensive in several respects: It can be computationally expensive (in particular when the B-tree is replicated across multiple computers, meaning that locks have to be acquired from a remote lock server), and it limits concurrency. It is therefore desirable to minimize the number of lock acquisitions (without compromising the correctness of the algorithm). Much research has been devoted to this topic (Paul Wang, <i>An In</i>-<i>Depth Analysis of Concurrent B</i>-<i>Tree Algorithms</i>, cited above, contains a good survey of work on this problem.) To our knowledge, the B-Tree algorithm that performs best with respect to minimizing lock acquisitions is the Sagiv algorithm (see Yehoshua Sagiv, <i>Concurrent Operations on B</i>-<i>Trees with Overtaking</i>, cited above).</p>
  <p num="p-0045">The system described herein improves on Sagiv's algorithm in two respects: First, it avoids an inefficiency of Sagiv's algorithm, namely that operations may get “lost” while trying to locate a data record and have to be restarted; second, it introduces a scheme for garbage-collecting deleted nodes that does not require any additional lock acquisitions, while Sagiv's technique requires additional locking. The two optimizations are independent of each other, that is, Sagiv's algorithm can be improved by adding either one or both.</p>
  <p num="p-0046">Before describing the invention, it is helpful to review B-Trees in general and Sagiv's algorithm in particular.</p>
  <p num="p-0047">C. B-Trees and the Sagiv Algorithm</p>
  <p num="p-0048">A B-Tree is a data structure that maintains an association of keys with values. A prerequisite is that there exists a total ordering over the keys, i.e., that it is always possible to decide whether one key is larger than the other. As indicated in <figref idrefs="DRAWINGS">FIG. 2</figref>, reference number <b>208</b>, B-Trees support three basic operations:
</p> <ul> <li id="ul0002-0001" num="0054">1) insert(k, v), which associates the key k with the value v;</li> <li id="ul0002-0002" num="0055">2) lookup(k), which returns the value v associated with the key k; and</li> <li id="ul0002-0003" num="0056">3) delete(k), which disassociates the key k from its associated value.</li> </ul> <p num="p-0049">B-Trees were first described by Bayer and McCreight (R. Bayer and E. McCreight, <i>Organization and Maintenance of Large Ordered Indexes</i>, cited above). There are many variations of B-Trees, including B*-trees (see H. Wedekind, <i>On the selection of access paths in an information retrieval system</i>, cited above), B+-Trees (see D. Corner, <i>The Ubiquitous B</i>-<i>Tree</i>, ACM Computing Surveys, cited above), and B-Link Trees (see P. L. Lehman and S. B. Yao, <i>Efficient Locking for Concurrent Operations on B</i>-<i>Trees</i>, cited above). Sagiv's algorithm uses B-Link Trees. The present invention is applicable to all types of B-Trees and variations thereof, and the term B-Tree as used herein in describing the invention is intended to encompass all variants of the basic B-Tree structure. Preferred embodiments of the invention use a new form of B-Link Tree.</p>
  <p num="p-0050">A B-Link Tree (and in fact any B-Tree) stores keys and values as well as metadata in nodes. Nodes are kept on disk or some other storage device (B-Trees make sense for any slow and cheap storage device), and are read into main memory on demand, and written back to disk if modified. Nodes on disk are identified by handles. (For the purpose of this discussion, it is sufficient to think of handles as the addresses of contiguous ranges of storage blocks (e.g., disk block addresses) plus optional metadata.) As indicated in <figref idrefs="DRAWINGS">FIG. 2</figref>, reference numeral <b>210</b>, an allocator is a software component that maintains nodes on disk and supports four operations:
</p> <ul> <li id="ul0003-0001" num="0059">1) allocate(n), which reserves space on the disk for a node with a maximum size of n bytes and returns a handle to it;</li> <li id="ul0003-0002" num="0060">2) deallocate(h), which relinquishes the space at the disk location identified by the handle h;</li> <li id="ul0003-0003" num="0061">3) read(h), which reads the node from the disk location identified by the handle h and returns it; and</li> <li id="ul0003-0004" num="0062">4) write(h, A), which writes the node A from main memory to the disk location identified by handle h.</li> </ul> <p num="p-0051">In the following discussion, we assume that the allocator operations are atomic, that is, two concurrent operations on the same handle do not interfere with each other.</p>
  <p num="p-0052">Nodes in a B-Tree may contain handles referring to other nodes. In most B-Tree variants, the handles connect the nodes to form a tree (hence the name), a directed, connected, and acyclic graph. In the following, we assume the reader to be familiar with the definition of a tree and the terms subtree, link, root, leaf, parent, child, and sibling. B-Link Trees differ from proper trees in that in addition to the links from parents to children, every node has a link to its directly adjacent right sibling (if such a sibling exists). This can be seen in the exemplary B-Link Tree <b>300</b> of <figref idrefs="DRAWINGS">FIG. 3A</figref>, where the “right link” (link to right sibling) is represented by reference numeral <b>302</b>.</p>
  <p num="p-0053">The B-Link Trees used by Sagiv are composed of two different kinds of nodes: data nodes and index nodes, reference numerals <b>304</b> and <b>306</b>, respectively, of <figref idrefs="DRAWINGS">FIG. 3A</figref>. A data node is simply a key-value pair of the form &lt;k,d&gt;. An index node is of the form:
</p> <ul> <li id="ul0004-0001" num="0066">&lt;k<sub>min</sub>, h<sub>0</sub>, k<sub>0</sub>, h<sub>1</sub>, k<sub>1</sub>, . . . , h<sub>n−1</sub>, k<sub>n−1</sub>, h<sub>n</sub>, k<sub>max</sub>, h<sub>right</sub>&gt;</li> </ul> <p num="p-0054">In the following, we refer to field x of node A as A.x. Given an index node A, A.h<sub>0</sub>, . . . A.h<sub>n </sub>are handles to the n+1 children of A, and A.h<sub>right </sub>is a handle to its right sibling. A.k<sub>i </sub>(for 0≦i&lt;n) is the largest key in the subtree rooted at handle A.h<sub>i</sub>., and A.k<sub>i−1 </sub>(or A.k<sub>min </sub>if i=0) is less than the smallest key in the subtree rooted at handle A.<sub>i</sub>. In. A.k<sub>max </sub>is greater or equal to the largest key in any subtree of A (and per definition ∞ if A does not have a right sibling), and A.k<sub>min </sub>is equal to B.k.<sub>max</sub>, where B is the left sibling of A (or −∞ if A does not have a left sibling). Moreover, A.k<sub>min</sub>&lt;A.k<sub>0</sub>&lt; . . . &lt;A.k<sub>n</sub>≦A.k<sub>max</sub>. Finally, there is a limit on the size of n (which indicates the number of keys and handles in an index node). If n reaches a maximum value (say, 2t), then the index node is said to be full. Likewise, if n falls below a certain number (say, t), the node is said to be underfull.</p>
  <p num="p-0055">Because of the constraints on the keys in an index node and the keys in the subtrees rooted at that node, B-Link trees are search trees, that is, trees where one can find a particular key by descending into the tree. Intuitively, lookup(k) starts at the root handle, reads in the corresponding node A, and identifies a value i such that A.k<sub>i−1 </sub>(or A.k<sub>min </sub>if i=0)&lt;k≦A.k<sub>i </sub>(or A.k<sub>max </sub>if i=n). It then recursively proceeds along the handle A.h<sub>i </sub>until it reaches a data node B, and returns B's value if B's key is indeed k, or null otherwise.</p>
  <p num="p-0056">The delete operation is similar to the lookup operation: delete(k) descends into the tree until a data node D with key k is discovered (if such a node exists). The operation then marks D as deleted (D is not immediately deallocated, because other ongoing operations may have a handle to D but not yet have read D), and removes the handle to D from D's parent node A. This may cause A to become underfull.</p>
  <p num="p-0057">The insert operations is more complicated: insert(k,v) allocates a new data node D with handle h, writes the pair (k,v) to it, and then recursively descends into the tree the same way as lookup does, until it finds the leaf index node A (the index node whose children are data nodes) that should receive h. If A is not full, insert(k,v) simply inserts h and k at the appropriate places into A; otherwise, it allocates a new index node Ā, moves half of A's key-handle pairs over to Ā, inserts k and h into A or Ā, and finally adds the handle to Ā and A's new k<sub>max </sub>to A's parent (this may in turn cause A's parent to become overfull, causing the node splitting process to move up the tree).</p>
  <p num="p-0058">As mentioned above, the delete operation may cause nodes to become underfull. To prevent too many nodes from becoming underfull (which would cause the tree to become deeper than it needs to be, which would increase the number of disk accesses required by each operation), a compression thread is run in the background. The thread repeatedly traverses the tree, searching for underfull nodes. When it locates an underfull node A, it either rebalances it with its left or right sibling (which entails moving key-handle pairs from the sibling to A, and adjusting a key in the parent node), or it outright merges A with its left or right sibling (which entails moving all of A's content to the sibling, marking A as deleted, and removing A's handle and corresponding key from A's parent, which in turn may cause the parent to become underfull).</p>
  <p num="p-0059">In Sagiv's algorithm, nodes that are marked as deleted are deallocated only when it is certain that no operations have handles to those nodes. This is achieved by adding a timestamp to each deleted node, indicating the time it was deleted, and maintaining a table that records the start time of every lookup, insert, and delete operation in flight. The system maintains a list of deleted nodes. The compression thread periodically goes through the list, and deletes exactly those nodes whose timestamp predates the start times of all ongoing operations. The drawback of this scheme is that the table of start times is accessed by many threads, which means it has to be protected by a lock. Each operation requires two lock acquisitions and releases (one for adding a thread-start time pair to the table, and one for removing it).</p>
  <p num="p-0060">The situation is further complicated by the fact that concurrent lookup, insert, and delete operations may interfere with one another. This could be avoided by locking every node visited during an operation, and unlocking it only once the child or sibling referenced by any extracted handle has been read (this is called “lock coupling” in the literature). Sagiv's algorithm avoids such excessive locking by using the optimistic assumption that operations usually don't interfere, detecting the cases in which this assumption was unwarranted, and recovering from the misstep.</p>
  <p num="p-0061">To make things concrete, consider the case where the operation lookup(k) decides to follow a handle h, but before it can read the corresponding node A, another thread inserts a key-handle pair into A, and in the process splits A into two nodes, A and Ā (the newly allocated right sibling of A). After reading A, the lookup operation can detect the fact that A was split (because k&gt;A.k<sub>max</sub>), and can recover from this situation by following the A.h<sub>right </sub>handle, leading it to Ā (which indeed contains the appropriate range of keys). However, this inexpensive recovery is not always possible. Consider the case where the operation lookup(k) decides to follow a handle h, but before it can read the corresponding node A, the compression thread rebalances node A (which happens to be underfuill), moving some of A's content, including the handle that lookup should follow, to A's left sibling Ā. After reading A, the lookup operation can detect that A has been rebalanced (because k≦A.k<sub>min</sub>), but since lookup does not know the handle of Ā, the only way to recover is to restart the lookup operation at the root of the tree.</p>
  <p num="p-0062">D. Maintaining Handles to Left Siblings</p>
  <p num="p-0063">According to first aspect of the present invention, to avoid restarts, we propose to modify the structure of index nodes as follows:
</p> <ul> <li id="ul0005-0001" num="0077">&lt;h<sub>left</sub>, k<sub>min</sub>, h<sub>0</sub>, k<sub>0</sub>, h<sub>1</sub>, k<sub>1</sub>, . . . , h<sub>n−1</sub>, k<sub>n−1</sub>, h<sub>n</sub>, k<sub>max</sub>, h<sub>right </sub>&gt;
<br>
where h<sub>left </sub>is the handle of the left sibling (if there is one, and null otherwise), and all other fields are defined as in Sagiv's algorithm. This data structure is depicted in <figref idrefs="DRAWINGS">FIG. 3B</figref>, where reference <b>300</b>′ refers to the modified B-Link data structure and reference numeral <b>310</b> refers specifically to the left link, i.e., h<sub>left</sub>. As in Sagiv's algorithm, the lookup, insert, and delete operations detect if the key range of an index node A does not include the key k that the operation is trying to locate. As in Sagiv's algorithm, the operation reacts to k&gt;A.k<sub>max </sub>by following the handle A.h<sub>right </sub>to the right sibling. However, while Sagiv's algorithm reacted to k≦A.k<sub>min </sub>by restarting the operation at the root, our algorithm reacts by following the handle A.h<sub>left </sub>to the left sibling. Following the handle to the left sibling requires one extra read operation, while restarting the operation at the root would require up to (and typically close to) d read operations, where d is the depth of the tree.
</li> </ul> <p num="p-0064"> <figref idrefs="DRAWINGS">FIGS. 3C and 3D</figref> provide more detailed examples of a Sagiv-style B-Link Tree in accordance with the prior art, and a B-Link tree in accordance with the present invention, respectively. These are intended to further illustrate the left-link aspect of the present invention, and to distinguish it from the prior art.</p>
  <p num="p-0065"> <figref idrefs="DRAWINGS">FIG. 3C</figref> depicts a Sagiv-style B-Link tree that contains the mapping {(<b>2</b>, Miller), (<b>5</b>, Smith), (<b>7</b>, Jones), (<b>10</b>, Brown), (<b>12</b>, Levin), (<b>15</b>, Dahl), (<b>17</b>, Lewis), (<b>20</b>, Yu)}. The numbers are key values and the names are the associated data values. P is the prime node of the tree; I<b>1</b>, . . . , I<b>7</b> are index nodes; and D<b>1</b>, . . . , D<b>8</b> are data nodes. A prime node is a node containing an array of handles, each handle pointing to the leftmost index node of a level of the tree, with the first handle in the prime node pointing to the leftmost leaf index node, and the last one pointing to the root index node. I<b>1</b> is the root node of the tree (that is, the one index node that does not have a parent). One gets to the root node by following the last handle in the prime node (P[2] in this case). I<b>1</b>, I<b>2</b>, I<b>3</b> are non-leaf index nodes (that is, index nodes that have index-node children). This means that I<b>1</b>.h<sub>0 </sub>is non-null, and that IsLeaf(I<b>1</b>) (IsLeaf is discussed below-see section F) is false (the same is true for I<b>2</b>, I<b>3</b>). I<b>4</b>, I<b>5</b>, I<b>6</b>, and I<b>7</b> are leaf index nodes, that is, index nodes that do not have index-node children. This means that I<b>4</b>.h<sub>0 </sub>is null, and that IsLeaf(I<b>4</b>) is true (the same is true for I<b>5</b>, I<b>6</b>, and I<b>7</b>). In this tree, t=2; that is, each index node can hold two keys in addition to k<sub>min </sub>and k<sub>max</sub>. I<b>1</b>, I<b>2</b>, and I<b>3</b> are not full (some fields are unused and shaded out). Num(I<b>1</b>) (Num is discussed below—see section F) is 1 (the same is true for I<b>2</b>, I<b>3</b>). I<b>1</b>, I<b>2</b>, and I<b>3</b> can each take one more key-handle pair. I<b>4</b>, I<b>5</b>, I<b>6</b>, and I<b>7</b> are full, i.e., there are no unused fields. Num(I<b>4</b>) is 2 (same for I<b>5</b>, I<b>6</b>, and I<b>7</b>).</p>
  <p num="p-0066"> <figref idrefs="DRAWINGS">FIG. 3D</figref> depicts a tree that contains left links h<sub>left</sub>, as shown. The tree contains the same mapping, {(<b>2</b>, Miller), (<b>5</b>, Smith), (<b>7</b>, Jones), (<b>10</b>, Brown), (<b>12</b>, Levin), (<b>15</b>, Dahl), (<b>17</b>, Lewis), (<b>20</b>, Yu)}, as the tree in <figref idrefs="DRAWINGS">FIG. 3C</figref>. As before, the numbers are key values, the names are the associated data values. P is the prime node of the tree, I<b>1</b>, . . . , I<b>7</b> are index nodes, D<b>1</b>, . . . , D<b>8</b> are data nodes. I<b>1</b> is the root node of the tree (that is, the one index node that does not have a parent). One gets to the root node by following the last handle in the prime node (P[2] in this case). I<b>1</b>, I<b>2</b>, I<b>3</b> are non-leaf index nodes (that is, index nodes that have index-node children). This means that I<b>1</b>.h<sub>0 </sub>is non-null, and that IsLeaf(I<b>1</b>) is false (same for I<b>2</b>, I<b>3</b>). I<b>4</b>, I<b>5</b>, I<b>6</b>, and I<b>7</b> are leaf index nodes (that is, index nodes that don't have index-node children). This means that I<b>4</b>.h<sub>0 </sub>is null, and that IsLeaf(I<b>4</b>) is true (same for I<b>5</b>, I<b>6</b>, and I<b>7</b>). In this tree, t=2 (that is, each index node can hold two keys in addition to k<sub>min </sub>and k<sub>max</sub>). I<b>1</b>, I<b>2</b>, and I<b>3</b> are not full (some fields are unused and shaded out). Num(I<b>1</b>) is 1 (same for I<b>2</b>, I<b>3</b>). I<b>1</b>, I<b>2</b>, and I<b>3</b> can each take one more key-handle pair. I<b>4</b>, I<b>5</b>, <b>6</b>, and I<b>7</b> are full (there are no unused fields). Num(I<b>4</b>) is 2 (same for I<b>5</b>, I<b>6</b>, and I<b>7</b>).</p>
  <p num="p-0067">To further illustrate the idea, we have produced below exemplary pseudocode of Sagiv's lookup operation (adapted from Yehoshua Sagiv, <i>Concurrent Operations on B</i>-<i>Trees with Overtaking</i>, cited above), including the code for restarting the lookup operation if the lookup goes astray (but omitting the machinery for keeping track of operation start times):</p>
  <p num="p-0068">
    <tables id="TABLE-US-00001" num="00001"> <table frame="none" colsep="0" rowsep="0" class="description-table"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="21pt" align="left"> </colspec> <colspec colname="1" colwidth="196pt" align="left"> </colspec> <thead> <tr class="description-tr"> <td class="description-td"> </td>
              <td namest="offset" nameend="1" align="center" rowsep="1" class="description-td" colspan="2"> </td>
            </tr> </thead> <tbody valign="top"> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">procedure Lookup(h<sub>P</sub>: Handle, k : Key)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   var h: Handle, A: Node;</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">label start:</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   P := Read(h<sub>P</sub>)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   h := last item in P</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   repeat</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">     A := read(h)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">     if k &gt; A.k<sub>max </sub>then</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">        h := A.h<sub>right</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">     else if k ≦ A.k<sub>min </sub>then</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">        goto start</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">     else</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">        choose i such that A.k<sub>i−1 </sub>&lt; k ≦ A.k<sub>i </sub>(let i be</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">        0 if Num(A) = 0)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">        h := A.h<sub>i</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">     endif</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   until A is a leaf and A.k<sub>min </sub>&lt; k ≦ A.k<sub>max</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   if k is contained in A then</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">     return corresponding value</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   else</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">     return null</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   endif</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">endproc</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td namest="offset" nameend="1" align="center" rowsep="1" class="description-td" colspan="2"> </td>
            </tr> </tbody> </tgroup> </table> </tables> </p>
  <p num="p-0069">In contrast, here is exemplary pseudocode corresponding to one implementation of a lookup routine in accordance with the present invention. (Note that <figref idrefs="DRAWINGS">FIG. 7</figref> depicts a flowchart of another exemplary Lookup procedure.) As can be seen, this routine follows the left-link instead of restarting the operation. This pseudocode is reproduced in <figref idrefs="DRAWINGS">FIG. 3E</figref> with a box <b>320</b> enclosing new lines of code designed to utilize the left-link data. The new lines of code determine whether the key value k is less than or equal to the value stored in the k<sub>min </sub>field of node A, and if so it assigns the left-link handle to the handle variable (i.e., h:=A.h<sub>left</sub>).</p>
  <p num="p-0070">
    <tables id="TABLE-US-00002" num="00002"> <table frame="none" colsep="0" rowsep="0" class="description-table"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="21pt" align="left"> </colspec> <colspec colname="1" colwidth="196pt" align="left"> </colspec> <thead> <tr class="description-tr"> <td class="description-td"> </td>
              <td namest="offset" nameend="1" align="center" rowsep="1" class="description-td" colspan="2"> </td>
            </tr> </thead> <tbody valign="top"> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">procedure Lookup(h<sub>P</sub>: Handle, k : Key)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   var h: Handle, A: Node;</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   P := Read(h<sub>P</sub>)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   h := last item in P</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   repeat</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">     A := read(h)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">     if k &gt; A.k<sub>max </sub>then</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">        h := A.h<sub>right</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">     else if k ≦ A.k<sub>min </sub>then</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">        h := A.h<sub>left</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">     else</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">        choose i such that A.k<sub>i−1 </sub>&lt; k ≦ A.k<sub>i </sub>(let i be</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">        0 if Num(A) = 0)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">        h := A.h<sub>i</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">     endif</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   until A is a leaf and A.k<sub>min </sub>&lt; k ≦ A.k<sub>max</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   if k is contained in A then</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">     return corresponding value</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   else</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">     return null</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   endif</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">endproc</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td namest="offset" nameend="1" align="center" rowsep="1" class="description-td" colspan="2"> </td>
            </tr> </tbody> </tgroup> </table> </tables> </p>
  <p num="p-0071">E. Attach Version Numbers to Handles and Disk Blocks</p>
  <p num="p-0072">We will now describe an inventive way to avoid maintaining a table of operation start times. In particular, in a presently preferred implementation, we do this by attaching version numbers to handles and nodes or the “unit of allocation” returned by the allocator <b>210</b> (<figref idrefs="DRAWINGS">FIG. 2</figref>). As mentioned above, when a node is deleted by the delete operation or by the compression thread, it is possible that a concurrent operation has a handle to it. Sagiv's algorithm deals with this problem by attaching a timestamp noting the time of deletion to every deleted node, and by recording the start time of every operation. Deleted nodes are “garbage collected” only when none of the ongoing operations have been started before the node was marked as deleted. This solution requires the system to maintain a table mapping threads to start times, which requires two synchronizations—one for adding a thread-start time pair to the table and one for removing it—since the table is being mutated by the client threads and accessed by the compression thread.</p>
  <p num="p-0073">According to a presently preferred implementation of our invention, version numbers are attached to each handle and to each node. Initially, each node has version number 0. The allocate operation (described above) returns a handle identifying a node and embeds the node's version number into the handle. The deallocate operation increments the node's version number (in addition to making it available for subsequent reallocation). The read operation returns a node's version number in addition to the node. The caller of the read operation (i.e., a lookup, insert, or delete operation) checks if the version number returned by the read operation matches the version number of the handle that was read. If the version numbers do not match, the node has been deleted and subsequently deallocated by a different thread. In this case, the lookup, insert, or delete operation is restarted.</p>
  <p num="p-0074">Using this version numbering scheme, it is possible to deallocate nodes right when they are being marked as deleted. As a further optimization, we can defer deallocating deleted nodes for some fixed interval of time, which eliminates the needs for restarts for all but the most long-running operations.</p>
  <p num="p-0075">In an alternative embodiment of this aspect of the invention, the read operation does not return the version number of the disk block that was being read, but instead raises an exception whenever the version number of the handle and the version number of the disk block do not match. The caller of the read operation (i.e., a lookup, insert, or delete operation) catches the exception and restarts the lookup, insert, or delete operation.</p>
  <p num="p-0076">To further illustrate the idea, here is exemplary pseudocode of Sagiv's lookup operation (again adapted from Yehoshua Sagiv, <i>Concurrent Operations on B</i>-<i>Trees with Overtaking</i>), this time also including the machinery for keeping track of operation start times. T is a global variable referring to a table mapping thread identifiers to operation start times:</p>
  <p num="p-0077">
    <tables id="TABLE-US-00003" num="00003"> <table frame="none" colsep="0" rowsep="0" class="description-table"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="203pt" align="left"> </colspec> <thead> <tr class="description-tr"> <td class="description-td"> </td>
              <td namest="offset" nameend="1" align="center" rowsep="1" class="description-td" colspan="2"> </td>
            </tr> </thead> <tbody valign="top"> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">procedure Lookup(h<sub>P</sub>: Handle, k : Key)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   var h: Handle, A: Node;</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">label start:</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   P := Read(h<sub>P</sub>)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   h := last handle in P</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   repeat</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      lock T</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      insert (ID of this thread, current time) into T</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      unlock T</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      A := read(h)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      if k &gt; A.k<sub>max </sub>then</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">         h := A.h<sub>right</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      else if k ≦ A.k<sub>min </sub>then</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">         goto start</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      else</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">         choose i such that A.k<sub>i−1 </sub>&lt; k ≦ A.k<sub>i </sub>(let i be</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">         0 if Num(A) = 0)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">         h := A.h<sub>i</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      endif</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   until A is a leaf and A.k<sub>min </sub>&lt; k ≦ A.k<sub>max</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   lock T</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   remove (ID of this thread, corresponding time) from T</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   unlock T</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   if k is contained in A then</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      return corresponding value</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   else</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      return null</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   endif</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">endproc</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td namest="offset" nameend="1" align="center" rowsep="1" class="description-td" colspan="2"> </td>
            </tr> </tbody> </tgroup> </table> </tables> </p>
  <p num="p-0078">In contrast, here is an example of pseudocode for a lookup routine in accordance with the present invention, where this routine avoids any operations on the table T (to emphasize that our invention consists of two independent parts, this version does not incorporate the use of left-links to avoid restarts).</p>
  <p num="p-0079">
    <tables id="TABLE-US-00004" num="00004"> <table frame="none" colsep="0" rowsep="0" class="description-table"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="203pt" align="left"> </colspec> <thead> <tr class="description-tr"> <td class="description-td"> </td>
              <td namest="offset" nameend="1" align="center" rowsep="1" class="description-td" colspan="2"> </td>
            </tr> </thead> <tbody valign="top"> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">procedure Lookup(h<sub>P</sub>: Handle, k : Key)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   var h: Handle, A: Node;</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">label start:</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   P := Read(h<sub>P</sub>)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   h := last handle in P</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   repeat</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      A := read(h)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      if version(A) ≠ version(h) then goto start</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      if k &gt; A.k<sub>max </sub>then</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">         h := A.h<sub>right</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      else if k ≦ A.k<sub>min </sub>then</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">         goto start</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      else</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">         choose i such that A.k<sub>i−1 </sub>&lt; k ≦ A.k<sub>i </sub>(let i be</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">         0 if Num(A) = 0)</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">         h := A.h<sub>i</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      endif</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   until A is a leaf and A.k<sub>min </sub>&lt; k ≦ A.k<sub>max</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   if k is contained in A then</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      return corresponding value</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   else</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">      return null</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">   endif</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">endproc</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td namest="offset" nameend="1" align="center" rowsep="1" class="description-td" colspan="2"> </td>
            </tr> </tbody> </tgroup> </table> </tables> </p>
  <p num="p-0080">Note that this pseudocode is also depicted in <figref idrefs="DRAWINGS">FIG. 3F</figref>, where the box <b>330</b> indicates the new line of code (“if version(A)≠ version(h) then goto start”). Moreover, the new pseudocode does not include the lines of code from the Sagiv algorithm relating to the lock operation. In other words, the following code has been eliminated:</p>
  <p num="p-0081"> <tables id="TABLE-US-00005" num="00005"> <table frame="none" colsep="0" rowsep="0" class="description-table"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="42pt" align="left"> </colspec> <colspec colname="1" colwidth="175pt" align="left"> </colspec> <thead> <tr class="description-tr"> <td class="description-td"> </td> <td namest="offset" nameend="1" align="center" rowsep="1" class="description-td" colspan="2"> </td> </tr> </thead> <tbody valign="top"> <tr class="description-tr"> <td class="description-td"> </td> <td class="description-td">lock T</td> </tr> <tr class="description-tr"> <td class="description-td"> </td> <td class="description-td">insert (ID of this thread, current time) into T</td> </tr> <tr class="description-tr"> <td class="description-td"> </td> <td class="description-td">unlock T</td> </tr> <tr class="description-tr"> <td class="description-td"> </td> <td namest="offset" nameend="1" align="center" rowsep="1" class="description-td" colspan="2"> </td> </tr> </tbody> </tgroup> </table> </tables> <br>
In addition, the code,
</p>
  <p num="p-0082"> <tables id="TABLE-US-00006" num="00006"> <table frame="none" colsep="0" rowsep="0" class="description-table"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="28pt" align="left"> </colspec> <colspec colname="1" colwidth="189pt" align="left"> </colspec> <thead> <tr class="description-tr"> <td class="description-td"> </td> <td namest="offset" nameend="1" align="center" rowsep="1" class="description-td" colspan="2"> </td> </tr> </thead> <tbody valign="top"> <tr class="description-tr"> <td class="description-td"> </td> <td class="description-td">lock T</td> </tr> <tr class="description-tr"> <td class="description-td"> </td> <td class="description-td">remove (ID of this thread, corresponding time) from T</td> </tr> <tr class="description-tr"> <td class="description-td"> </td> <td class="description-td">unlock T</td> </tr> <tr class="description-tr"> <td class="description-td"> </td> <td namest="offset" nameend="1" align="center" rowsep="1" class="description-td" colspan="2"> </td> </tr> </tbody> </tgroup> </table> </tables> <br>
has been removed.
</p>
  <p num="p-0083">Of course, the two improvements disclosed herein may be combined to achieve the benefits of both of them. The pseudocode of the insert and delete operations and the compression thread is significantly more complicated but nonetheless well within the capabilities of a person skilled in the art. Moreover, the modifications needed to incorporate our invention should be straightforward after reading this specification.</p>
  <p num="p-0084">F. Flowcharts of Exemplary Procedures</p>
  <p num="p-0085"> <figref idrefs="DRAWINGS">FIGS. 4–10</figref> are flowcharts representing several procedures that may be employed in connection with a presently preferred implementation of an algorithm in accordance with the present invention. The following table summarizes the data types, notation and functions (index node and Allocator functions) referred to in these flowcharts.</p>
  <p num="p-0086">
    <tables id="TABLE-US-00007" num="00007"> <table frame="none" colsep="0" rowsep="0" class="description-table"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="70pt" align="left"> </colspec> <colspec colname="2" colwidth="147pt" align="left"> </colspec> <thead> <tr class="description-tr"> <td namest="1" nameend="2" align="center" rowsep="1" class="description-td" colspan="2"> </td>
            </tr> </thead> <tbody valign="top"> <tr class="description-tr"> <td class="description-td">Primitive Types</td>
              <td class="description-td"> </td>
            </tr> <tr class="description-tr"> <td class="description-td">k</td>
              <td class="description-td">a key value</td>
            </tr> <tr class="description-tr"> <td class="description-td">d</td>
              <td class="description-td">a data value</td>
            </tr> <tr class="description-tr"> <td class="description-td">ba</td>
              <td class="description-td">a block address</td>
            </tr> <tr class="description-tr"> <td class="description-td">v</td>
              <td class="description-td">a version number</td>
            </tr> <tr class="description-tr"> <td class="description-td">Composite Types</td>
            </tr> <tr class="description-tr"> <td class="description-td">h = (v, ba)</td>
              <td class="description-td">a handle (may be null)</td>
            </tr> <tr class="description-tr"> <td class="description-td">D = (k, d)</td>
              <td class="description-td">a data node</td>
            </tr> <tr class="description-tr"> <td class="description-td">X, A, B = (h<sub>left′ </sub>k<sub>min′</sub> </td>
              <td class="description-td">an index node</td>
            </tr> <tr class="description-tr"> <td class="description-td">h<sub>0′ </sub>k<sub>0′ </sub>h<sub>1′ </sub>k<sub>1′ </sub>. . . ,</td>
            </tr> <tr class="description-tr"> <td class="description-td">h<sub>n−1′ </sub>k<sub>n−1′ </sub>h<sub>n′ </sub>k<sub>max′</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td">h<sub>right</sub>)</td>
            </tr> <tr class="description-tr"> <td class="description-td">P = (h<sub>0′ </sub>. . . , h<sub>n</sub>)</td>
              <td class="description-td">a prime node</td>
            </tr> <tr class="description-tr"> <td class="description-td">Notation</td>
            </tr> <tr class="description-tr"> <td class="description-td">h.v</td>
              <td class="description-td">refers to the version number v of handle h</td>
            </tr> <tr class="description-tr"> <td class="description-td">X.h<sub>n</sub> </td>
              <td class="description-td">refers to the field h<sub>n </sub>(the rightmost child</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">handle) of index node X</td>
            </tr> <tr class="description-tr"> <td class="description-td">P[i]</td>
              <td class="description-td">refers to handle h<sub>i </sub>of prime node P (where</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">h<sub>0 </sub>refers to the leftmost leaf-level index</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">node in the tree)</td>
            </tr> <tr class="description-tr"> <td class="description-td">Index Node Functions</td>
            </tr> <tr class="description-tr"> <td class="description-td">Num(X)</td>
              <td class="description-td">returns n where X is an index node (h<sub>left′</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">k<sub>min′ </sub>h<sub>0′ </sub>k<sub>0′ </sub>h<sub>1′ </sub>k<sub>1′ </sub>. . . , h<sub>n−1′ </sub>k<sub>n−1′ </sub>h<sub>n′ </sub>k<sub>max′</sub> </td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">h<sub>right</sub>)</td>
            </tr> <tr class="description-tr"> <td class="description-td">IsLeaf(X)</td>
              <td class="description-td">returns true if and only if X.h<sub>0 </sub>= null</td>
            </tr> <tr class="description-tr"> <td class="description-td">IsDeleted(X)</td>
              <td class="description-td">returns true if and only if X.k<sub>min </sub>= −inf</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">and X.k<sub>max </sub>= −inf</td>
            </tr> <tr class="description-tr"> <td class="description-td">Allocator Functions</td>
            </tr> <tr class="description-tr"> <td class="description-td">Alloc(size)</td>
              <td class="description-td">allocates a block of the given size, and</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">returns a handle to the block</td>
            </tr> <tr class="description-tr"> <td class="description-td">Dealloc(h)</td>
              <td class="description-td">deallocates the block referred to by the</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">handle h, and increments the block's</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">version number</td>
            </tr> <tr class="description-tr"> <td class="description-td">Read(h)</td>
              <td class="description-td">reads the block referred to by the handle</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">h, and returns (v, N), the block's version</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">number v and the node N stored in the</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">block</td>
            </tr> <tr class="description-tr"> <td class="description-td">Write(N, h)</td>
              <td class="description-td">writes the node N to the block referenced</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">by the handle h</td>
            </tr> <tr class="description-tr"> <td class="description-td">Lock(h)</td>
              <td class="description-td">locks the block referred to by the handle h</td>
            </tr> <tr class="description-tr"> <td class="description-td">Unlock(h)</td>
              <td class="description-td">unlocks the block referred to by the</td>
            </tr> <tr class="description-tr"> <td class="description-td"> </td>
              <td class="description-td">handle h</td>
            </tr> <tr class="description-tr"> <td namest="1" nameend="2" align="center" rowsep="1" class="description-td" colspan="2"> </td>
            </tr> </tbody> </tgroup> </table> </tables> </p>
  <p num="p-0087"> <figref idrefs="DRAWINGS">FIG. 4</figref> is a flowchart of a procedure entitled GetNextHandle. This procedure takes an index node X and a key k and returns (h, isLink), where h is a handle referring to a child or sibling of X that is closer in the tree to the data node containing the key k and its associated data value, and isLink is a boolean value indicating whether h is a link to a sibling of X. As shown in <figref idrefs="DRAWINGS">FIG. 4</figref>, this procedure begins at an entry point for GetNextHandle(X, k) <b>402</b>. At step <b>404</b>, the procedure determines whether k is less than or equal to X.k<sub>min</sub>, where X.k<sub>min </sub>refers to the field k<sub>min </sub>of index node X. If so, the procedure returns (X.h<sub>left</sub>, true), indicating that the left sibling of X is closer to the desired data node. If not, the procedure determines whether k is greater than X.k<sub>max</sub>, and if so, returns (X.h<sub>right</sub>, true), indicating that the right sibling of X is closer to the desired data node (Step <b>410</b>). If k is not greater than X.k<sub>max</sub>, as determined at step <b>408</b>, the procedure determines whether Num(X) is equal to 0 (step <b>412</b>), and if so, at step <b>414</b> returns (X.h<sub>0</sub>, false). Moving on to step <b>416</b>, the procedure deter-mines whether X.k<sub>n−1 </sub>is less than k. If so, the procedure at step <b>418</b> returns (X.h<sub>n </sub>false). If not, the procedure moves on to step <b>420</b> and finds the smallest i such that k is less than or equal to X.k<sub>i</sub>. Next, at step <b>422</b>, the procedure tests whether IsLeaf(X) is true. If so, it returns (X.h<sub>i+1</sub>, false) (Step <b>424</b>), and if not, it returns (X.h<sub>i</sub>, false) (Step <b>426</b>). In sum the procedure of <figref idrefs="DRAWINGS">FIG. 4</figref> returns a handle and a boolean flag indicating whether the handle is a link to a sibling of node X.</p>
  <p num="p-0088"> <figref idrefs="DRAWINGS">FIG. 5</figref> is a flowchart of a procedure entitled InsertPair, which takes an index node X, a key k, and a handle h and inserts the key k and the handle h into X. This procedure returns nothing.</p>
  <p num="p-0089">As shown in <figref idrefs="DRAWINGS">FIG. 5</figref>, the procedure begins at the entry point InsertPair(X, k, h) (Step <b>502</b>). Next, at step <b>504</b>, the procedure determines whether Num(X) is equal to 0. If so, at step <b>506</b>, the key k and handle h are inserted into the node X as shown. If Num(X) is not equal to 0, at step <b>508</b> the procedure determines whether X.k<sub>0 </sub>is less than k; and if not, proceeds to step <b>510</b> where the key k and handle h are inserted into the node X as shown. On the other hand, if the procedure determines that X.k<sub>0 </sub>is less than k, it proceeds to step <b>512</b> where it finds the largest i such that X.k<sub>i−1 </sub>is less than k, and then at step <b>514</b> inserts the key k and handle h into node X as shown. Finally, at step <b>516</b> the procedure returns. In sum, the key k and handle h are inserted into the node X at steps <b>506</b>, <b>510</b>, or <b>514</b>, depending on whether Num(X) is equal to 0, and whether X.k<sub>0 </sub>is less than k.</p>
  <p num="p-0090"> <figref idrefs="DRAWINGS">FIG. 6</figref> is a flowchart of a procedure entitled CreateTree. This procedure receives no argument and returns a prime node handle h<sub>p </sub>identifying a new tree. As shown, the CreateTree procedure <b>600</b> begins at the entry point CreateTree( ) (step <b>602</b>). At step <b>604</b>, the node X is defined as (null, −inf, null, +inf, null). At step <b>606</b>, the handle h, is defined as Alloc(space for X) where the function Alloc( ) allocates a block of a size given by the argument and returns a handle to the block. Next, at step <b>608</b> the procedure invokes Write(X, h<sub>x</sub>), in order to write the node X to the block referenced by the handle h<sub>x</sub>. At step <b>610</b> the procedure defines the prime node P to contain the handle h<sub>x</sub>. At step <b>612</b> the procedure again invokes the function Alloc(space for P), in order to allocate a block sufficiently large to store P, which returns a handle hp to the block. At step <b>614</b>, the procedure writes the node P to the block referenced by the handle hp, and at step <b>616</b> the procedure concludes by returning the handle h. In sum, this procedure returns a prime node handle hp identifying a new tree.</p>
  <p num="p-0091"> <figref idrefs="DRAWINGS">FIG. 7</figref> is a flowchart of a procedure entitled Lookup, which takes a prime node handle h<sub>p </sub>and a key k and returns a data item d or null. The Lookup procedure <b>700</b> begins at the entry point Lookup(h<sub>p </sub>k) (step <b>702</b>). At step <b>704</b>, the procedure invokes the function Read(h<sub>p</sub>) in order to read the block referred to by the handle h<sub>p</sub>. The Read function returns (v, P), the block's version number v and the prime node P stored in the block. Next, at step <b>706</b>, the handle h is defined as the last handle in the prime node P, thereby referring to the root node of the tree. At step <b>708</b>, the procedure again invokes the function Read( ) in order to read the block referred to by handle h. This time, the function returns the version number v and the index node X stored in the block referenced by handle h. At step <b>710</b>, the procedure determines whether h.v (i.e., the version number of handle h) is equal to v. If not, the procedure loops back as shown to step <b>704</b>. If so, the procedure proceeds to step <b>712</b> where the function GetNextHandle (described above in connection with <figref idrefs="DRAWINGS">FIG. 4</figref>) is invoked. In this instance, the function GetNextHandle(X, k) returns the handle h and boolean isLink indicating whether the handle h is a link to a sibling of node X. Next, at step <b>714</b>, the procedure tests whether handle h is null. If so, the procedure proceeds to step <b>716</b> where null is returned. If not, the procedure proceeds to step <b>718</b>, where it determines whether both IsLeaf(X) and not isLink are true. If they are not both true, the procedure loops back to step <b>708</b> as shown. If, on the other hand, IsLeaf(X) and not isLink are both true, the procedure proceeds to step <b>720</b> where the function Read(h) is invoked in order to read the block referred to by handle h and thereby determine the block's version number v and the data node D stored in the block. Next, at step <b>722</b>, the procedure determines whether h.v (i.e., the version number of handle h) is equal to v. If not, the procedure loops back to step <b>704</b> as shown, and if so, proceeds to step <b>724</b>. At step <b>724</b>, the procedure determines whether D.k is equal to k (i.e., whether the key of data node D is equal to k). If not, the procedure proceeds to step <b>726</b> where it returns null, and if so, it proceeds to step <b>728</b> and returns D.d, that is, the data portion of the data node D. Thus, in sum, the Lookup procedure takes a prime node handle h<sub>p </sub>and a key k and returns a data item d or null.</p>
  <p num="p-0092"> <figref idrefs="DRAWINGS">FIG. 8</figref> is a flow chart of a procedure entitled Delete which takes a prime node handle h<sub>p </sub>and a key k, and deletes the key and its associated data value from the tree identified by the handle h<sub>p</sub>. This procedure returns nothing.</p>
  <p num="p-0093">As shown, the Delete procedure <b>800</b> begins at the entry point Delete(h<sub>p</sub>, k) (step <b>802</b>). Next, at step <b>804</b>, the procedure invokes the function Read(h<sub>p</sub>) in order to read the block referred to by the handle h<sub>p</sub>. This function returns the block's version number v and the prime node P stored in the block. Next, at step <b>806</b> the handle h is defined as the last handle in node P, thereby referring to the root node of the tree. At step <b>808</b>, the procedure again invokes the Read( ) function in order to read the block referred to by handle h, returning the block's version number and the index node X contained therein. At step <b>810</b>, the procedure tests whether h.v is equal is equal to v, i.e., whether the version number of handle h is equal to the version number returned by the previous invocation of Read( ). If not, the procedure loops back to step <b>804</b> as shown; and if so, it proceeds to step <b>812</b>. At step <b>812</b> the function GetNextHandle (discussed above in connection with <figref idrefs="DRAWINGS">FIG. 4</figref>) is invoked with the arguments X, k. In this manner, the procedure determines the handle h and the boolean isLink indicating whether the handle h is a link to a sibling of node X. Next, at step <b>814</b>, the procedure tests whether IsLeaf(X) and not isLink are both true; if not, the procedure loops back to step <b>808</b>, and if so, proceeds to step <b>816</b>. At step <b>816</b>, the procedure tests whether handle h is null, and if so, proceeds to step <b>818</b> where it returns. If h is not null, the procedure proceeds to step <b>820</b> where the function Lock(h) is invoked in order to lock the block referred to by the handle h. Next, at step <b>822</b> Read(h) reads the block referred to by handle h, returning the block's version number and the index node X contained therein. At step <b>824</b> the procedure tests whether h.v is equal to v, and if not, proceeds to step <b>826</b> where the block referred to by the handle h is unlocked, after which the procedure loops back to step <b>804</b> as shown. On the other hand, if h.v is equal to v, the procedure proceeds to step <b>828</b> (see subpart <b>8</b>B of <figref idrefs="DRAWINGS">FIG. 8</figref>), where the procedure determines whether key k is less than or equal to X.k<sub>min</sub>, i.e., whether the key k is found in a data node attached to one of the left siblings of X. If so, the procedure proceeds to steps <b>830</b> and <b>832</b>, where the block referred to by handle h is unlocked and then the handle h is defined as the left sibling handle of node X. If key k is not less than or equal to X.k<sub>min</sub>, the procedure proceeds to step <b>834</b> where it tests whether k is greater than X.k<sub>max</sub>, and if so, proceeds to steps <b>836</b> and <b>838</b>, where it unlocks the block referred to by handle h and defines h to be the right sibling handle of node X. If at step <b>834</b> the procedure determines that k is not greater than X.k<sub>max</sub>, it proceeds to step <b>840</b> where it tests whether Num(X) is equal to 0, meaning that X (which is a leaf-level index node) has no children, and that it therefore does not contain the key k. If the answer to this test is yes, the procedure moves ahead to step <b>856</b>, and if it is no, it proceeds to step <b>842</b>. At step <b>842</b>, the procedure determines whether X.k<sub>n−1 </sub>is less than k, i.e., whether the field k<sub>n−1 </sub>of node X is less than the key value k. If it is, the procedure jumps ahead to step <b>856</b> as shown, and if it is not, it proceeds to step <b>844</b>, where it finds the smallest i such that k is less than or equal to X.k<sub>i</sub>. Next, at step <b>846</b>, the procedure invokes Read(X.h<sub>i+1</sub>), reading a block containing a data node D and a version number v. Next, at step <b>848</b> the procedure tests whether D.k is equal to k. If it is not, the procedure jumps to step <b>856</b>, and if so, it proceeds to step <b>850</b> where it deallocates the block referred to by the handle X.h<sub>i+1</sub>, which increments the block version number. Next, at step <b>852</b> the procedure removes the handles identified by X.k<sub>i </sub>and X.h<sub>i+1 </sub>from node X. At step <b>854</b>, the Write( ) function is invoked to write the node X referenced by handle h. Finally, at steps <b>856</b> and <b>858</b> the block referred to by handle h is unlocked and the procedure returns. In sum, the Delete procedure takes a prime node handle h<sub>p </sub>and a key k and removes the key k and its associated data value from the tree identified by h<sub>p</sub>.</p>
  <p num="p-0094"> <figref idrefs="DRAWINGS">FIG. 9</figref> is a flowchart of a procedure entitled Insert, which takes a prime node handle h<sub>p</sub>, a key value k, and a data value d and inserts the key and the data value into the tree identified by h<sub>p</sub>. The Insert function <b>900</b> begins at the entry point identified by reference numeral <b>901</b>, and is invoked by the call Insert(h<sub>p</sub>, k, d), where hp is a prime node handle, k is a key value, and d is a data value. At step <b>902</b>, the Data node D is defined by the key value k and data value d. At step <b>903</b>, the Alloc function is invoked so as to allocate a block large enough to contain D; and the handle identifying the block is assigned to h<sub>D</sub>. Next, at step <b>904</b> the procedure writes the node D to the block referenced by handle h<sub>D</sub>. At step <b>905</b>, L<sub>T </sub>is set to 0 and then at step <b>906</b> S is defined as the new empty stack. (By way of providing further background, we note that the levels of a tree are the sets of siblings. In the terminology used in the instant application, level <b>0</b> contains all leaf index nodes, level <b>1</b> contains their parents, and so on; the highest level contains the root node. The number of the highest level is one less than the number of handles in a prime node (since we use zero-based indexing). The “target level” variable L<sub>T </sub>identifies the level at which the key-handle pair (k, h<sub>D</sub>) shall be inserted into the tree. Setting L<sub>T </sub>to 0 means that the pair shall be inserted into a leaf index node. As the algorithm unfolds, L<sub>T </sub>may be incremented, indicating that a (modified) key-handle pair shall be inserted into an index node higher up in the tree (potentially all the way up to the root.) At step <b>907</b>, the Read( ) function is invoked to read the block referred to by handle hp so as to identify the version number v and the prime node P stored in the block. At step <b>908</b>, the last handle in node P (the root index node) is assigned to h<sub>x</sub>. At step <b>909</b> L<sub>N </sub>is defined to be the number of handles in node P, which is identical to the number of index node levels in the tree. At step <b>910</b>, L<sub>C </sub>is defined as L<sub>N</sub>−1. L<sub>C </sub>(the “current level”) is the level the insert procedure is currently at. Since Insert starts at the root (which is at level L<sub>N</sub>−1, as explained above), L<sub>C </sub>is initialized to this value, and is decremented as Insert descends into the tree. At step <b>912</b> Read(h<sub>x</sub>) is invoked to return the version number v and the index node X referred to by handle h<sub>x</sub>. At step <b>913</b>, the procedure tests whether h<sub>x</sub>.v is equal to v, and at step <b>914</b> the procedure tests whether L<sub>C </sub>is greater than L<sub>T</sub>. If the answer to both of the tests of steps <b>913</b> and <b>914</b> is yes, the procedure proceeds to step <b>915</b>. If, on the other hand, the answer to step <b>913</b> is no, the procedure loops back to step <b>906</b> as shown. If the answer to the test of step <b>914</b> is no, the procedure proceeds to step <b>920</b> (see subpart <b>9</b>B of <figref idrefs="DRAWINGS">FIG. 9</figref>).</p>
  <p num="p-0095">At step <b>915</b>, the procedure invokes the GetNextHandle function with the arguments X and k, whereby the handle h′ and boolean isLink are returned. As discussed previously, the boolean isLink indicates whether the handle h′ is a link to a sibling of node X. At step <b>916</b>, the procedure tests whether isLink is true, and if it is, branches ahead to step <b>919</b>. If isLink is false, the procedure proceeds to step <b>917</b>, where it decrements L<sub>C</sub>. At step <b>918</b>, the procedure pushes the handle h<sub>x </sub>onto stack S. At step <b>919</b>, the function assigns the value of h′ to h<sub>x</sub>.</p>
  <p num="p-0096">Now referring to subpart <b>9</b>B of <figref idrefs="DRAWINGS">FIG. 9</figref>, at step <b>920</b> the procedure invokes the Lock( ) function in order to lock the block referred to by the handle h<sub>x</sub>. At step <b>921</b> the procedure invokes Read(h<sub>x</sub>), which reads the block identified by handle h<sub>x </sub>and extracts an index node X and a version number v. At step <b>922</b>, the procedure tests whether h<sub>x</sub>.v is equal to v. If not, it branches to step <b>906</b> (subpart <b>9</b>A) as shown. If, on the other hand, h<sub>x</sub>.v is equal to v, the procedure proceeds to step <b>923</b>, where it tests whether the function IsLeaf(X) is true. If not, the procedure branches to step <b>934</b> (subpart <b>9</b>C of <figref idrefs="DRAWINGS">FIG. 9</figref>), and if so, it proceeds to step <b>925</b>, where it tests whether X.k<sub>n−1 </sub>is less than k. If the answer to the test of step <b>925</b> is yes, the procedure branches to step <b>934</b>, and if it is no, the procedure proceeds to step <b>926</b>. At step <b>926</b>, the procedure finds the smallest i such that k is less than X.k<sub>i</sub>. At step <b>927</b>, the procedure invokes Read(X.h<sub>i+1</sub>), which reads the block identified by handle X.h<sub>i+1 </sub>and extracts a data node D and a version number v. At step <b>928</b>, the procedure tests whether D.k is equal to k; if it is, the procedure proceeds to step <b>929</b>, and otherwise it branches to step <b>934</b>. At step <b>929</b>, the procedure defines node D to be a data node containing the key value k and data value d. Next, at step <b>930</b> the function Write (D, X.h<sub>i+1</sub>) is invoked in order to write the node D to the block referenced by the handle h<sub>i+1</sub>. Next, at step <b>931</b>, the function Dealloc(h<sub>D</sub>) is invoked in order to deallocate the block referred to by the handle h<sub>D </sub>and increment the block's version number. At step <b>932</b>, the block referred to by the handle h<sub>X </sub>is unlocked, and then at step <b>933</b> the procedure returns.</p>
  <p num="p-0097">Referring now to subpart <b>9</b>C of <figref idrefs="DRAWINGS">FIG. 9</figref>, at step <b>934</b> the procedure tests whether k is greater than X.k<sub>min </sub>and less than or equal to X.k<sub>max</sub>. If the answer to the test of step <b>934</b> is yes, the procedure proceeds to step <b>941</b>; if the answer is no, the procedure proceeds to step <b>935</b>. At step <b>935</b>, the block referred to by the handle h<sub>X </sub>is unlocked, and then at step <b>936</b> the GetNextHandle function is invoked with the arguments X and k, which thereby returns the handle h′ and the boolean isLink. As discussed previously, this function returns the handle h′ and the boolean isLink indicating whether this handle is a link to a sibling of node X. At step <b>937</b>, the procedure tests whether isLink is true; if so, it proceeds to step <b>938</b> and if not, it branches to step <b>920</b> (see subpart <b>9</b>B of <figref idrefs="DRAWINGS">FIG. 9</figref>). At step <b>938</b>, the handle h<sub>X </sub>is assigned the value of h′ and then at step <b>939</b> Read(h<sub>X</sub>) is invoked to determine the version number v and node X referred to by the handle h<sub>X</sub>. At step <b>940</b>, the procedure tests whether h<sub>X</sub>.v is equal to v; if so, it branches back to step <b>936</b> as shown, and if not, it branches to step <b>906</b> (subpart <b>9</b>A of <figref idrefs="DRAWINGS">FIG. 9</figref>).</p>
  <p num="p-0098">As mentioned above, at step <b>934</b> the procedure tests whether k is greater than X.k<sub>min </sub>and less than or equal to X.k<sub>max</sub>. If the answer to this test is yes, the procedure proceeds to step <b>941</b> where it tests whether node X is full. If X is full, the procedure proceeds to step <b>946</b> (subpart <b>9</b>D of <figref idrefs="DRAWINGS">FIG. 9</figref>), otherwise it proceeds to step <b>942</b>. At step <b>942</b>, the procedure invokes InsertPair(X, k, h<sub>D</sub>), in order to insert the key k and handle h<sub>D </sub>in node X. At step <b>943</b>, Write(X, h<sub>X</sub>) is invoked in order to write the node X to the block referenced by the handle h<sub>x</sub>. At step <b>944</b>, the block referred to by the handle h<sub>x </sub>is unlocked, and then at step <b>945</b> the procedure returns.</p>
  <p num="p-0099">Referring now to subpart <b>9</b>D of <figref idrefs="DRAWINGS">FIG. 9</figref>, if node X is full, then X is split into two nodes X and Y. At step <b>946</b> the procedure tests whether the function IsLeaf(X) is true. If it is, the procedure proceeds to step <b>947</b>, and if it is not, the procedure proceeds to step <b>951</b>. Steps <b>947</b>, <b>948</b> and <b>949</b>, on the one hand, and steps <b>951</b>, <b>952</b> and <b>953</b> on the other hand are performed in order to define nodes Y and X, depending on whether X is a leaf or not. Steps <b>947</b> and <b>951</b> are performed in order to define the node Y, steps <b>948</b> and <b>952</b> are performed to allocate space for Y, and steps <b>949</b> and <b>953</b> are performed to define the node X. At step <b>950</b>, the procedure tests whether X.k<sub>max </sub>is less than key value k. If not, the procedure proceeds to step <b>954</b> where the function InsertPair (discussed above in connection with <figref idrefs="DRAWINGS">FIG. 5</figref>) is invoked with the arguments X, k and h<sub>D </sub>to insert k and h<sub>D </sub>into X. In step <b>955</b>, Write(Y,h<sub>y</sub>) is invoked in order to write the node Y. Similarly, at step <b>957</b> Write(X, h<sub>x</sub>) is invoked in order to write the node X. If at step <b>950</b> it is determined that X.k<sub>max </sub>is less than k, the procedure proceeds to step <b>956</b> where the function InsertPair(Y, k, h<sub>D</sub>) is invoked to insert k and h<sub>D </sub>into Y, after which steps <b>955</b> and <b>957</b> are performed as described above. At step <b>958</b>, Read(h<sub>p</sub>) is invoked and this function returns the version number v and the prime node P in the block referred to by the handle h<sub>p</sub>.</p>
  <p num="p-0100">The procedure then proceeds to step <b>959</b> (see subpart <b>9</b>E of <figref idrefs="DRAWINGS">FIG. 9</figref>).</p>
  <p num="p-0101">Referring to subpart <b>9</b>E of <figref idrefs="DRAWINGS">FIG. 9</figref>, at step <b>959</b> the procedure determines whether handle h<sub>x </sub>is the last handle in prime node P, meaning that the node identified by h<sub>x </sub>is the root of the tree. If so, the procedure proceeds to steps <b>960</b> through <b>966</b> and if not, proceeds to steps <b>967</b> through <b>972</b>. At step <b>960</b> the procedure defines the index node Z as shown. At step <b>961</b> the handle h<sub>x </sub>is defined with the function Alloc(space for Z), in order to allocate a block large enough to hold Z and return a handle to the block. In other words, the handle h, is returned by the function Alloc( ). At step <b>962</b> the function Write(Z, h<sub>z</sub>) is invoked in order to write the index node Z to the block referenced by the handle h<sub>z</sub>. At step <b>963</b>, the procedure appends h<sub>z </sub>to the end of prime node P. At step <b>964</b>, Write(P, hp) is invoked to write the node P to the block referenced by the handle h<sub>p</sub>. Next, at step <b>965</b> the block referred to by the handle h<sub>x </sub>is unlocked and then at step <b>966</b> the procedure returns.</p>
  <p num="p-0102">If at step <b>959</b> the answer to the test whether h<sub>x </sub>is the last handle in P is no, the procedure proceeds to step <b>967</b>, wherein the block referred to by the handle h<sub>x </sub>is unlocked. Then, at step <b>968</b>, the handle h<sub>D </sub>is set to h<sub>y</sub>. At step <b>969</b> the key value k is set to X.k<sub>max</sub>. At step <b>970</b>, the procedure determines whether the stack S is empty; if not, it proceeds to step <b>971</b> wherein the handle h<sub>x </sub>is defined from the last value on the stack S. On the other hand, if S is empty, the procedure proceeds to step <b>973</b> where handle h<sub>x </sub>is defined with P[L<sub>N</sub>], and then at step <b>974</b> L<sub>N </sub>is defined as L<sub>N</sub>+1. Finally, at step <b>972</b> L<sub>T </sub>is set to L<sub>T</sub>+1, and then the procedure loops back to step <b>920</b> (see subpart <b>9</b>B of <figref idrefs="DRAWINGS">FIG. 9</figref>), as shown.</p>
  <p num="p-0103">In sum, the Insert procedure of <figref idrefs="DRAWINGS">FIG. 9</figref> (subparts <b>9</b>A through <b>9</b>E), takes a prime node handle h<sub>P</sub>, a key value k, and a data value d and inserts the key-data pair into the tree identified by h<sub>P</sub>.</p>
  <p num="p-0104"> <figref idrefs="DRAWINGS">FIG. 10</figref> is a flowchart of a procedure entitled Compress. This procedure takes a prime node handle h<sub>p </sub>and compresses the node; it does not return, as it is executed by a background process. The Compress procedure <b>1000</b> begins at an entry point <b>1002</b> with the call Compress(h<sub>p</sub>). At step <b>1004</b>, Read(h<sub>p</sub>) is invoked, and this function returns a version number v and the prime node P referred to by the handle hp. At step <b>1006</b>, the index i is set to 1. At step <b>1008</b>, the procedure tests whether the number of handles in node P is greater than i. If the number of handles in P is greater than i, the procedure proceeds to step <b>1010</b> to cause the function CompressLevel with the argument P[i]. This function is described below in connection with <figref idrefs="DRAWINGS">FIG. 11</figref>. Briefly, CompressLevel( ) is a function that takes an index node handle h<sub>X </sub>and compressed the index node referred to by that handle and all its right siblings. In step <b>1012</b>, the index i is set to i+1, and then the procedure loops back to decision step <b>1008</b>. At step <b>1008</b> if it is determined that the number of handles in P is not greater i, the procedure proceeds to step <b>1014</b>, where the handle h is set to the last handle in node P. Next, at step <b>1016</b>, the block referred to by the handle h is locked, and then at step <b>1018</b> Read(h) is invoked, and this function returns the version number v and node X referred to by handle h. Next, at step <b>1020</b>, the procedure tests whether Num(X) is equal to 0 and X.h<sub>right </sub>is equal to null and not IsLeaf(X) are all true. If so, the procedure proceeds to step <b>1022</b> and invokes Read(h<sub>P</sub>), which returns the version number v and prime node P. If the answer to the test at step <b>1020</b> is no, the procedure jumps ahead to step <b>1032</b> and unlocks the block referred to by handle h. After step <b>1022</b> is performed, the procedure moves on to step <b>1024</b> and tests whether h is the last handle in P (that is, if h refers to the root node of the tree); if not, the procedure jumps ahead to step <b>1032</b>, and if so, proceeds to step <b>1026</b>. At step <b>1026</b> the procedure removes the last handle from P, and at step <b>1028</b> writes the node P referenced by the handle h<sub>p</sub>. Next, at step <b>1030</b>, the procedure deallocates the block referred to by handle h, and then proceeds to step <b>1032</b>, where it unlocks the block referred to by handle h. Finally at step <b>1034</b>, the procedure pauses and then loops back to step <b>1004</b>, as shown. In sum, this procedure compresses the tree identified by handle h<sub>p</sub>.</p>
  <p num="p-0105">The CompressLevel procedure <b>1100</b> begins at an entry point <b>1101</b> with the call CompressLevel(h<sub>X</sub>). At step <b>1102</b>, the variable a is set to 0 and at step <b>1103</b>, the handle h<sub>A </sub>is set to null. Next, at step <b>1104</b> the procedure tests whether the handle h<sub>X </sub>is null, and if so, proceeds to step <b>1105</b> where the procedure returns. If h<sub>x </sub>is not null, the procedure proceeds to step <b>1106</b> and locks the block referred to by handle h<sub>X</sub>. Next, at step <b>1107</b>, Read(h<sub>X</sub>) is invoked to read index node X and its version number v. At step <b>1108</b>, the procedure tests whether handle h<sub>A </sub>is null. If h<sub>A </sub>is null, the procedure branches to block <b>115</b> (subpart <b>11</b>B of <figref idrefs="DRAWINGS">FIG. 11</figref>), and if h<sub>A </sub>is not null, the procedure proceeds to step <b>1109</b> where variable a is set to −1. Next, at step <b>1110</b>, index i is set to zero, and then at step <b>1111</b> the procedure tests whether Num(X) is greater than or equal to i, i.e., the procedure tests whether the number n returned by the function Num(X) is greater than or equal to index i. If it is not, the procedure branches to step <b>1115</b> (subpart <b>11</b>B of <figref idrefs="DRAWINGS">FIG. 11</figref>), and if so, proceeds to step <b>1112</b>. At step <b>1112</b>, the procedure tests whether the handle to the ith child of node X (i.e., X.h<sub>i</sub>) is equal to handle h<sub>A</sub>. If it is not, the procedure proceeds to block <b>1114</b> and increments index i and then proceeds back to step <b>1111</b>. If X.h<sub>i </sub>is equal to handle h<sub>A </sub>the procedure proceeds to step <b>1113</b> where variable a is set to the value of index i.</p>
  <p num="p-0106">Referring now to subpart <b>11</b>B of <figref idrefs="DRAWINGS">FIG. 11</figref>, at step <b>1115</b>, the procedure tests whether the handle h<sub>A </sub>is null or the variable a is neither equal to −1 nor equal to Num(X). If the answer to the test of step <b>1115</b> is no, the procedure proceeds to step <b>1116</b> through <b>1118</b> and then back to step <b>1104</b>, as shown. Steps <b>1116</b> through <b>1118</b> are performed to unlock the block referred to by the handle h<sub>X</sub>, set h<sub>X </sub>to the field h<sub>right </sub>of index node X, and then to set handle h<sub>A </sub>to null.</p>
  <p num="p-0107">If the answer to the test of step <b>1115</b> is yes, the procedure performs a series of steps beginning with step <b>1119</b>, where it tests whether handle h<sub>A </sub>is null. If h<sub>A </sub>is null, the procedure at step <b>1120</b> sets variable a to 0. If handle h<sub>A </sub>is not null, the procedure at step <b>1122</b> increments a. Then, at step <b>1121</b> handle h<sub>A </sub>is set to X.h<sub>a</sub>. At step <b>1123</b>, the block referred to by handle h<sub>A </sub>is locked, and then at step <b>1124</b> the function Read(h<sub>A</sub>) is invoked, to read index node A and its associated version number v. At step <b>1125</b>, the handle h<sub>B </sub>is set to A.h<sub>right</sub>. Next, at step <b>1126</b> the procedure tests whether the handle h<sub>B </sub>is null. If it is, steps <b>1131</b> through <b>1133</b> are performed, i.e., the block referred to by handle h<sub>X </sub>is unlocked, the block referred to by handle h<sub>A </sub>is unlocked, and then the procedure returns. On the other hand, if handle h<sub>B </sub>is not null, the procedure proceeds to step <b>1127</b>, and locks the block referred to by handle h<sub>B</sub>. Next, at step <b>1128</b>, Read(h<sub>B</sub>) is invoked to determine the version number v and node B. At step <b>1129</b>, B.h<sub>left </sub>is set to the value of handle h<sub>A</sub>. Next, at step <b>1130</b>, b is set to 0.</p>
  <p num="p-0108">The remaining steps of the CompressLevel procedure are shown in subpart <b>11</b>C of <figref idrefs="DRAWINGS">FIG. 11</figref>. Referring to this subpart, at step <b>1134</b> the procedure tests whether X.h<sub>b </sub>is h<sub>B</sub>. If so, it proceeds to step <b>1144</b>; otherwise, it proceeds to step <b>1135</b>. At step <b>1135</b>, variable b is incremented, and at step <b>1136</b> the procedure tests whether Num(X) is greater than or equal to b. If so, the procedure loops back step <b>1134</b> as shown. If not, the procedure proceeds to step <b>1137</b> and unlocks the block referred to by handle h<sub>X</sub>. Next, at step <b>1138</b>, the procedure unlocks the block referred to by handle h<sub>A </sub>and at step <b>1139</b> unlocks the block referred to by handle h<sub>B</sub>. At step <b>1140</b> the procedure tests whether B.k<sub>max </sub>is less than X.k<sub>max</sub>. If not, the procedure performs step <b>1143</b>, in which handle h<sub>X </sub>is set to X.h<sub>right</sub>. If B.k<sub>max </sub>is less than X.k<sub>max </sub>as determined at step <b>1140</b>, the procedure proceeds to step <b>1141</b> and tests whether Num(A) is less than t or Num(B) is less than t. If either of these is true, the procedure proceeds to step <b>1142</b> and sets handle h<sub>A </sub>to null, and then branches back to step <b>1104</b> (subpart <b>11</b>A of <figref idrefs="DRAWINGS">FIG. 11</figref>) as shown.</p>
  <p num="p-0109">At step <b>1144</b>, the procedure again tests whether Num(A) is less than t or Num(B) is less than t. If not, the procedure proceeds to steps <b>1152</b> through <b>1154</b> as shown, and from there to steps <b>1150</b> and <b>1151</b>, after which the procedure branches back to step <b>1104</b> (subpart <b>11</b>B of <figref idrefs="DRAWINGS">FIG. 11</figref>). If the answer to the test of step <b>1144</b> is yes, the procedure proceeds to steps <b>1145</b>, <b>1146</b>, <b>1147</b>, <b>1148</b>, and <b>1149</b> as shown (these steps should by now be self-explanatory and are obviously not executed in order). After these steps are performed, the procedure tests whether node B is deleted, and if so, branches back to step <b>1104</b>. If node B is not deleted, the procedure sets at step <b>1151</b> h<sub>A </sub>to h<sub>B</sub>.</p>
  <p num="p-0110"> <figref idrefs="DRAWINGS">FIG. 12</figref> is a flowchart of a procedure entitled MergeNodes. This procedure, as its name implies, merges nodes; it takes index nodes X, A, B, (where A is the left sibling of B and X is their parent) and index node handles h<sub>X</sub>, h<sub>A</sub>, and h<sub>B </sub>referring to these nodes, and merges the contents of A and B into A, discarding B in the process. The MergeNodes procedure <b>1200</b> begins at entry point <b>1202</b> and is invoked with the call MergeNodes(X, A, B, h<sub>X</sub>, h<sub>A</sub>, h<sub>B</sub>), as shown. At step <b>1204</b>, the procedure tests whether IsLeaf(A) is true. Recall that IsLeaf(X) is a function that returns true if, and only if, X.h<sub>0 </sub>is null. If IsLeaf(A) is true, the procedure performs step <b>1206</b>, and if it is false, the procedure performs steps <b>1210</b>. Steps <b>1206</b> and <b>1210</b> assign the values shown in the corresponding blocks to node A. Next, at step <b>1208</b> the procedure performs the operation shown with respect to node B. At step <b>1212</b>, node X is defined as shown. Steps <b>1214</b> through <b>1228</b> are then performed to write nodes A, X, and B, unlock handles h<sub>A</sub>, h<sub>X</sub>, and h<sub>B</sub>, and to deallocate index node B identified by handle hB. The procedure returns at step <b>1228</b>.</p>
  <p num="p-0111"> <figref idrefs="DRAWINGS">FIG. 13</figref> is a flowchart of a procedure entitled MoveToLeft. This procedure is performed in order to move a node to the left is performed in order to move part of the contents of an index node to its left sibling. The MoveToLeft Procedure <b>1300</b> begins at entry point <b>1302</b> with the call MoveToLeft(X, A, B, h<sub>X</sub>, h<sub>A</sub>, h<sub>B</sub>). At step <b>1304</b> the variable m is defined as ½Num(B)−½Num(A). Recall that the function Num(X) returns n where X is an index node (h<sub>left</sub>, k<sub>min</sub>, h<sub>0</sub>, k<sub>0</sub>, h<sub>1</sub>, k<sub>1</sub>, . . . , k<sub>n−1</sub>, h<sub>n−1</sub>, h<sub>n</sub>, k<sub>max</sub>, h<sub>right</sub>). Thus, Num(X) returns the integer n, when n is the index of the last child handle of the node X.</p>
  <p num="p-0112">At step <b>1306</b>, the procedure tests whether IsLeaf(A) is true (i.e., whether A.h<sub>0 </sub>is null). If so, the procedure performs steps <b>1308</b> and <b>1310</b> as shown; and if not, the procedure performs steps <b>1314</b> and <b>1316</b>. These steps assign the values shown in the corresponding blocks to nodes A and B.</p>
  <p num="p-0113">Steps <b>1312</b> through <b>1330</b> write out and unlock the index nodes A, X and B, and then return.</p>
  <p num="p-0114"> <figref idrefs="DRAWINGS">FIG. 14</figref> is a flowchart of a procedure entitled MoveToRight which takes index nodes X, A, B and index node handles h<sub>X</sub>, h<sub>A</sub>, h<sub>B</sub>. Steps <b>1402</b> through <b>1406</b> are directly analogous to steps <b>1302</b> through <b>1306</b> discussed above, except in <b>1404</b> the variable n is defined as ½Num(A)+½Num(B) instead of as ½Num(B)−½Num(A). The remaining steps of procedure <b>1400</b> are similar to the corresponding steps of procedure <b>1300</b> discussed above but are modified in order to accomplish the move the right function. These differences will be apparent to one of ordinary skill in the art and will not be described here.</p>
  <p num="p-0115">G. Conclusion</p>
  <p num="p-0116">As mentioned above, while exemplary embodiments of the present invention have been described in connection with various computing devices and network architectures, the underlying concepts may be applied to any computing device or system in which it is desirable to traverse and/or perform other functions in connection with a B-Link or other data structure. Thus, the procedures and systems described above may be applied to a variety of applications and devices. While exemplary data structures, programming languages, names and examples are chosen herein as representative of various choices, these are not intended to be limiting.</p>
  <p num="p-0117">The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the present invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the debugging interface aspects of the present invention, e.g., through the use of a data processing API or the like, are preferably implemented in a high level procedural or object-oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.</p>
  <p num="p-0118">The methods and apparatus of the present invention may also be practiced via communications embodied in the form of program code that is transmitted over some transmission medium, such as over electrical wiring or cabling, through fiber optics, or via any other form of transmission, wherein, when the program code is received and loaded into and executed by a machine, such as a gate array, a programmable logic device (PLD), a client computer, or the like. When implemented on a general-purpose processor, the program code combines with the processor to provide a unique apparatus that operates to invoke the functionality of the present invention. Additionally, any storage techniques used in connection with the present invention may invariably be a combination of hardware and software.</p>
  <p num="p-0119">While the present invention has been described in connection with the presently preferred embodiments, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. For example, one skilled in the art will recognize that the present invention as described in the present application may apply to any computing device or environment, whether wired or wireless, and may be applied to any number of such computing devices connected via a communications network, and interacting across the network. Furthermore, it should be emphasized that a variety of computer platforms, including handheld device operating systems and other application specific operating systems are contemplated, especially as the number of wireless networked devices continues to proliferate. Still further, the present invention may be implemented in or across a plurality of processing chips or devices, and storage may similarly be effected across a plurality of devices. Therefore, the present invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims.</p>
</div></div></div><div class="patent-section patent-tabular-section"><a id="npl-citations"></a><div class="patent-section-header"><span class="patent-section-title">Non-Patent Citations</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th colspan="3"class="patent-data-table-th">Reference</th></tr></thead><tr><td class="patent-data-table-td ">1</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Antoshenkov, G., "<a href='http://scholar.google.com/scholar?q="Random+Sampling+from+Pseudo-Ranked+B%2B+Trees%2C"'>Random Sampling from Pseudo-Ranked B+ Trees,</a>" VLDB, 1992, 375-382.</td></tr><tr><td class="patent-data-table-td ">2</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Arnow, D.M. et al., "<a href='http://scholar.google.com/scholar?q="An+Empirical+Comparison+of+B-Trees%2C+Compact+B-Trees+and+Multiway+Trees%2C"'>An Empirical Comparison of B-Trees, Compact B-Trees and Multiway Trees,</a>" SIGMOD Conference, 1984, 33-46.</td></tr><tr><td class="patent-data-table-td ">3</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Baeza-Yates, R.A. et al., "<a href='http://scholar.google.com/scholar?q="Performance+of+B%2B-Trees+with+Partial+Expansions%2C"'>Performance of B+-Trees with Partial Expansions,</a>" TKDE, 1989, 1(2), 248-257.</td></tr><tr><td class="patent-data-table-td ">4</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Baeza-Yates, R.A., "<a href='http://scholar.google.com/scholar?q="An+Adaptive+Overflow+Technique+for+B-Trees%2C"'>An Adaptive Overflow Technique for B-Trees,</a>" EDBT, 1990, 16-28.</td></tr><tr><td class="patent-data-table-td ">5</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Baeza-Yates, R.A., "<a href='http://scholar.google.com/scholar?q="Modeling+Spits+in+File+Structures%2C"'>Modeling Spits in File Structures,</a>" Acta Informatica, 1989, 26(4), 349-362.</td></tr><tr><td class="patent-data-table-td ">6</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Baeza-Yates, R.A., "<a href='http://scholar.google.com/scholar?q="The+Expected+Behavior+of+B%2B-Trees%2C"'>The Expected Behavior of B+-Trees,</a>" Acta Informatica, 1989, 26(5), 439-471.</td></tr><tr><td class="patent-data-table-td ">7</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Bayer, R. et al., "<a href='http://scholar.google.com/scholar?q="Concurrency+of+Operations+on+B-trees%2C"'>Concurrency of Operations on B-trees,</a>" Acta Informatica, 1977, 9, 1-21.</td></tr><tr><td class="patent-data-table-td ">8</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Bayer, R. et al., "<a href='http://scholar.google.com/scholar?q="Organization+and+Maintenance+of+Large+Ordered+Indexes"'>Organization and Maintenance of Large Ordered Indexes</a>", Acta Informatica, 1972, 1, 173-189.</td></tr><tr><td class="patent-data-table-td ">9</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Bayer, R. et al., "<a href='http://scholar.google.com/scholar?q="Prefix+B-Trees%2C"'>Prefix B-Trees,</a>" TODS, 1977, 2(1), 11-26.</td></tr><tr><td class="patent-data-table-td ">10</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Biliris, A., "<a href='http://scholar.google.com/scholar?q="A+Comparative+Study+of+Concurrency+Control+Methods+in+B-Trees%2C"'>A Comparative Study of Concurrency Control Methods in B-Trees,</a>" Aegean Workshop on Computing, 1986, 305-316.</td></tr><tr><td class="patent-data-table-td ">11</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Biliris, A., "<a href='http://scholar.google.com/scholar?q="Operation+Specific+Locking+in+B-Trees%2C"'>Operation Specific Locking in B-Trees,</a>" PODS, 1987, 159-169.</td></tr><tr><td class="patent-data-table-td ">12</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Boswell, W. et al., "<a href='http://scholar.google.com/scholar?q="Alternatives+to+the+B%2B-Trees%2C"'>Alternatives to the B+-Trees,</a>" ICCI, 1990, 266-274.</td></tr><tr><td class="patent-data-table-td ">13</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Chen, S. et al., "<a href='http://scholar.google.com/scholar?q="Fractal+prefetching+B%2A-Trees%3A+optimizing+both+cache+and+disk+performance"'>Fractal prefetching B*-Trees: optimizing both cache and disk performance</a>", ACM Press, N.Y., N.Y., 2002, 157-168.</td></tr><tr><td class="patent-data-table-td ">14</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Chu, J-H. et al., "<a href='http://scholar.google.com/scholar?q="AN+Analysis+of+B-Trees+and+Their+Variants%2C"'>AN Analysis of B-Trees and Their Variants,</a>" IS, 1989, 14(5), 359-370.</td></tr><tr><td class="patent-data-table-td ">15</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Comer, D., "<a href='http://scholar.google.com/scholar?q="The+Ubiquitous+B-Tree"'>The Ubiquitous B-Tree</a>", Computing Surveys, Jun. 1979, 11(2), 121-137.</td></tr><tr><td class="patent-data-table-td ">16</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Diehr, G. et al., "<a href='http://scholar.google.com/scholar?q="Optimal+Pagination+of+B-Trees+with+Variable-Length+Items%2C"'>Optimal Pagination of B-Trees with Variable-Length Items,</a>" CACM, 1984, 27(3), 241-247.</td></tr><tr><td class="patent-data-table-td ">17</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Eisenbarth, B. et al., "<a href='http://scholar.google.com/scholar?q="The+Theory+of+Fringe+Analysis+and+its+Application+to+2-3+Trees+and+B-Trees%2C"'>The Theory of Fringe Analysis and its Application to 2-3 Trees and B-Trees,</a>" Information and Control, 1982, 55(1-3), 125-174.</td></tr><tr><td class="patent-data-table-td ">18</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Eiter, T. et al., "<a href='http://scholar.google.com/scholar?q="Sperrverfahren+fur+B-Baume+im+Vergleich%2C"'>Sperrverfahren fur B-Baume im Vergleich,</a>" Informatik Spektrum, 1991, 14(4), 183-200.</td></tr><tr><td class="patent-data-table-td ">19</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Ellis C., "<a href='http://scholar.google.com/scholar?q="Concurrent+Search+and+Insertion+in+2-3+trees%2C"'>Concurrent Search and Insertion in 2-3 trees,</a>" Acta Informatica, 1980, 14,63-86.</td></tr><tr><td class="patent-data-table-td ">20</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Faloutsos, C. et al., "<a href='http://scholar.google.com/scholar?q="On+B-Tree+Indices+for+Skewed+Distributions%2C"'>On B-Tree Indices for Skewed Distributions,</a>" VLDB, 1992, 363-374.</td></tr><tr><td class="patent-data-table-td ">21</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Ferguson, D.E., "<a href='http://scholar.google.com/scholar?q="Bit-Tree%2C+A+Data+Structure+for+Fast+File+Processing%2C"'>Bit-Tree, A Data Structure for Fast File Processing,</a>" CACM, 1992, 35(6), 114-120.</td></tr><tr><td class="patent-data-table-td ">22</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Fu, A. et al., "<a href='http://scholar.google.com/scholar?q="Concurrency+Control+of+Nested+Transactions+Accessing+B-Trees"'>Concurrency Control of Nested Transactions Accessing B-Trees</a>", ACM, 1989, 270-285.</td></tr><tr><td class="patent-data-table-td ">23</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Fujimura, K. et al., "<a href='http://scholar.google.com/scholar?q="On+Robustness+of+B-Trees%2C"'>On Robustness of B-Trees,</a>" TKDE, 1993, 5(3), 530-534.</td></tr><tr><td class="patent-data-table-td ">24</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Goh, C.H. et al., "<a href='http://scholar.google.com/scholar?q="Indexing+Temporal+Data+Using+Existing+B-30+-Trees%2C"'>Indexing Temporal Data Using Existing B-30 -Trees,</a>" DKE, 1996, 18(2), 147-165.</td></tr><tr><td class="patent-data-table-td ">25</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Goodman, N. et al., "<a href='http://scholar.google.com/scholar?q="Semantically-based+Concurrency+Control+for+Search+Structures%2C"'>Semantically-based Concurrency Control for Search Structures,</a>" Principles Of Database Systems, 1985, 8-19.</td></tr><tr><td class="patent-data-table-td ">26</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Gupta, G.K., "<a href='http://scholar.google.com/scholar?q="A+Self-Assessment+Procedure+Dealing+with+Binary+Trees+and+B-Trees%2C"'>A Self-Assessment Procedure Dealing with Binary Trees and B-Trees,</a>" Communications of the ACM, 1984, 27(5), 435-443.</td></tr><tr><td class="patent-data-table-td ">27</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Gupta, U.I. et al., "<a href='http://scholar.google.com/scholar?q="Ranking+and+Unranking+of+B-Trees%2C"'>Ranking and Unranking of B-Trees,</a>" Journal of Algorithms, 1983, 4(1), 51-60.</td></tr><tr><td class="patent-data-table-td ">28</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Hardjono, T. et al., Search Key Substitution in the Encipherment of B-Trees, VLDB, 1990, 50-58.</td></tr><tr><td class="patent-data-table-td ">29</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Held, G. et al., "<a href='http://scholar.google.com/scholar?q="B-Trees+Re-Examined%2C"'>B-Trees Re-Examined,</a>" Communications of the ACM, 1978, 21(2), 139-143.</td></tr><tr><td class="patent-data-table-td ">30</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Hellerstein, J.M. et al., "<a href='http://scholar.google.com/scholar?q="Generalized+Search+Trees+for+Database+Systems%2C"'>Generalized Search Trees for Database Systems,</a>" VLDB, 1995, 1-12.</td></tr><tr><td class="patent-data-table-td ">31</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Ishak, R., "<a href='http://scholar.google.com/scholar?q="Semantically+Consistent+Schedules+for+Efficient+and+Concurrent+B-Tree+Restructuring%2C"'>Semantically Consistent Schedules for Efficient and Concurrent B-Tree Restructuring,</a>" ICDE, 1992, 184-191.</td></tr><tr><td class="patent-data-table-td ">32</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Jannink, J., "<a href='http://scholar.google.com/scholar?q="Implementing+Deletion+in+B%2B-Trees%2C"'>Implementing Deletion in B+-Trees,</a>" SIGMOD Record, 1995, 24(1), 33-38.</td></tr><tr><td class="patent-data-table-td ">33</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Johnson, T. et al., "<a href='http://scholar.google.com/scholar?q="A+Framework+for+the+Performance+Analysis+of+Concurrent+B-Tree+Algorithms%2C"'>A Framework for the Performance Analysis of Concurrent B-Tree Algorithms,</a>" PODS, 1990, 273-287.</td></tr><tr><td class="patent-data-table-td ">34</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Johnson, T. et al., "<a href='http://scholar.google.com/scholar?q="B-Trees+with+Inserts+and+Deletes%3A+Why+Free-at-Empty+is+Better+than+Merge-at-Half%2C"'>B-Trees with Inserts and Deletes: Why Free-at-Empty is Better than Merge-at-Half,</a>" Journal of Computer and System Sciences, 1993, 47(1), 45-76.</td></tr><tr><td class="patent-data-table-td ">35</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Johnson, T. et al., "<a href='http://scholar.google.com/scholar?q="The+Performance+of+Current+B-Tree+Algorithms%2C"'>The Performance of Current B-Tree Algorithms,</a>" ACM Transactions On Database Systems, 1993, 18(1), 51-101.</td></tr><tr><td class="patent-data-table-td ">36</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Johnson, T. et al., "<a href='http://scholar.google.com/scholar?q="Utilization+of+B-Trees+with+Inserts%2C+Deletes+and+Modifies%2C"'>Utilization of B-Trees with Inserts, Deletes and Modifies,</a>" PODS, 1989, 235-246.</td></tr><tr><td class="patent-data-table-td ">37</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Keller, A.M. et al., "<a href='http://scholar.google.com/scholar?q="Concurrent+Use+of+B-Trees+with+Variable-Length+Entries%2C"'>Concurrent Use of B-Trees with Variable-Length Entries,</a>" SIGMOD Record, 1988, 17(2), 89-90.</td></tr><tr><td class="patent-data-table-td ">38</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Kersten, M. et al., "<a href='http://scholar.google.com/scholar?q="Application+of+an+Optimistic+Concurrency+Control+Method%2C"'>Application of an Optimistic Concurrency Control Method,</a>" Software Practice and Experience, 1984, 14(2), 153-168.</td></tr><tr><td class="patent-data-table-td ">39</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Kuspert, K., "<a href='http://scholar.google.com/scholar?q="Storage+Utilization+in+B%2A-Trees+with+a+Generalized+Overflow+Technique%2C"'>Storage Utilization in B*-Trees with a Generalized Overflow Technique,</a>" Acta Informatica, 1983, 19, 35-55.</td></tr><tr><td class="patent-data-table-td ">40</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Kwong, Y. et al., "<a href='http://scholar.google.com/scholar?q="A+New+Method+for+Concurrency+in+B-Trees%2C"'>A New Method for Concurrency in B-Trees,</a>" IEE Transaction on Software Engineering, 1982, 8(3), 211-222.</td></tr><tr><td class="patent-data-table-td ">41</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Kwong, Y. et al., "<a href='http://scholar.google.com/scholar?q="Approaches+to+Concurrency+in+B-trees%2C"'>Approaches to Concurrency in B-trees,</a>" MFCS, 1980, 402-413.</td></tr><tr><td class="patent-data-table-td ">42</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Kwong, Y. et al., "<a href='http://scholar.google.com/scholar?q="Concurrent+Operations+in+Large+Ordered+Indices%2C"'>Concurrent Operations in Large Ordered Indices,</a>" Lecture Notes in Computer Science, 1980, 83, 207-222.</td></tr><tr><td class="patent-data-table-td ">43</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Kwong, Y-S. et al., "<a href='http://scholar.google.com/scholar?q="On+B-Trees%3A+Routing+Schemes+and+Concurrency%2C"'>On B-Trees: Routing Schemes and Concurrency,</a>" SIGMOD Conference, 1980, 207-213.</td></tr><tr><td class="patent-data-table-td ">44</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Langenhop, C. et al., "<a href='http://scholar.google.com/scholar?q="A+Model+of+the+Dynamic+Behavior+of+B-Trees%2C"'>A Model of the Dynamic Behavior of B-Trees,</a>" Acta Informatica, 1989, 27(1), 41-59.</td></tr><tr><td class="patent-data-table-td ">45</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Lanin, V. et al., "<a href='http://scholar.google.com/scholar?q="A+Symmetric+Concurrent+B-Tree+Algorithm%2C"'>A Symmetric Concurrent B-Tree Algorithm,</a>" FJCC, 1986, 380-389.</td></tr><tr><td class="patent-data-table-td ">46</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Lanka, S. et al., "<a href='http://scholar.google.com/scholar?q="Fully+Persistent+B%2B-Trees%2C"'>Fully Persistent B+-Trees,</a>" SIGMOD Conference,1991, 426-435.</td></tr><tr><td class="patent-data-table-td ">47</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Lausen, G., "<a href='http://scholar.google.com/scholar?q="Integrated+Concurrency+Control+Shared+B-Trees%2C"'>Integrated Concurrency Control Shared B-Trees,</a>" Computing, 1984, 33(1), 13-26.</td></tr><tr><td class="patent-data-table-td ">48</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Lehman, P.L. et al., "<a href='http://scholar.google.com/scholar?q="Efficient+Locking+for+Concurrent+Operations+on+B-Trees"'>Efficient Locking for Concurrent Operations on B-Trees</a>", ACM Transactions on Database Systems, Dec. 1981, 6(4), 650-670.</td></tr><tr><td class="patent-data-table-td ">49</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Leung, C., "<a href='http://scholar.google.com/scholar?q="Approximate+Storage+Utilisation+of+B-Trees%3A+A+Simple+Derivation+and+Generalisation%2C"'>Approximate Storage Utilisation of B-Trees: A Simple Derivation and Generalisation,</a>" Information Processing Letters, 1984, 19(4), 199-201.</td></tr><tr><td class="patent-data-table-td ">50</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Lomet, D.B. et al., "<a href='http://scholar.google.com/scholar?q="Access+Method+Concurrency+with+Recovery%2C"'>Access Method Concurrency with Recovery,</a>" SIGMOD Conference, 1992, 351-360.</td></tr><tr><td class="patent-data-table-td ">51</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Lomet, D.B., "<a href='http://scholar.google.com/scholar?q="Multi-Table+Search+for+B-Tree+Files%2C"'>Multi-Table Search for B-Tree Files,</a>" SIGMOD Conference, 1979, 35-42.</td></tr><tr><td class="patent-data-table-td ">52</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Lomet, D.B., "<a href='http://scholar.google.com/scholar?q="Partial+Expansions+for+File+Organizations+with+an+Index%2C"'>Partial Expansions for File Organizations with an Index,</a>" ACM Transactions on Database Systems, 1987, 12(1), 65-84.</td></tr><tr><td class="patent-data-table-td ">53</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Lum, V.Y., "<a href='http://scholar.google.com/scholar?q="Multi-Attribute+Retrieval+with+Combined+Indexes%2C"'>Multi-Attribute Retrieval with Combined Indexes,</a>" Communications of the ACM, 1970, 13(11), 660-665.</td></tr><tr><td class="patent-data-table-td ">54</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Maelbrancke, R. et al., "<a href='http://scholar.google.com/scholar?q="Optimizing+Jan+Jannink%27s+Implementation+of+B%2B-Tree+Deletion%2C"'>Optimizing Jan Jannink's Implementation of B+-Tree Deletion,</a>" SIGMOD Record, 1995, 24(3), 5-7.</td></tr><tr><td class="patent-data-table-td ">55</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">McCreight, E.M., "<a href='http://scholar.google.com/scholar?q="Pagination+of+B%2A-Trees+with+Variable-Length+Records%2C"'>Pagination of B*-Trees with Variable-Length Records,</a>" Communications of the ACM, 1977, 20(9), 670-674.</td></tr><tr><td class="patent-data-table-td ">56</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Mohan, C. et al., "<a href='http://scholar.google.com/scholar?q="Algorithms+for+Creating+Indexes+for+Very+Large+Tables+Without+Quiescing+Updates%2C"'>Algorithms for Creating Indexes for Very Large Tables Without Quiescing Updates,</a>" SIGMOD Conference, 1992, 361-370.</td></tr><tr><td class="patent-data-table-td ">57</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Mohan, C. et al., "<a href='http://scholar.google.com/scholar?q="ARIES%2FIM%3A+An+Efficient+and+High+Concurrency+Index+Management+Method+Using+Write-Ahead+Logging%2C"'>ARIES/IM: An Efficient and High Concurrency Index Management Method Using Write-Ahead Logging,</a>" SIGMOD Conference, 1992, 371-380.</td></tr><tr><td class="patent-data-table-td ">58</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Mohan, C., "<a href='http://scholar.google.com/scholar?q="ARIES%2FKVL%3A+A+Key-Value+Locking+Method+for+Concurrency+Control+of+Multiaction+Transactions+Operating+on+B-Tree+Indexes%2C"'>ARIES/KVL: A Key-Value Locking Method for Concurrency Control of Multiaction Transactions Operating on B-Tree Indexes,</a>" Proceedings of the 16&lt;SUP&gt;th &lt;/SUP&gt;VLDB Conference, 1990, 392-405.</td></tr><tr><td class="patent-data-table-td ">59</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Mond, Y. et al., "<a href='http://scholar.google.com/scholar?q="Concurrency+Control+in+B-Trees%2B-Trees+Database+Using+Preparatory+Operations%2C"'>Concurrency Control in B-Trees+-Trees Database Using Preparatory Operations,</a>" VLDB, 1985, 331-334.</td></tr><tr><td class="patent-data-table-td ">60</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Nakamura, T. et al., "<a href='http://scholar.google.com/scholar?q="An+Analysis+of+Storage+Utilization+Factor+in+Block+Split+Data+Structuring+Scheme%2C"'>An Analysis of Storage Utilization Factor in Block Split Data Structuring Scheme,</a>" VLDB, 1978, 489-495.</td></tr><tr><td class="patent-data-table-td ">61</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Nurmi, O. et al., "<a href='http://scholar.google.com/scholar?q="Concurrency+Control+in+Databse+Structures+with+Relaxed+Balance%2C"'>Concurrency Control in Databse Structures with Relaxed Balance,</a>" PODS, 1987, 170-176.</td></tr><tr><td class="patent-data-table-td ">62</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Olken, F. et al., "<a href='http://scholar.google.com/scholar?q="Random+Sampling+from+B%2B+Trees%2C"'>Random Sampling from B+ Trees,</a>" Proceedings of the 15&lt;SUP&gt;th &lt;/SUP&gt;International Conference on Very Large Data Bases, 1989, 269-277.</td></tr><tr><td class="patent-data-table-td ">63</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">O'Neil, P.E., "<a href='http://scholar.google.com/scholar?q="The+SB-Tree%3A+An+Index-Sequential+Structure+for+High-Performance+Sequential+Access%2C"'>The SB-Tree: An Index-Sequential Structure for High-Performance Sequential Access,</a>" Acta Informatica, 1992, 29(3), 241-265.</td></tr><tr><td class="patent-data-table-td ">64</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Ouksel, M. et al., "<a href='http://scholar.google.com/scholar?q="Multidimensional+B-Trees%3A+Analysis+of+Dynamic+Behavior%2C"'>Multidimensional B-Trees: Analysis of Dynamic Behavior,</a>" BIT, 1981, 21, 401-418.</td></tr><tr><td class="patent-data-table-td ">65</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Phuc, N.H. et al., "<a href='http://scholar.google.com/scholar?q="Performance+Comparison+Between+B%2A-Tree+and+Prefix+Binary+Tree+Index+Organizations%2C"'>Performance Comparison Between B*-Tree and Prefix Binary Tree Index Organizations,</a>" International Conference On Databases, 1983, vol. 19, 358-376.</td></tr><tr><td class="patent-data-table-td ">66</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Pinchuk, A.P. et al., "<a href='http://scholar.google.com/scholar?q="Maintaining+Dictionaries%3A+Space-Saving+Modifications+of+B-Trees%2C"'>Maintaining Dictionaries: Space-Saving Modifications of B-Trees,</a>" ICDT, 1992, 421-435.</td></tr><tr><td class="patent-data-table-td ">67</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Pollari-Malmi, K. et al., "<a href='http://scholar.google.com/scholar?q="Concurrency+Control+in+B-Trees+with+Batch+updates"'>Concurrency Control in B-Trees with Batch updates</a>", IEEE Transactions on Knowledge and Data Engineering, Dec. 1996, 8(6), 975-984.</td></tr><tr><td class="patent-data-table-td ">68</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Rosenberg, A.L. et al., "<a href='http://scholar.google.com/scholar?q="Compact+B-Trees%2C"'>Compact B-Trees,</a>" SIGMOD Conference, 1979, 43-51.</td></tr><tr><td class="patent-data-table-td ">69</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Rosenberg, A.L. et al., "<a href='http://scholar.google.com/scholar?q="Time-+and+Space+Optimality+in+B-Trees%2C"'>Time- and Space Optimality in B-Trees,</a>" ACM Transactions on Database Systems, 1981, 6(1), 174-193.</td></tr><tr><td class="patent-data-table-td ">70</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Sagiv, Y. "<a href='http://scholar.google.com/scholar?q="Concurrent+Operations+on+B%2A-Trees+with+Overtaking"'>Concurrent Operations on B*-Trees with Overtaking</a>", Journal of Computer Science, 1986, 33, 275-295.</td></tr><tr><td class="patent-data-table-td ">71</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Sagiv, Y., "<a href='http://scholar.google.com/scholar?q="Concurrent+Operations+on+B%2A-Trees+with+Overtaking"'>Concurrent Operations on B*-Trees with Overtaking</a>", Journal of Computer and System Sciences, 1986, 33, 275-296.</td></tr><tr><td class="patent-data-table-td ">72</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Samadi, B., "<a href='http://scholar.google.com/scholar?q="B-Trees+in+a+System+with+Multiple+users%2C"'>B-Trees in a System with Multiple users,</a>" Information Processing Letters, 1976, 5(4), 107-112.</td></tr><tr><td class="patent-data-table-td ">73</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Scheuermann, P. et al., "<a href='http://scholar.google.com/scholar?q="Multidimensional+B-Trees+for+Associative+Searching+in+Database+Systems%2C"'>Multidimensional B-Trees for Associative Searching in Database Systems,</a>" Information Systems, 1982, 7(2), 123-137.</td></tr><tr><td class="patent-data-table-td ">74</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Seeger, B. et al., "<a href='http://scholar.google.com/scholar?q="Multi-Disk+B-Trees%2C"'>Multi-Disk B-Trees,</a>" SIGMOD Conference, 1991, 436-445.</td></tr><tr><td class="patent-data-table-td ">75</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Setzer, V.W. et al., "<a href='http://scholar.google.com/scholar?q="New+Concurrency+Control+Algorithms+for+Accessing+and+Compacting+B-Trees%2C"'>New Concurrency Control Algorithms for Accessing and Compacting B-Trees,</a>" Proceedings of the 20&lt;SUP&gt;th &lt;/SUP&gt;VLDB Conference, 1994, 238-248.</td></tr><tr><td class="patent-data-table-td ">76</td><td class="patent-data-table-td "><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td ">Shimin Chen, "<a href='http://scholar.google.com/scholar?q="Fractual+prefetchig+B-Trees%3A+optimizing+both+cache+and+disk+performance"'>Fractual prefetchig B-Trees: optimizing both cache and disk performance</a>" 2002, ACM Press, N.Y, N.Y., pp. 157-168.</td></tr><tr><td class="patent-data-table-td ">77</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Snyder, L., "<a href='http://scholar.google.com/scholar?q="On+B-Trees+Re-Examined%2C"'>On B-Trees Re-Examined,</a>" Communications of the ACM, 1977, 21(7), 594.</td></tr><tr><td class="patent-data-table-td ">78</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Spirn, J.R. et al., "<a href='http://scholar.google.com/scholar?q="Memory+Management+for+B-Trees%2C"'>Memory Management for B-Trees,</a>" Performance Evaluation, 1985, 5, 159-174.</td></tr><tr><td class="patent-data-table-td ">79</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Srinivasan, V. et al., "<a href='http://scholar.google.com/scholar?q="Performance+of+B%2B+Tree+Concurrency+Algorithms%2C"'>Performance of B+ Tree Concurrency Algorithms,</a>" VLDB Journal., 1993, 2(4), 361-406.</td></tr><tr><td class="patent-data-table-td ">80</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Srinivasan, V. et al., "<a href='http://scholar.google.com/scholar?q="Performance+of+B-Tree+Concurrency+Algorithms%2C"'>Performance of B-Tree Concurrency Algorithms,</a>" SIGMOD Conference, 1991, 416-425.</td></tr><tr><td class="patent-data-table-td ">81</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Srinivasan, V. et al., "<a href='http://scholar.google.com/scholar?q="Performance+of+On-Line+Index+Construction+Algorithms%2C"'>Performance of On-Line Index Construction Algorithms,</a>" EDBT, 1992, 293-309.</td></tr><tr><td class="patent-data-table-td ">82</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Srivastava, J. et al., "<a href='http://scholar.google.com/scholar?q="Efficient+Algorithms+for+Maintenance+of+Large+Database%2C"'>Efficient Algorithms for Maintenance of Large Database,</a>" ICDE, 1988, 402-408.</td></tr><tr><td class="patent-data-table-td ">83</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Sullivan, M. et al., "<a href='http://scholar.google.com/scholar?q="An+Index+Implementation+Supporting+Fast+Recovery+for+the+POSTGRES+Storage+System%2C"'>An Index Implementation Supporting Fast Recovery for the POSTGRES Storage System,</a>" ICDE, 1992, 293-300.</td></tr><tr><td class="patent-data-table-td ">84</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Tharp, A.L. et al., "<a href='http://scholar.google.com/scholar?q="B%2B+Trees%2C+Bounded+Disorder+and+Adaptive+Hashing%2C"'>B+ Trees, Bounded Disorder and Adaptive Hashing,</a>" IS, 1991, 16(1), 65-71.</td></tr><tr><td class="patent-data-table-td ">85</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Wang, P., "<a href='http://scholar.google.com/scholar?q="An+In-Depth+Analysis+of+Concurrent+B-tree+Algorithms"'>An In-Depth Analysis of Concurrent B-tree Algorithms</a>", Report is a Minor Revision of a Master's Thesis of the Same Title submitted to the Department of Electrical Engineering and Computer Science, Jan. 10, 1991, 131 pages.</td></tr><tr><td class="patent-data-table-td ">86</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Wedekind, H., "<a href='http://scholar.google.com/scholar?q="On+the+Selection+of+Access+Paths+in+a+Data+Base+System"'>On the Selection of Access Paths in a Data Base System</a>", Data Base Management, 1974, 385-397.</td></tr><tr><td class="patent-data-table-td ">87</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Wright, W.E., "<a href='http://scholar.google.com/scholar?q="Some+Average+Performance+Measures+for+the+B-Tree%2C"'>Some Average Performance Measures for the B-Tree,</a>" Acta Informatica, 1985, 21, 541-557.</td></tr><tr><td class="patent-data-table-td ">88</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Zhang, B. et al., "<a href='http://scholar.google.com/scholar?q="Unsafe+Operations+in+B-Trees%2C"'>Unsafe Operations in B-Trees,</a>" Acta Informatica, 1989, 26(5), 421-438.</td></tr></table><div class="patent-section-footer">* Cited by examiner</div></div><div class="patent-section patent-tabular-section"><a id="forward-citations"></a><div class="patent-section-header"><span class="patent-section-title">Referenced by</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th">Citing Patent</th><th class="patent-data-table-th">Filing date</th><th class="patent-data-table-th">Publication date</th><th class="patent-data-table-th">Applicant</th><th class="patent-data-table-th">Title</th></tr></thead><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8055613">US8055613</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Apr 29, 2008</td><td class="patent-data-table-td patent-date-value">Nov 8, 2011</td><td class="patent-data-table-td ">Netapp, Inc.</td><td class="patent-data-table-td ">Method and apparatus for efficiently detecting and logging file system changes</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8650219">US8650219</a></td><td class="patent-data-table-td patent-date-value">Jun 5, 2012</td><td class="patent-data-table-td patent-date-value">Feb 11, 2014</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">Persistent iteration over a database tree structure</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8769606">US8769606</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Dec 29, 2009</td><td class="patent-data-table-td patent-date-value">Jul 1, 2014</td><td class="patent-data-table-td ">Sap Ag</td><td class="patent-data-table-td ">Computer-implemented method, computer system, and computer program product for optimization of evaluation of a policy specification</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US20100306818">US20100306818</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Dec 29, 2009</td><td class="patent-data-table-td patent-date-value">Dec 2, 2010</td><td class="patent-data-table-td ">Sap Ag</td><td class="patent-data-table-td ">Computer-Implemented Method, Computer System, And Computer Program Product for Optimization Of Evaluation Of A Policy Specification</td></tr></table><div class="patent-section-footer">* Cited by examiner</div></div><div class="patent-section patent-tabular-section"><a id="classifications"></a><div class="patent-section-header"><span class="patent-section-title">Classifications</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th"> </th><th class="patent-data-table-th"> </th></tr></thead><tr><td class="patent-data-table-td ">U.S. Classification</td><td class="patent-data-table-td "><span class="nested-value"><a href="http://www.google.com/url?id=sIB1BAABERAJ&q=http://www.uspto.gov/web/patents/classification/uspc001/defs001.htm&usg=AFQjCNG37WdtIPCwBOhdSwF0dt2rkf76Nw#C001S001000">1/1</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=sIB1BAABERAJ&q=http://www.uspto.gov/web/patents/classification/uspc707/defs707.htm&usg=AFQjCNE7Q7Bg2eD2wcE_fXEcdOe7Yesevw#C707SE17011">707/E17.011</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=sIB1BAABERAJ&q=http://www.uspto.gov/web/patents/classification/uspc707/defs707.htm&usg=AFQjCNE7Q7Bg2eD2wcE_fXEcdOe7Yesevw#C707S999103">707/999.103</a></span></td></tr><tr><td class="patent-data-table-td ">International Classification</td><td class="patent-data-table-td "><span class="nested-value"><a href="http://www.google.com/url?id=sIB1BAABERAJ&q=http://web2.wipo.int/ipcpub/&usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&notion=scheme&version=20130101&symbol=G06F0012000000">G06F12/00</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=sIB1BAABERAJ&q=http://web2.wipo.int/ipcpub/&usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&notion=scheme&version=20130101&symbol=G06F0017300000">G06F17/30</a></span></td></tr><tr><td class="patent-data-table-td ">Cooperative Classification</td><td class="patent-data-table-td "><span class="nested-value"><a href="http://www.google.com/url?id=sIB1BAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=Y10S707/918">Y10S707/918</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=sIB1BAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=Y10S707/99944">Y10S707/99944</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=sIB1BAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=G06F17/30958">G06F17/30958</a></span></td></tr><tr><td class="patent-data-table-td ">European Classification</td><td class="patent-data-table-td "><span class="nested-value">G06F17/30Z1G</span></td></tr></table><div class="patent-section-footer"></div></div><div class="patent-section patent-tabular-section"><a id="legal-events"></a><div class="patent-section-header"><span class="patent-section-title">Legal Events</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th">Date</th><th class="patent-data-table-th">Code</th><th class="patent-data-table-th">Event</th><th class="patent-data-table-th">Description</th></tr></thead><tr><td class="patent-data-table-td patent-date-value">Dec 30, 2013</td><td class="patent-data-table-td ">FPAY</td><td class="patent-data-table-td ">Fee payment</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Year of fee payment: </span><span class="nested-value">8</span></div></td></tr><tr><td class="patent-data-table-td patent-date-value">Dec 23, 2009</td><td class="patent-data-table-td ">FPAY</td><td class="patent-data-table-td ">Fee payment</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Year of fee payment: </span><span class="nested-value">4</span></div></td></tr><tr><td class="patent-data-table-td patent-date-value">May 6, 2009</td><td class="patent-data-table-td ">AS</td><td class="patent-data-table-td ">Assignment</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Owner name: </span><span class="nested-value">OSTRASSE KRALL GMBH., LLC., DELAWARE</span></div><div class="nested-key-value"><span class="nested-key">Free format text: </span><span class="nested-value">ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:MICROSOFT CORPORATION;REEL/FRAME:022645/0206</span></div><div class="nested-key-value"><span class="nested-key">Effective date: </span><span class="nested-value">20090424</span></div></td></tr><tr><td class="patent-data-table-td patent-date-value">Nov 25, 2008</td><td class="patent-data-table-td ">B1</td><td class="patent-data-table-td ">Reexamination certificate first reexamination</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Free format text: </span><span class="nested-value">CLAIMS 1, 10 AND 12 ARE CANCELLED. NEW CLAIM 18 IS ADDED AND DETERMINED TO BE PATENTABLE. CLAIMS 2-9, 11 AND 13-17 WERE NOT REEXAMINED.</span></div></td></tr><tr><td class="patent-data-table-td patent-date-value">Apr 10, 2007</td><td class="patent-data-table-td ">RR</td><td class="patent-data-table-td ">Request for reexamination filed</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Effective date: </span><span class="nested-value">20061212</span></div></td></tr></table><div class="patent-section-footer"></div></div><div class="modal-dialog" id="patent-images-lightbox"><div class="patent-lightbox-controls"><div class="patent-lightbox-rotate-controls"><div class="patent-lightbox-rotation-text">Rotate</div><div class="rotate-icon rotate-ccw-icon"></div><div class="rotate-icon rotate-cw-icon"></div></div><div class="patent-lightbox-index-counter"></div><a class="patent-lightbox-fullsize-link" target="_blank">Original Image</a><div class="patent-drawings-control patent-drawings-next"><img class="patent-drawings-button-img"src="/googlebooks/images/kennedy/page_right.png" alt="Next page"width="21" height="21" /></div><div class="patent-drawings-control patent-drawings-prev"><img class="patent-drawings-button-img"src="/googlebooks/images/kennedy/page_left.png" alt="Previous page"width="21" height="21" /></div></div><div class="modal-dialog-content"><div class="patent-lightbox-image-holder"><div class="patent-lightbox-placeholder"></div></div></div></div><script>_OC_initPatentsAtb({image_not_available_html: " Image not available"});</script></div></div></div></td></tr></table><script>(function() {var href = window.location.href;if (href.indexOf('?') !== -1) {var parameters = href.split('?')[1].split('&');for (var i = 0; i < parameters.length; i++) {var param = parameters[i].split('=');if (param[0] == 'focus') {var elem = document.getElementById(param[1]);if (elem) {elem.focus();}}}}})();</script><script>_OC_addFlags({LockSrc:"/books/javascript/lock_8a2b04e7bf975d5171d8e4c0b6365c7a.js", Host:"http://www.google.com/", IsBooksRentalEnabled:1, IsWebstoreDisplayCaseEnabled:1, IsObfuscationEnabled:1, IsBrowsingHistoryEnabled:1, IsWebReaderSvgEnabled:0, IsGeoLayerEnabled:1, IsImageModeNotesEnabled:1, IsCopyMenuItemEnabled:1, IsGiftingEnabled:0, IsWebReaderUniversalPaginatorEnabled:0, IsOfflineBubbleEnabled:1, IsReaderEnabledForPlayRequests:1, IsFutureOnSaleVolumesEnabled:1, IsOfflineRestrictedCopyEnabled:1, IsBooksUnifiedLeftNavEnabled:1, IsRestrictedCopyEnabled:1, IsZipitFolderCollectionEnabled:1, IsEndOfSampleRecommendationsEnabled:1, IsRatingsOnBookcardsEnabled:1, IsAdsDisabled:0, IsIframePageDisplayEnabled:0, IsEmbeddedMediaEnabled:1, IsImageModeAnnotationsEnabled:1, IsMyLibraryGooglePlusEnabled:1, IsImagePageProviderEnabled:0, IsBookcardListPriceSmall:0, IsInternalUser:0, IsBooksShareButtonEnabled:0, IsPreOrdersEnabled:0, IsDisabledRandomBookshelves:0, WebstoreDisplayCasePosition:3});_OC_Run({"enable_p13n":false,"add_vol_to_collection_base_url":"http://www.google.com/patents?op=add\u0026sig=ACfU3U3KgWRymX8JlpBC5lkL6v3ClqavLg\u0026id=sIB1BAABERAJ","remove_vol_from_collection_base_url":"http://www.google.com/patents?op=remove\u0026sig=ACfU3U3WmRGZ6fw9b1L0l9jvAJTUoQfgoA\u0026id=sIB1BAABERAJ","logged_in":false,"p13n_save_user_settings_url":"http://www.google.com/patents?op=edit_user_settings\u0026sig=ACfU3U0KgZ53sAfPkIRoEb1iOJ5FbTKHOw","is_cobrand":false,"sign_in_url":"https://www.google.com/accounts/Login?service=\u0026continue=http://www.google.com/patents%3Fhl%3Den\u0026hl=en","is_play_enabled":true}, {"volume_id":"","is_ebook":true,"volumeresult":{"has_flowing_text":false,"has_scanned_text":true,"can_download_pdf":false,"can_download_epub":false,"is_pdf_drm_enabled":false,"is_epub_drm_enabled":false,"download_pdf_url":"http://www.google.com/patents/download/Algorithm_for_tree_traversals_using_left.pdf?id=sIB1BAABERAJ\u0026output=pdf\u0026sig=ACfU3U1V_g_OJb5BfTiJkcPxzG3mMpDphA"},"sample_url":"http://www.google.com/patents/reader?id=sIB1BAABERAJ\u0026printsec=frontcover\u0026output=reader\u0026source=gbs_atb_hover","is_browsable":true,"is_public_domain":true}, {});</script><div id="footer_table" style="font-size:83%;text-align:center;position:relative;top:20px;height:4.5em;margin-top:2em"><div style="margin-bottom:8px"><a href=http://www.google.com/><nobr>Google&nbsp;Home</nobr></a> - <a href=//www.google.com/patents/sitemap/><nobr>Sitemap</nobr></a> - <a href=http://www.google.com/googlebooks/uspto.html><nobr>USPTO Bulk Downloads</nobr></a> - <a href=/intl/en/privacy/><nobr>Privacy Policy</nobr></a> - <a href=/intl/en/policies/terms/><nobr>Terms of Service</nobr></a> - <a href=https://support.google.com/faqs/answer/2539193?hl=en><nobr>About Google Patents</nobr></a> - <a href="http://www.google.com/tools/feedback/intl/en/error.html" onclick="try{_OC_startFeedback({productId: '72792',locale: 'en'});return false;}catch(e){}"><nobr>Send Feedback</nobr></a></div><span>Data provided by IFI CLAIMS Patent Services</span><br><span >&copy;2012 Google</span></div> <script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-27188110-1");pageTracker._setCookiePath("/patents/");pageTracker._trackPageview();</script> </body></html>