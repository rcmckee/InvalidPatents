<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><title>Patent US6819670 - Data packet routing for mobile networks - Google Patents</title><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){var d=void 0!=b?b:(new Date).getTime();this.t[a]=[d,c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(e){}};this.tick("start",null,a)}var a;window.performance&&(a=window.performance.timing);var f=a?new e(a.responseStart):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart,d=a.responseStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_",
"_wtsrt",d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();})();
</script><link rel="stylesheet" href="/patents/css/_8a2b04e7bf975d5171d8e4c0b6365c7a/kl_intl_patents_bundle.css" type="text/css" /><script src="/books/javascript/atb_8a2b04e7bf975d5171d8e4c0b6365c7a__en.js"></script><script>function googleTranslateElementInit() {new google.translate.TranslateElement({pageLanguage: "en",gaTrack: true,gaId: "UA-27188110-1",multilanguagePage: true});}</script><script src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script><meta name="DC.type" content="Patent"><meta name="DC.title" content="Data packet routing for mobile networks"><meta name="DC.contributor" content="Peter R. Fenner" scheme="inventor"><meta name="DC.contributor" content="Fenner Investments, Ltd." scheme="assignee"><meta name="DC.date" content="1999-1-8" scheme="dateSubmitted"><meta name="DC.description" content="To provide fast access times with very large key fields, an associative memory utilizes a location addressable memory and lookup table to generate from a key the address in memory storing an associated record. The lookup tables, stored in memory, are constructed with the aid of arithmetic data compression methods to create a near perfect hashing of the keys. For encoding into the lookup table, keys are divided into a string of symbols. Each valid and invalid symbol is assigned an index value, such that the sum of valid index values for symbols of a particular key is a unique value that is used as an address to the memory storing the record associated with that key, and the sum of keys containing invalid index values point to a location in memory containing similar data. Utilizing the lookup tables set and relational operations maybe carried out that provide a user with a maximum number of key records resulting from a sequence of intersection, union and mask operations."><meta name="DC.date" content="2004-11-16" scheme="issued"><meta name="DC.relation" content="EP:0255767:A2" scheme="references"><meta name="DC.relation" content="FR:2513472" scheme="references"><meta name="DC.relation" content="GB:2189112" scheme="references"><meta name="DC.relation" content="US:3355556" scheme="references"><meta name="DC.relation" content="US:3678391" scheme="references"><meta name="DC.relation" content="US:3979733" scheme="references"><meta name="DC.relation" content="US:4276643" scheme="references"><meta name="DC.relation" content="US:4494230" scheme="references"><meta name="DC.relation" content="US:4597078" scheme="references"><meta name="DC.relation" content="US:4603416" scheme="references"><meta name="DC.relation" content="US:4606002" scheme="references"><meta name="DC.relation" content="US:4644351" scheme="references"><meta name="DC.relation" content="US:4661951" scheme="references"><meta name="DC.relation" content="US:4706081" scheme="references"><meta name="DC.relation" content="US:4742511" scheme="references"><meta name="DC.relation" content="US:4797881" scheme="references"><meta name="DC.relation" content="US:4812843" scheme="references"><meta name="DC.relation" content="US:4833701" scheme="references"><meta name="DC.relation" content="US:4843622" scheme="references"><meta name="DC.relation" content="US:4866431" scheme="references"><meta name="DC.relation" content="US:4875208" scheme="references"><meta name="DC.relation" content="US:4887265" scheme="references"><meta name="DC.relation" content="US:4896319" scheme="references"><meta name="DC.relation" content="US:4912756" scheme="references"><meta name="DC.relation" content="US:4916691" scheme="references"><meta name="DC.relation" content="US:4922503" scheme="references"><meta name="DC.relation" content="US:4953162" scheme="references"><meta name="DC.relation" content="US:4989204" scheme="references"><meta name="DC.relation" content="US:5095480" scheme="references"><meta name="DC.relation" content="US:5168498" scheme="references"><meta name="DC.relation" content="US:5365520" scheme="references"><meta name="DC.relation" content="US:5490258" scheme="references"><meta name="DC.relation" content="US:5842224" scheme="references"><meta name="DC.relation" content="US:5860136" scheme="references"><meta name="citation_reference" content="Bartee, T.C. et al., &quot;C31 Information Systems Internetwork Study,&quot; Institute for Defense Analyses, Apr. 1984."><meta name="citation_reference" content="Deering, Stephen E., &quot;Multicast Routing in Internetworks and Extended LANs,&quot; pp. 55-64, 1988 ACM."><meta name="citation_reference" content="Elden, Walter L. et al., &quot;LAN Interoperability Study of Protocols Needed for Distributed Command and Control,&quot; Final Technical Report, Mar. 1985."><meta name="citation_reference" content="Estrin, Deborah, &quot;Interconnection Protocols for Interorganization Networks,&quot; Reprinted from IEEE J. Selected Areas Commun., vol. SAC-5, No. 9, pp. 1480-1491, Dec. 1987."><meta name="citation_reference" content="G. Parr, &quot;A More Fault Tolerant Approach to Address Resolution for a Multi-Lan System of Ethernets,&quot; Network Working Group, Request for Comments: 1029, May 12, 1988, pp. 1-16, University of Ulster."><meta name="citation_reference" content="G. Parr, &quot;Address Resolution for an Intelligent Filtering Bridge Running on a Subnetted Ethernet System,&quot; Institute of Informatics, Computer Science Dept., 1987, pp. 48-70, Univ. of Ulster at Coleraine, County Londonderry, N. Ireland."><meta name="citation_reference" content="Kleinrock, Leonard et al., &quot;Hierarchical Routing for Large Networks, Performance Evaluation and Optimization,&quot; Reprinted from Computer Networks, vol. 1, pp. 155-174, Jan. 1977."><meta name="citation_reference" content="Shoch, John F., &quot;Inter-Network Naming, Addressing, and Routing,&quot; Reprinted from IEEE Proc. COMPCON, pp. 72-79, 1978."><meta name="citation_reference" content="Sunshine, Carl A., &quot;Addressing Problems in Multi-Network Systems,&quot; Reprinted from IEEE Proc. INFOCOM, pp. 12-18, 1982."><meta name="citation_reference" content="Tsuchiya, Paul F, &quot;The Landmark Hierarchy: A New Hierarchy for Routing in Very Large Networks,&quot; The Mitre Corporation, pp. 35-42, 1988 ACM."><meta name="citation_reference" content="Tsudik, Gene, &quot;Implications of Fragmentation and Dynamic Routing for Internet Datagram Authentication,&quot; Networks and Distributed Systems Laboratory, Computer Science Department, University of Southern California and IBM Los Angeles Scientific Center, pp 22-30."><meta name="citation_reference" content="Wai Sum Lai, &quot;Packet Forwarding,&quot; IEEE Communications Magazine, Jul. 12, 1988, pp. 8-17, vol. 26, No. 7."><meta name="citation_patent_number" content="US:6819670"><meta name="citation_patent_application_number" content="US:09/227,688"><link rel="canonical" href="http://www.google.com/patents/US6819670"/><meta property="og:url" content="http://www.google.com/patents/US6819670"/><meta name="title" content="Patent US6819670 - Data packet routing for mobile networks"/><meta name="description" content="To provide fast access times with very large key fields, an associative memory utilizes a location addressable memory and lookup table to generate from a key the address in memory storing an associated record. The lookup tables, stored in memory, are constructed with the aid of arithmetic data compression methods to create a near perfect hashing of the keys. For encoding into the lookup table, keys are divided into a string of symbols. Each valid and invalid symbol is assigned an index value, such that the sum of valid index values for symbols of a particular key is a unique value that is used as an address to the memory storing the record associated with that key, and the sum of keys containing invalid index values point to a location in memory containing similar data. Utilizing the lookup tables set and relational operations maybe carried out that provide a user with a maximum number of key records resulting from a sequence of intersection, union and mask operations."/><meta property="og:title" content="Patent US6819670 - Data packet routing for mobile networks"/><meta property="og:type" content="book"/><meta property="og:site_name" content="Google Books"/><meta property="og:image" content="http://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"/><link rel="image_src" href="http://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"/><script>(function(){try{var aa=function(a,b,c,d){d=d||{};d._sn=["cfg",b,c].join(".");window.gbar.logger.ml(a,d)};var g=window.gbar=window.gbar||{},l=window.gbar.i=window.gbar.i||{},m={},n;function _tvn(a,b){var c=parseInt(a,10);return isNaN(c)?b:c}function _tvf(a,b){var c=parseFloat(a);return isNaN(c)?b:c}function _tvv(a){return!!a}function p(a,b,c){(c||g)[a]=b}g.bv={n:_tvn("2",0),r:"",f:".67.",e:"0",m:_tvn("0",1)};
function q(a,b,c){var d="on"+b;if(a.addEventListener)a.addEventListener(b,c,!1);else if(a.attachEvent)a.attachEvent(d,c);else{var f=a[d];a[d]=function(){var a=f.apply(this,arguments),b=c.apply(this,arguments);return void 0==a?b:void 0==b?a:b&&a}}}var s=function(a){return function(){return g.bv.m==a}},ba=s(1),ca=s(2);p("sb",ba);p("kn",ca);l.a=_tvv;l.b=_tvf;l.c=_tvn;l.i=aa;var da=window.gbar.i.i;var t,u,v,w;function ea(a){v=a}function fa(a){var b;if(b=v&&window.encodeURIComponent)b=a.href,b=!b.match(/^http[s]?:\/\/accounts\.google\.[^/]*\/ClearSID/i)&&!b.match(/^http[s]?:\/\/[^/]*\/accounts\/ClearSID/i);if(b=b&&encodeURIComponent(v()))a.href=a.href.replace(/([?&]continue=)[^&]*/,"$1"+b)}function ga(a){window.gApplication&&(a.href=window.gApplication.getTabUrl(a.href))}
function ha(a){var b=document.forms[0].q,c=window.encodeURIComponent&&b&&b.value,b=b&&b.placeholder;c&&c!=b&&(a.href=a.href.replace(/([?&])q=[^&]*|$/,function(a,b){return(b||"&")+"q="+encodeURIComponent(c)}))}n=l.a("")?ga:ha;
function x(a,b,c,d,f,e){var h=document.getElementById(a);if(h){var k=h.style;k.left=d?"auto":b+"px";k.right=d?b+"px":"auto";k.top=c+"px";k.visibility=u?"hidden":"visible";f&&e?(k.width=f+"px",k.height=e+"px"):(x(t,b,c,d,h.offsetWidth,h.offsetHeight),u=u?"":a)}}
var y=[],ia=function(a,b){y.push(b)},ja=function(a){a=a||window.event;var b=a.target||a.srcElement;a.cancelBubble=!0;null==t&&(a=document.createElement(Array.every||window.createPopup?"iframe":"div"),a.frameBorder="0",t=a.id="gbs",a.src="javascript:''",b.parentNode.appendChild(a),q(document,"click",z));var c=b,b=0;"gb3"!=c.className&&(c=c.parentNode);a=c.getAttribute("aria-owns")||"gbi";var d=c.offsetWidth,f=20<c.offsetTop?46:24;document.getElementById("tphdr")&&(f-=3);var e=!1;do b+=c.offsetLeft||
0;while(c=c.offsetParent);var c=(document.documentElement.clientWidth||document.body.clientWidth)-b-d,h,d=document.body,k=document.defaultView;k&&k.getComputedStyle?(d=k.getComputedStyle(d,""))&&(h=d.direction):h=d.currentStyle?d.currentStyle.direction:d.style.direction;h="rtl"==h;if("gbi"==a){for(d=0;k=y[d++];)k();A(null,window.navExtra);h&&(b=c,e=!0)}else h||(b=c,e=!0);u!=a&&z();x(a,b,f,e)},z=function(){u&&x(u,0,0)},A=function(a,b){var c,d=document.getElementById("gbi"),f=a;f||(f=d.firstChild);
for(;b&&(c=b.pop());){var e=d,h=c,k=f;w||(w="gb2");e.insertBefore(h,k).className=w}},ka=function(a,b,c){if((b=document.getElementById(b))&&a){a.className="gb4";var d=document.createElement("span");d.appendChild(a);d.appendChild(document.createTextNode(" | "));d.id=c;b.appendChild(d)}},la=function(){return document.getElementById("gb_70")},ma=function(){return!!u};p("qs",n);p("setContinueCb",ea);p("pc",fa);p("tg",ja);p("close",z);p("addLink",ka);p("almm",A);p("si",la);p("adh",ia);p("op",ma);var B=function(){},C=function(){},F=function(a){var b=new Image,c=D;b.onerror=b.onload=b.onabort=function(){try{delete E[c]}catch(a){}};E[c]=b;b.src=a;D=c+1},E=[],D=0;p("logger",{il:C,ml:B,log:F});var G=window.gbar.logger;var H={},na={},I=[],oa=l.b("0.1",.1),pa=l.a("1",!0),qa=function(a,b){I.push([a,b])},ra=function(a,b){H[a]=b},sa=function(a){return a in H},J={},K=function(a,b){J[a]||(J[a]=[]);J[a].push(b)},ta=function(a){K("m",a)},L=function(a,b){var c=document.createElement("script");c.src=a;c.async=pa;Math.random()<oa&&(c.onerror=function(){c.onerror=null;B(Error("Bundle load failed: name="+(b||"UNK")+" url="+a))});(document.getElementById("xjsc")||document.getElementsByTagName("body")[0]||
document.getElementsByTagName("head")[0]).appendChild(c)},N=function(a){for(var b=0,c;(c=I[b])&&c[0]!=a;++b);!c||c[1].l||c[1].s||(c[1].s=!0,M(2,a),c[1].url&&L(c[1].url,a),c[1].libs&&m.d&&m.d(c[1].libs))},O=function(a){K("gc",a)},P=null,ua=function(a){P=a},M=function(a,b,c){if(P){a={t:a,b:b};if(c)for(var d in c)a[d]=c[d];try{P(a)}catch(f){}}};p("mdc",H);p("mdi",na);p("bnc",I);p("qGC",O);p("qm",ta);p("qd",J);p("lb",N);p("mcf",ra);p("bcf",qa);p("aq",K);p("mdd","");p("has",sa);
p("trh",ua);p("tev",M);var Q=l.b("0.1",.001),R=0;
function _mlToken(a,b){try{if(1>R){R++;var c,d=a,f=b||{},e=encodeURIComponent,h=["//www.google.com/gen_204?atyp=i&zx=",(new Date).getTime(),"&jexpid=",e("17483"),"&srcpg=",e("prop=22"),"&jsr=",Math.round(1/Q),"&ogev=",e("_KntU-ecEIPVsQSH8YCwCQ"),"&ogf=",g.bv.f,"&ogrp=",e("1"),"&ogv=",e("1407723702.0"),"&oggv="+e("es_plusone_gc_20140723.0_p0"),"&ogd=",e("com"),"&ogc=",e("NOR"),"&ogl=",e("en")];f._sn&&(f._sn="og."+
f._sn);for(var k in f)h.push("&"),h.push(e(k)),h.push("="),h.push(e(f[k]));h.push("&emsg=");h.push(e(d.name+":"+d.message));var r=h.join("");S(r)&&(r=r.substr(0,2E3));c=r;var Aa=window.gbar.logger._aem(a,c);F(Aa)}}catch(Na){}}var S=function(a){return 2E3<=a.length},va=function(a,b){return b};function T(a){B=a;p("_itl",S,G);p("_aem",va,G);p("ml",B,G);a={};H.er=a}l.a("")?T(function(a){throw a;}):l.a("1")&&Math.random()<Q&&T(_mlToken);I.push(["m",{url:"//ssl.gstatic.com/gb/js/scm_7385cc5883250b43a39405734c1bea59.js"}]);g.mcf("c",{});g.sg={c:""};if(l.a("1")){var wa=l.a("");I.push(["gc",{auto:wa,url:"//ssl.gstatic.com/gb/js/abc/gci_91f30755d6a6b787dcc2a4062e6e9824.js",libs:"googleapis.client:plusone:gapi.iframes"}]);var xa={version:"gci_91f30755d6a6b787dcc2a4062e6e9824.js",index:"",lang:"en"};H.gc=xa;var U=function(a){window.googleapis&&window.iframes?a&&a():(a&&O(a),N("gc"))};p("lGC",U);l.a("1")&&p("lPWF",U)};window.__PVT="";if(l.a("1")&&l.a("1")){var V=function(a){U(function(){K("pw",a);N("pw")})};p("lPW",V);I.push(["pw",{url:"//ssl.gstatic.com/gb/js/abc/pwm_45f73e4df07a0e388b0fa1f3d30e7280.js"}]);var W=[],ya=function(a){W[0]=a},za=function(a,b){var c=b||{};c._sn="pw";B(a,c)},Ba={signed:W,elog:za,base:"https://plusone.google.com/u/0",loadTime:(new Date).getTime()};H.pw=Ba;var X=function(a,b){for(var c=b.split("."),d=function(){var b=arguments;a(function(){for(var a=g,d=0,e=c.length-1;d<e;++d)a=a[c[d]];a[c[d]].apply(a,b)})},f=g,e=0,h=c.length-1;e<h;++e)f=
f[c[e]]=f[c[e]]||{};return f[c[e]]=d};X(V,"pw.clk");X(V,"pw.hvr");p("su",ya,g.pw)};function Ca(){function a(){for(var b;(b=e[h++])&&"m"!=b[0]&&!b[1].auto;);b&&(M(2,b[0]),b[1].url&&L(b[1].url,b[0]),b[1].libs&&m.d&&m.d(b[1].libs));h<e.length&&setTimeout(a,0)}function b(){0<f--?setTimeout(b,0):a()}var c=l.a("1"),d=l.a(""),f=3,e=I,h=0,k=window.gbarOnReady;if(k)try{k()}catch(r){da(r,"ml","or")}d?p("ldb",a):c?q(window,"load",b):b()}p("rdl",Ca);var Da={D:1,H:2,da:3,p:4,W:5,M:6,F:7,g:8,ha:9,U:10,L:11,T:12,S:13,N:14,Q:15,P:16,fa:17,w:18,O:19,ga:20,ea:21,u:22,G:23,ja:24,ka:25,ia:26,A:27,j:28,o:29,k:30,ca:31,Z:32,$:33,J:34,K:35,ba:36,aa:37,Y:38,B:39,R:40,v:41,X:42,V:43,h:48,C:49,I:500},Y=[1,2,3,4,5,6,9,10,11,13,14,28,29,30,34,35,37,38,39,40,41,42,43,48,49,500];var Z=l.b("0.001",1E-4),Ea=l.b("1",1),Fa=!1,Ga=!1;if(l.a("1")){var Ha=Math.random();Ha<=Z&&(Fa=!0);Ha<=Ea&&(Ga=!0)}var Ia=Da,$=null;function Ja(){var a=0,b=function(b,d){l.a(d)&&(a|=b)};b(1,"");b(2,"");b(4,"");b(8,"");return a}
function Ka(a,b){var c=Z,d=Fa,f;f=a;if(!$){$={};for(var e=0;e<Y.length;e++){var h=Y[e];$[h]=!0}}if(f=!!$[f])c=Ea,d=Ga;if(d){d=encodeURIComponent;g.rp?(f=g.rp(),f="-1"!=f?f:"1"):f="1";c=["//www.google.com/gen_204?atyp=i&zx=",(new Date).getTime(),"&oge=",a,"&ogex=",d("17483"),"&ogev=",d("_KntU-ecEIPVsQSH8YCwCQ"),"&ogf=",g.bv.f,"&ogp=",d("22"),"&ogrp=",d(f),"&ogsr=",Math.round(1/c),"&ogv=",d("1407723702.0"),"&oggv="+
d("es_plusone_gc_20140723.0_p0"),"&ogd=",d("com"),"&ogl=",d("en"),"&ogc=",d("NOR"),"&ogus=",Ja()];if(b){"ogw"in b&&(c.push("&ogw="+b.ogw),delete b.ogw);var k;f=b;e=[];for(k in f)0!=e.length&&e.push(","),e.push(La(k)),e.push("."),e.push(La(f[k]));k=e.join("");""!=k&&(c.push("&ogad="),c.push(d(k)))}F(c.join(""))}}function La(a){"number"==typeof a&&(a+="");return"string"==typeof a?a.replace(".","%2E").replace(",","%2C"):a}C=Ka;p("il",C,G);var Ma={};H.il=Ma;setTimeout(function(){C(Ia.g)},0);}catch(e){window.gbar&&gbar.logger&&gbar.logger.ml(e,{"_sn":"cfg.init"});}})();
(function(){try{var b=window.gbar.i.i;var c=window.gbar;var f=function(d){try{var a=document.getElementById("gbom");a&&d.appendChild(a.cloneNode(!0))}catch(e){b(e,"omas","aomc")}};c.aomc=f;}catch(e){window.gbar&&gbar.logger&&gbar.logger.ml(e,{"_sn":"cfg.init"});}})();
(function(){try{var a=window.gbar;a.mcf("pm",{p:""});}catch(e){window.gbar&&gbar.logger&&gbar.logger.ml(e,{"_sn":"cfg.init"});}})();
(function(){try{window.gbar.rdl();}catch(e){window.gbar&&gbar.logger&&gbar.logger.ml(e,{"_sn":"cfg.init"});}})();
if (window['_OC_timingAction']) {window['_OC_timingAction']('patents_refpage');}</script><style>#gbar,#guser{font-size:13px;padding-top:1px !important;}#gbar{float:left;height:22px}#guser{padding-bottom:7px !important;text-align:right}.gbh,.gbd{border-top:1px solid #c9d7f1;font-size:1px}.gbh{height:0;position:absolute;top:24px;width:100%}#gbs,.gbm{background:#fff;left:0;position:absolute;text-align:left;visibility:hidden;z-index:1000}.gbm{border:1px solid;border-color:#c9d7f1 #36c #36c #a2bae7;z-index:1001}.gb1{margin-right:.5em}.gb1,.gb3{zoom:1}.gb2{display:block;padding:.2em .5em}.gb2,.gb3{text-decoration:none !important;border-bottom:none}a.gb1,a.gb4{text-decoration:underline !important}a.gb1,a.gb2,a.gb3,a.gb4{color:#00c !important}.gbi .gb3,.gbi .gb2,.gbi .gb4{color:#dd8e27 !important}.gbf .gb3,.gbf .gb2,.gbf .gb4{color:#900 !important}a.gb2:hover{background:#36c;color:#fff !important}#gbar .gbz0l{color:#000 !important;cursor:default;font-weight:bold;text-decoration:none !important}
#gbar { padding:.3em .6em !important;}</style></head><body  topmargin="3" marginheight="3"><div id=gbar><nobr><a onclick=gbar.qs(this);gbar.logger.il(1,{t:1}); class=gb1 id=gb_1 href="https://www.google.com/search?sa=N&tab=tw">Search</a> <a onclick=gbar.qs(this);gbar.logger.il(1,{t:2}); class=gb1 id=gb_2 href="http://www.google.com/search?hl=en&tbm=isch&source=og&sa=N&tab=ti">Images</a> <a onclick=gbar.qs(this);gbar.logger.il(1,{t:8}); class=gb1 id=gb_8 href="http://maps.google.com/maps?hl=en&sa=N&tab=tl">Maps</a> <a onclick=gbar.qs(this);gbar.logger.il(1,{t:78}); class=gb1 id=gb_78 href="https://play.google.com/?hl=en&sa=N&tab=t8">Play</a> <a onclick=gbar.qs(this);gbar.logger.il(1,{t:36}); class=gb1 id=gb_36 href="http://www.youtube.com/results?sa=N&tab=t1">YouTube</a> <a onclick=gbar.logger.il(1,{t:5}); class=gb1 id=gb_5 href="http://news.google.com/nwshp?hl=en&tab=tn">News</a> <a onclick=gbar.logger.il(1,{t:23}); class=gb1 id=gb_23 href="https://mail.google.com/mail/?tab=tm">Gmail</a> <a onclick=gbar.logger.il(1,{t:25}); class=gb1 id=gb_25 href="https://drive.google.com/?tab=to">Drive</a> <a class=gb3 href="http://www.google.com/intl/en/options/" onclick="this.blur();gbar.tg(event);return !1" aria-haspopup=true><u>More</u> <small>&#9660;</small></a><div class=gbm id=gbi><a onclick=gbar.logger.il(1,{t:24}); class=gb2 id=gb_24 href="https://www.google.com/calendar?tab=tc">Calendar</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:51}); class=gb2 id=gb_51 href="http://translate.google.com/?hl=en&sa=N&tab=tT">Translate</a><a onclick=gbar.logger.il(1,{t:17}); class=gb2 id=gb_17 href="http://www.google.com/mobile/?hl=en&tab=tD">Mobile</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:10}); class=gb2 id=gb_10 href="http://www.google.com/search?hl=en&tbo=u&tbm=bks&source=og&sa=N&tab=tp">Books</a><a onclick=gbar.logger.il(1,{t:212}); class=gb2 id=gb_212 href="https://wallet.google.com/manage/?tab=ta">Wallet</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:6}); class=gb2 id=gb_6 href="http://www.google.com/search?hl=en&tbo=u&tbm=shop&source=og&sa=N&tab=tf">Shopping</a><a onclick=gbar.logger.il(1,{t:30}); class=gb2 id=gb_30 href="http://www.blogger.com/?tab=tj">Blogger</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:27}); class=gb2 id=gb_27 href="http://www.google.com/finance?sa=N&tab=te">Finance</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:31}); class=gb2 id=gb_31 href="https://plus.google.com/photos?sa=N&tab=tq">Photos</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:12}); class=gb2 id=gb_12 href="http://www.google.com/search?hl=en&tbo=u&tbm=vid&source=og&sa=N&tab=tv">Videos</a><div class=gb2><div class=gbd></div></div><a onclick=gbar.logger.il(1,{t:66}); href="http://www.google.com/intl/en/options/" class=gb2>Even more &raquo;</a></div></nobr></div><div id=guser width=100%><nobr><span id=gbn class=gbi></span><span id=gbf class=gbf></span><span id=gbe></span><a target=_top id=gb_70 href="https://www.google.com/accounts/Login?service=&continue=http://www.google.com/patents%3Fhl%3Den&hl=en" class=gb4>Sign in</a><div style="display: none"><div class=gbm id=gbd5 aria-owner=gbg5><div class=gbmc><ol id=gbom class=gbmcc></ol></div></div></div></nobr></div><div class=gbh style=left:0></div><div class=gbh style=right:0></div><div role="alert" style="position: absolute; left: 0; right: 0;"><a href="http://www.google.com/patents/us6819670?hl=en&amp;output=html_text" title="Screen reader users: click this link for accessible mode. Accessible mode has the same essential features but works better with your reader."><img border="0" src="http://www.google.com/images/cleardot.gif"alt="Screen reader users: click this link for accessible mode. Accessible mode has the same essential features but works better with your reader."></a></div><div id="guser"><nobr></nobr></div><div style="clear:both;"></div><div id="gb-top-search-box" class="gb-top-search-box-small gb-reset"><table><tr><td class="logo"><a href="http://www.google.com/patents" class="logo-link"><img class="logo-img" src="/intl/en/images/logos/google_logo_41.png" alt="Go to Google Books Home" height="41"/></a></td><td><form action="http://www.google.com/search" name="f" id="vheadf" method="get"><span id="hf"></span><input type="hidden" name="tbm" value="pts"/><input type="hidden" name="tbo" value="1"/><input type="hidden" name="hl" value="en"/><table><tr><td><div class="inputs"><table><tr><td><div class="text-input"><input type="text" name="q" id="vheadq" class="text" maxlength="2048" size="31" value="" title="Search Patents" accesskey="s" autocomplete="off"/><script>window._OC_autoDir &&window._OC_autoDir('vheadq', 'tia-vheadq');</script></div></td><td><div class="submit-input"><input name="btnG" class="submit" type="submit" value=""/></div></td></tr></table></div></td><td class="col-ext-links"><div class="ext-links"><a href="http://www.google.com/advanced_patent_search">&lt;nobr&gt;Advanced Patent Search&lt;/nobr&gt;</a></div></td></tr></table></form></td></tr></table></div><div class="kd-appbar"><h2 class="kd-appname"><a href="/patents">Patents</a></h2><div class="kd-buttonbar left" id="left-toolbar-buttons"><a id="appbar-write-review-link" href=""></a><a id="appbar-view-print-sample-link" href=""></a><a id="appbar-view-ebook-sample-link" href=""></a><a id="appbar-patents-prior-art-finder-link" href="https://www.google.com/patents/related/US6819670"></a><a id="appbar-patents-discuss-this-link" href="http://www.google.com/url?id=8ohpBAABERAJ&amp;q=http://patents.stackexchange.com/redirect/google-patents%3Fpatent%3DUS6819670&amp;usg=AFQjCNFHgFgNKBEipLqjVt-Vasclt3zoAA" data-is-grant="true"></a><a id="appbar-read-patent-link" href="//docs.google.com/viewer?url=patentimages.storage.googleapis.com/pdfs/US6819670.pdf"></a><a id="appbar-download-pdf-link" href="//patentimages.storage.googleapis.com/pdfs/US6819670.pdf"></a></div><div class="kd-buttonbar right" id="right-toolbar-buttons"></div></div><div id="books-microdata" itemscope=""itemtype="http://schema.org/Book"itemid="http://www.google.com/patents/US6819670" style="display:none"><span itemprop="description">To provide fast access times with very large key fields, an associative memory utilizes a location addressable memory and lookup table to generate from a key the address in memory storing an associated record. The lookup tables, stored in memory, are constructed with the aid of arithmetic data compression...</span><span itemprop="url">http://www.google.com/patents/US6819670?utm_source=gb-gplus-share</span><span class="main-title" itemprop="name">Patent US6819670 - Data packet routing for mobile networks</span><img itemprop="image" src="http://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"alt="Patent US6819670 - Data packet routing for mobile networks" title="Patent US6819670 - Data packet routing for mobile networks"></div><div style="display: none"><ol id="ofe-gear-menu-contents" class="gbmcc"><li class="gbe gbmtc"><a class="gbmt goog-menuitem-content" id="" href="http://www.google.com/advanced_patent_search">Advanced Patent Search</a></li></ol></div><table id="viewport_table" cellpadding="0" style="clear:both" cellspacing="0"><tr><td id="viewport_td"><div class=vertical_module_list_row><div id=intl_patents class=about_content><div id=intl_patents_v><table class="patent-bibdata"><tr><td class="patent-bibdata-heading">Publication number</td><td class="single-patent-bibdata">US6819670 B1</td></tr><tr><td class="patent-bibdata-heading">Publication type</td><td class="single-patent-bibdata">Grant</td></tr><tr><td class="patent-bibdata-heading">Application number</td><td class="single-patent-bibdata">US 09/227,688</td></tr><tr><td class="patent-bibdata-heading">Publication date</td><td class="single-patent-bibdata">Nov 16, 2004</td></tr><tr><td class="patent-bibdata-heading">Filing date</td><td class="single-patent-bibdata">Jan 8, 1999</td></tr><tr><td class="patent-bibdata-heading">Priority date<span class="patent-tooltip-anchor patent-question-icon"data-tooltip-text="The priority date is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the date listed."></span></td><td class="single-patent-bibdata">Jun 16, 1989</td></tr><tr><td class="patent-bibdata-heading">Fee status<span class="patent-tooltip-anchor patent-question-icon"data-tooltip-text="The fee status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status or dates listed."></span></td><td class="single-patent-bibdata">Lapsed</td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">Also published as</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="/patents/US5860136">US5860136</a>, </span><span class="patent-bibdata-value"><a href="/patents/US7145906">US7145906</a>, </span><span class="patent-bibdata-value"><a href="/patents/US20050063382">US20050063382</a></span></span></td></tr><tr class="patent-bibdata-list-row alternate-patent-number"><td class="patent-bibdata-heading">Publication number</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value">09227688, </span><span class="patent-bibdata-value">227688, </span><span class="patent-bibdata-value">US 6819670 B1, </span><span class="patent-bibdata-value">US 6819670B1, </span><span class="patent-bibdata-value">US-B1-6819670, </span><span class="patent-bibdata-value">US6819670 B1, </span><span class="patent-bibdata-value">US6819670B1</span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">Inventors</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="http://www.google.com/search?tbo=p&tbm=pts&hl=en&q=ininventor:%22Peter+R.+Fenner%22">Peter R. Fenner</a></span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">Original Assignee</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="http://www.google.com/search?tbo=p&tbm=pts&hl=en&q=inassignee:%22Fenner+Investments,+Ltd.%22">Fenner Investments, Ltd.</a></span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">Export Citation</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="/patents/US6819670.bibtex">BiBTeX</a>, </span><span class="patent-bibdata-value"><a href="/patents/US6819670.enw">EndNote</a>, </span><span class="patent-bibdata-value"><a href="/patents/US6819670.ris">RefMan</a></span></span></td></tr><tr class="patent-internal-links"><td colspan=2><span class="patent-bibdata-value"><a href="#backward-citations">Patent Citations</a> (34),</span> <span class="patent-bibdata-value"><a href="#npl-citations">Non-Patent Citations</a> (12),</span> <span class="patent-bibdata-value"><a href="#forward-citations">Referenced by</a> (24),</span> <span class="patent-bibdata-value"><a href="#classifications">Classifications</a> (27),</span> <span class="patent-bibdata-value"><a href="#legal-events">Legal Events</a> (9)</span> </td></tr><tr><td colspan=2 class="patent-bibdata-external-link-spacer-top"></td></tr><tr class="patent-bibdata-external-link-spacer-bottom"></tr><tr><td colspan=2><span class="patent-bibdata-heading">External Links:&nbsp;</span><span><span class="patent-bibdata-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://patft.uspto.gov/netacgi/nph-Parser%3FSect2%3DPTO1%26Sect2%3DHITOFF%26p%3D1%26u%3D/netahtml/PTO/search-bool.html%26r%3D1%26f%3DG%26l%3D50%26d%3DPALL%26RefSrch%3Dyes%26Query%3DPN/6819670&usg=AFQjCNGfu1W-0tCO6dJ19KQLw0zMCij-wA">USPTO</a>, </span><span class="patent-bibdata-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://assignments.uspto.gov/assignments/q%3Fdb%3Dpat%26pat%3D6819670&usg=AFQjCNH4iN5u-oPW1hgu_y5JBo7EFiz3aw">USPTO Assignment</a>, </span><span class="patent-bibdata-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://worldwide.espacenet.com/publicationDetails/biblio%3FCC%3DUS%26NR%3D6819670B1%26KC%3DB1%26FT%3DD&usg=AFQjCNEC6Fq9YiPcrrqZmAMYJyKgdU8TIg">Espacenet</a></span></span></td></tr><tr class="patent-bibdata-group-spacer"></tr></table><div class="number-and-title"><span class="patent-title"><invention-title mxw-id="PT55341623" lang="EN" load-source="patent-office">Data packet routing for mobile networks</invention-title></span><br><span class="patent-number">US 6819670 B1</span></div><div class="patent-section patent-abstract-section"><div class="patent-section-header"><span class="patent-section-title">Abstract</span></div><div class="patent-text"><abstract mxw-id="PA50748773" lang="EN" load-source="patent-office"> <div class="abstract">To provide fast access times with very large key fields, an associative memory utilizes a location addressable memory and lookup table to generate from a key the address in memory storing an associated record. The lookup tables, stored in memory, are constructed with the aid of arithmetic data compression methods to create a near perfect hashing of the keys. For encoding into the lookup table, keys are divided into a string of symbols. Each valid and invalid symbol is assigned an index value, such that the sum of valid index values for symbols of a particular key is a unique value that is used as an address to the memory storing the record associated with that key, and the sum of keys containing invalid index values point to a location in memory containing similar data. Utilizing the lookup tables set and relational operations maybe carried out that provide a user with a maximum number of key records resulting from a sequence of intersection, union and mask operations.</div>
  </abstract></div></div><div class="patent-section patent-drawings-section"><div class="patent-section-header"><span class="patent-section-title">Images<span class="patent-section-count">(33)</span></span></div><div class="patent-drawings-body"><div class="patent-drawings-carousel"><div class="drawings"><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00000.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00000.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00001.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00001.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00002.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00002.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00003.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00003.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00004.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00004.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00005.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00005.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00006.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00006.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00007.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00007.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00008.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00008.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00009.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00009.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00010.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00010.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00011.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00011.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00012.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00012.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00013.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00013.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00014.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00014.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00015.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00015.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00016.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00016.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00017.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00017.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00018.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00018.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00019.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00019.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00020.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00020.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00021.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00021.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00022.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00022.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00023.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00023.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00024.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00024.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00025.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00025.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00026.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00026.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00027.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00027.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00028.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00028.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00029.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00029.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00030.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00030.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00031.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00031.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/US6819670B1/US06819670-20041116-D00032.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/US6819670B1/US06819670-20041116-D00032.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div></div></div><div class="patent-drawings-control patent-drawings-prev"><img class="patent-drawings-button-img" alt="Previous page"src="/googlebooks/images/kennedy/page_left.png"width="21" height="21" /></div><div class="patent-drawings-control patent-drawings-next"><img class="patent-drawings-button-img" alt="Next page"src="/googlebooks/images/kennedy/page_right.png"width="21" height="21" /></div></div></div><div class="patent-post-drawings"></div><div class="patent-section patent-claims-section"><div class="patent-section-header"><span class="patent-section-title">Claims<span class="patent-section-count">(17)</span></span></div><div class="patent-text"><div mxw-id="PCLM8763038" lang="EN" load-source="patent-office" class="claims">
    <claim-statement>What is claimed is: </claim-statement> <div class="claim"> <div num="1" id="US-6819670-B1-CLM-00001" class="claim">
      <div class="claim-text">1. In a communications node of a system, a method for routing data packets comprising:</div>
      <div class="claim-text">receiving a first data packet, the data packet including a a first internet protocol (IP) address for identifying a mobile source of the data packet independently of the physical media over which the mobile source is communicating; </div>
      <div class="claim-text">storing the first IP address and associating it with a physical media path from which the first data packet was received; </div>
      <div class="claim-text">receiving a second data packet, the second data packet including the first IP address for identifying the mobile source as a destination of the second data packet and a second IP address for identifying the sender of the data packet; </div>
      <div class="claim-text">looking up the physical media path associated with the first IP address; and </div>
      <div class="claim-text">forwarding the second data packet based on the stored physical media path. </div>
    </div>
    </div> <div class="claim-dependent"> <div num="2" id="US-6819670-B1-CLM-00002" class="claim">
      <div class="claim-text">2. The method of <claim-ref idref="US-6819670-B1-CLM-00001">claim 1</claim-ref> wherein first IP address uniquely identifies the mobile source for routing data packets within public; interconnected networks.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="3" id="US-6819670-B1-CLM-00003" class="claim">
      <div class="claim-text">3. The method of <claim-ref idref="US-6819670-B1-CLM-00001">claim 1</claim-ref>, further comprising, looking up filtering information for second IP address; and filtering the data packet based on the filtering information.</div>
    </div>
    </div> <div class="claim"> <div num="4" id="US-6819670-B1-CLM-00004" class="claim">
      <div class="claim-text">4. In a communications node of a system of interconnected networks, a method for routing data packets comprising:</div>
      <div class="claim-text">storing a unique internet protocol (IP) address for identifying a mobile receiver of a data packet anywhere within the interconnected networks, independently of the physical media over which the mobile receiver is communicating; </div>
      <div class="claim-text">associating the unique IP address with a physical media path; </div>
      <div class="claim-text">receiving a data packet having a source IP address identifying a sender of the data packet and the mobile receiver's IP address identifying the mobile receiver as a destination for the data packet; </div>
      <div class="claim-text">looking up the physical media path along which to forward the data packet using the entire mobile receiver's IP address contained in the data packet; and </div>
      <div class="claim-text">forwarding the data packet according to the physical media path. </div>
    </div>
    </div> <div class="claim-dependent"> <div num="5" id="US-6819670-B1-CLM-00005" class="claim">
      <div class="claim-text">5. The method of <claim-ref idref="US-6819670-B1-CLM-00004">claim 4</claim-ref>, further comprising, looking up filtering information for source IP address; and filtering the data packet based on the filtering information.</div>
    </div>
    </div> <div class="claim"> <div num="6" id="US-6819670-B1-CLM-00006" class="claim">
      <div class="claim-text">6. A communications node for routing data packets, each such data packet including a first internet protocol (IP) address for uniquely identifying a mobile source of each such data packet independently of the physical media over which the mobile source is communicating within the interconnected networks the communications node including a packet routing device for routing the data packets and a data structure stored in a memory for associating the first IP address of a first data packet sent by a mobile source with a physical media path identifier identifying the physical media path from which the first data packet was received; wherein, when the communications node receives a second data packet that includes the first IP address as identifying the mobile source as a destination of the second data packet, and a second IP address for identifying a source of the second data packet, the packet routing device looks up in the data structure the physical media path identifier associated with the first IP address and forwards the second data packet to the physical media path identified by the physical media path identifier.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="7" id="US-6819670-B1-CLM-00007" class="claim">
      <div class="claim-text">7. The communication system of <claim-ref idref="US-6819670-B1-CLM-00006">claim 6</claim-ref> wherein the first IP address is a globally unique identifier.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="8" id="US-6819670-B1-CLM-00008" class="claim">
      <div class="claim-text">8. The communications node of <claim-ref idref="US-6819670-B1-CLM-00006">claim 6</claim-ref>, wherein the communications node stores source IP address filtering information and includes circuitry for filtering the data packet in response to the source filtering information stored for the second IP address.</div>
    </div>
    </div> <div class="claim"> <div num="9" id="US-6819670-B1-CLM-00009" class="claim">
      <div class="claim-text">9. A communications node for routing data packets, each such data packet including a source internet protocol (IP) address for uniquely identifying a source of each such data packet independently of the physical media over which the source is communicating with the interconnected networks, and a destination IP address for identifying a destination of the data packet, the communications node including a packet routing device and a data structure stored in a memory for storing the source IP address of a first data packet sent by a mobile source and associating it with a physical media path identifier to which the first data packet was forwarded by the communications node; wherein, when the communications node receives a second data packet, which includes the first source IP address of the first data packet as identifying the source of the second data packet, the packet routing device looks up in the data structure the physical media path identifier of the node associated with the the source IP address and forwards the second data packet.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="10" id="US-6819670-B1-CLM-00010" class="claim">
      <div class="claim-text">10. The communication system of <claim-ref idref="US-6819670-B1-CLM-00009">claim 9</claim-ref> wherein the first IP address is a globally unique identifier.</div>
    </div>
    </div> <div class="claim"> <div num="11" id="US-6819670-B1-CLM-00011" class="claim">
      <div class="claim-text">11. A communications node for connecting a plurality of networks comprising:</div>
      <div class="claim-text">a packet routing device for routing data packets, each of the data packets containing a source IP address identifying a source of the data packet and a destination IP address identifying a destination of the packet, and </div>
      <div class="claim-text">a data structure for storing a first internet protocol (IP) address that uniquely identifies a host within the plurality of networks independently of physical media on which the host is communicating, the data structure associating the first IP address with routing information for forwarding data packets containing the first IP address as the destination IP address; </div>
      <div class="claim-text">wherein the packet routing device includes a circuit for looking up routing information in the data structure for forwarding a data packet to the host using the entire first IP address contained in the data packet. </div>
    </div>
    </div> <div class="claim-dependent"> <div num="12" id="US-6819670-B1-CLM-00012" class="claim">
      <div class="claim-text">12. The communications network of <claim-ref idref="US-6819670-B1-CLM-00011">claim 11</claim-ref>, wherein the circuit for looking up includes a circuit for determining an index into the table.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="13" id="US-6819670-B1-CLM-00013" class="claim">
      <div class="claim-text">13. The communications node of <claim-ref idref="US-6819670-B1-CLM-00011">claim 11</claim-ref>, wherein the communications node stores source filtering information, and includes circuitry for looking up source filtering information using the source IP address of each data packet and filtering the data packet.</div>
    </div>
    </div> <div class="claim"> <div num="14" id="US-6819670-B1-CLM-00014" class="claim">
      <div class="claim-text">14. A communication system comprising a message handling node for routing a data packet between two or more networks, the data packet destined for a mobile receiver having an internet protocol (IP) address for identifying the mobile receiver to each of the two or more networks independently of the physical media path over which the mobile receive is communicating; the data packet including a source IP address for identifying a sender of the data packet and the mobile receiver's IP address as a destination IP address; the message handling node storing a data structure associating routing information for the IP address of the mobile receiver and routing the data packet based on the routing information for the mobile receiver's IP address.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="15" id="US-6819670-B1-CLM-00015" class="claim">
      <div class="claim-text">15. The communication system of <claim-ref idref="US-6819670-B1-CLM-00014">claim 14</claim-ref>, wherein the at least one messaging handling node routes the data packet based on the entire IP address of the mobile receiver.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="16" id="US-6819670-B1-CLM-00016" class="claim">
      <div class="claim-text">16. The communication system of <claim-ref idref="US-6819670-B1-CLM-00014">claim 14</claim-ref> wherein the IP address of the mobile receiver is a globally unique IP address.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="17" id="US-6819670-B1-CLM-00017" class="claim">
      <div class="claim-text">17. The communication system of <claim-ref idref="US-6819670-B1-CLM-00014">claim 14</claim-ref>, wherein the message handling node includes storage of source IP address filtering information and circuitry for filtering the data packet in response to the source filtering information stored for the source IP address of the data packet.</div>
    </div>
  </div> </div></div></div><div class="patent-section patent-description-section"><div class="patent-section-header"><span class="patent-section-title">Description</span></div><div class="patent-text"><div mxw-id="PDES54333271" lang="EN" load-source="patent-office" class="description">
    <heading>RELATED APPLICATION</heading> <p>This application is a continuation of U.S. application Ser. No. 08/174,361, filed Dec. 28, 1993 now U.S. Pat. No. 5,860,136, which is a continuation-in-part of U.S. application Ser. No 07/952,988, filed on Sep. 29, 1992, now U.S. Pat. No. 5,490,258, which is a continuation-in-part of U.S. application Ser. No. 07/737,147, filed Jul. 29, 1991, now abandoned, which is a continuation-in-part of U.S. application Ser. No. 07/367,012, filed Jun. 16, 1989 now U.S. Pat. No. 5,095,480.</p>
    <heading>THE FIELD OF THE INVENTION</heading> <p>The present invention relates to associative memory systems, and more particularly to associative memory systems for handling large key set and spaces.</p>
    <heading>BACKGROUND OF THE INVENTION</heading> <p>Data communication between computers has become a standard part of worldwide networks in many areas of endeavors. These individual networks gather data about diverse subjects and exchange information of common interest among various media groups. Most of these networks are independent communication entities that are established to serve the needs of a particular group. Some use high speed connections while others use slow speed networks. Some use one type of protocol while others use a different type of protocol. Other well-known differences between networks also exist. There has been considerable effort expended in an attempt to make it possible to interconnect disparate physical networks and make them function as a coordinated unit.</p>
    <p>Whether they provide connections between one computer and another or between terminals and computers, communication networks are divided basically into circuit-switched or packet-switched types. Circuit-switched networks operate by forming a dedicated connection between two points. Such a dedicated circuit could be represented by a telephone connected through a circuit from the originating phone to a local switching office, across trunk lines to a remote switching office and finally to the destination telephone. When that circuit is complete, no other communications can travel over the wires that form the circuit. The advantage of such circuit lies in the fact that once it is established, no other network activity will decrease the capacity of the circuit. The disadvantage is that concurrent communication cannot take place on the line or circuit.</p>
    <p>Packet-switched networks take an entirely different approach. In such system, traffic on the network is divided into small segments of information called packets that are multiplexed on high capacity intermachine connections. Each packet carries identification that enables other units on the network to know whether they are to receive the data or are to transmit it to another destination. The chief advantage of packet-switching is that multiple communications among information sources such as computers can proceed concurrently with connections between machines being shared by all machines that are communicating. The disadvantage is that as activity increases, a given pair of communicating devices can use less of the network capacity.</p>
    <p>A new technology has been developed that is called Internet and it accommodates information or communication networks having multiple, diverse underlying hardware technologies, or physical media protocols, by adding both physical connections and a new set of conventions. One of the problems with the use of Internet is that addresses refer to connections and not to the device itself that is sending the information. Thus, if a communication source, such as an aircraft for example, moves from one communication network to another, its Internet address must change. Specifically, if an aircraft is transmitting a particular location address code in one communication network in the Internet system and it moves to another, its Internet address must change. It is similar to a traveler who has a personal computer operating with a first communication network. If the computer is taken on a trip and connected into the information system after reaching the new destination, a new location address for the computer must be obtained for the new destination. It is also similar to moving a telephone from one location to another. A new telephone number must be assigned to the telephone at the new location. The telephone cannot be reached at the new location with the old number. Further, when routing a signal from one station to another through a plurality of nodes forming multipath connections, the message format contains a destination location address that is used to make the routing decisions. When the system has multiple addresses, the route taken by the packets traveling to a particular station address depends upon the location code embedded in the station address.</p>
    <p>Thus, two problems occur in such message communication networks. The first is the requirement to change the address code of the communication source when it is at different locations in the network and the second is routing the message to the receiver if the address has changed. It can be seen, then, that with the presently existing system, if host A transmits a message to host B with a specific location code, by the time the message arrives at that location, host B may have moved to a new information processing network and changed its location code to conform to the new system and thus could not receive the message transmitted by host A. Host A must know that host B has entered the new information processing system and then must change the format of the new location address in order to contact host B.</p>
    <p>The present system overcomes the disadvantages of the prior art by simply assigning a fixed, unique and unchanging identification code to both host A and host B. As host B enters into a new network access system, it transmits its identification code to the nearest node and all of the nodes interconnecting all of the disparate networks each store, with the unique identification code of host B, the address of those nodes which can communicate with host B so that a path can be completed through the nodes between host A and host B.</p>
    <p>In the prior art, hierarchical logical routing is used to address highly mobile end-systems (computers on ships and aircraft, etc.) that are simultaneously connected to multiple communication paths and employ multicast message traffic. Hierarchical routing schemes have great difficulty solving this combined set of problems and a new approach must be used to overcome the difficulties in using hierarchical routing to meet the user's diverse requirements.</p>
    <p>Further, in the prior art, a logical network address of larger than 32 bits was too large to be used as a directory access method to locate a receiver at a location address specified in the message format. Specialized hierarchical address structures which embed network location information have been employed to reduce the size of the access index to the routing table and also to reduce the size of the routing table. This approach couples the address structure to the Internet routing software design.</p>
    <p>There are various “hidden assumptions” of hierarchical addressing. These “hidden assumptions” are (1) the processing load of the router CPU increases as the size of the routing table increases and (2) computer memory is a scarce and expensive resource. The present invention overcomes the first of these problems while computer memory technology has addressed the second problem by making very large memories cost effective.</p>
    <p>Traditional approaches for designing a network address structure have either been intimately entwined in the design of efficient routing look-up tables or assigned by a central authority such as ARPANET. Neither of these approaches gives much if any thought to the needs, desires or ease of use of the group which must make operational use of the system. In an age of fourth generation database languages and high level compilers, network addresses are basically hand-coded in low level language. Addresses and address structures are difficult to change as a mobile end-unit moves from one communication network to another. Experts are often required to ensure that operational equipment is properly integrated into the system. ISO (International Standards Organization) addressing provides a basis for a much better approach but the overall design and administration of a network addressing structure must be elevated to an easily supported, user friendly, distributed architecture to effectively support the user's long-term needs.</p>
    <p>Traditional directory access methods, whether for Internet routing, databases or compiler symbol tables, fall into three basic categories:</p>
    <p>(1) Sorted Tables.</p>
    <p>The keys are sorted by some rule which allows a particular search strategy (e.g., binary search) to locate the key. Associated with the key location is a pointer to the data. (2) Tree Structures.</p>
    <p>Parts of the key field are used to traverse a tree data structure to a leaf node which holds the data or a pointer to the data.</p>
    <p>(3) Hashing.</p>
    <p>Some arithmetic function is applied to the key which compresses the key field into a chosen integer range which is the initial directory size. This integer is the index into the directory which usually contains a pointer to the data.</p>
    <p>Each of these techniques has advantages and disadvantages when applied to the Internet routing table access design. Sorted tables provide the potentially most compact storage utilization at the cost of having access computations which grow with the number of addresses (keys) active in the system. Computations for sorted tables grow proportional to the log of the number of keys plus one. Using sorted tables, the router processing will slow down as the number of active addresses increases. But the desirable result is to make computation independent of the number of active addresses. It has been theorized, without providing a method, that a scheme to access sorted tables could exist which always allows access in two probes. To date, no methods have been proposed which approaches this theoretical result.</p>
    <p>Tree data structures have been widely employed for directories, particularly for file systems, such as the UNIX file system where larger amounts of auxiliary disc storage is being managed. Trees offer access times that are proportional to the length of the address (key). Trees trade off memory space for processing load. More branches at each level decreases the processing but uses much more memory. For example, a binary tree uses two locations at each level for each bit in the address field for which there is an active address. The binary tree processing of an eight bit octet requires eight memory accesses as well as unpacking the bits from the octet. On the other hand, processing a 256 way tree takes one memory access using the address octet as an index at each level. A 256 way tree requires 256 locations at the next level for every different octet active (a valid value) at the current level. An address of six octets with ten valid octet values in each octet position would require 256×10<sup>6 </sup>(256 million) locations, rapidly reaching an unrealizable size on current computer equipment. With current realizable computer memory sizes, pure tree structures do not appear to offer a viable structure for real time, address independent directory access method.</p>
    <p>Hashing has often been used over the last several decades to create directories where fast access is desired. One system uses a multi-level hashing scheme as the file system directory structure. The Total database system is based on hashed key access. Many language compilers use hash tables to store symbols. Hash table schemes have good average access costs—often a single access, but can degrade drastically when the table becomes too full or the hashing function does not perform a good job of evenly distributing the keys across the table. Some techniques called “linear hashing” and “dynamic hashing” have provided the method of expanding the hash table when a particular bucket becomes too full instead of using the traditional linked list overflow methods. These techniques generally require about 40% more space than the number of active addresses (keys) to achieve single access speed without employing overflow methods.</p>
    <p>All general hashing techniques use a variation of several common randomizing functions (such as dividing the key by a prime number and using the remainder) to “compress” the key field into a much smaller integer index into the hash table. Hashing functions have traditionally been viewed as one-way, randomized mapping of the key set into the hash space. The index computed by the hashing function could not be used to reconstruct the key. If for a particular hash function there exists a reciprocal function which maps the index to the unique key which generated the index, then the compressed keys could be stored in the directory.</p>
    <p>The present invention overcomes the disadvantages of the prior art by considering a flat, as opposed to hierarchical, logical routing address space with unique identifiers assigned to each transmitter and receiver to vastly simplify the modern communication problems of addressing highly mobile end-systems which are simultaneously connected to multiple communication paths and employ multicast message traffic.</p>
    <p>Further, the present invention employs a reversible arithmetic code compression technique to reduce the logical network address of up to 128 bits to a unique integer value which preserves any hierarchical ordering of the network address.</p>
    <p>Also, the present invention employs dynamic hashing and memory allocation techniques to automatically adjust the size of the routing table directory and routing records to accommodate the number of end-system addresses currently active in the communication system. These techniques provide a selection of approaches to allow graceful degradation of the routing efficiency when the memory available for routing tables is full.</p>
    <p>Finally, the system improves over the prior art by using a message format that is structure independent of the location of the destination of the message receiver.</p>
    <p>Arithmetic coding, when applied to addresses as known length keys, provides several advantages for table look-up when the addresses are known or can be learned in advance as they are in communications applications. The proposed arithmetic coding routing table design provides direct support for mobile, multi-homed, shared network end-systems employing multicast and unicast messaging while minimizing the effects of the “hidden assumptions” that have lead to reducing the routing table size by embracing hierarchical routing schemes.</p>
    <p>First, the identification encoding parameter tables are easily constructed by counting the occurrence of a particular symbol value and the accumulative distribution over all octet occurrences. That is, the tables are scaled to the statistical occurrence of each octet value. When a “bucket” overflows, dynamic hashing approaches can be used to expand the directory or parameter tables.</p>
    <p>Secondly, arithmetic coding can be constructed to operate on each symbol position in the address field as it arrives, allowing processing to begin as soon as the first address symbol arrives.</p>
    <p>Thirdly, arithmetic coding preserves the hierarchical (left to right precedence) of the ISO addresses being encoded. This is desirable if an Internet router only has knowledge of the network address but the Internet header carries the full destination address of a succeeding system node.</p>
    <p>Finally, a constant known set of computations is required for each symbol of the address field independent of the number of address symbols or the number of active Internet addresses.</p>
    <p>These features make the arithmetic coding used herein an ideal candidate for the routing table directory structure that is independent of a location address in a router, gate way or end-system.</p>
    <p>The present invention provides a very fast, automatically expandable, source filtered Internet routing scheme totally independent of the internal logical or physical structure of the network addresses in the message format that it is routing. Addresses are just unique identification numbers represented by a string of symbols of known length. Each Internet router learns the location of these numbers within the network from the Internet protocol traffic, from the source addresses of the packets it receives, and from a network management protocol.</p>
    <p>Address independent routing tables provides the following direct benefits:</p>
    <p>They provide a very fast routing table access scheme that is capable of supporting fast packet switch designs for very high speed media such as FDDI (i.e., routers which begin the outbound transmission of the packet as soon as possible after receiving the Internet header and before the whole packet has been received).</p>
    <p>They allow source address filtering for efficient multicast operation and security partitioning of the network.</p>
    <p>They allow independent automatic generation of network addresses from a user name space by a network name service. This facilitates using the same Internet software in disconnected networks with different addressing authorities and different address structures.</p>
    <p>They allow for orderly expansion, restructuring and redesign of the user name space without changing the Internet code or table structure.</p>
    <p>They reduce initial system procurement and logistic support costs because no special coding is needed for different networks.</p>
    <p>They reduce life cycle system costs because the Internet routers automatically adapt to network changes and they can be expanded without routing table modification.</p>
    <p>The present invention combines arithmetic coding with dynamic hashing to provide a very high speed method and system for detecting the 48 bit physical addresses in a Media Access Controller (MAC). The present system guarantees the acceptance or rejection of a frame. This technique always performs address detection functions within the transmission time of the address field plus a small fixed number of octet clocks depending on the logic implementation chosen. Specifically, the present system provides the following features: (1) variable length addresses with no known internal structure and processed with a number of memory accesses and a processing time proportional to the number of octets in the address field; (2) the size of the routing tables is directly proportional to the number of active addresses known to the router and within the practical limits of currently available microprocessing systems; (3) and the computational operations required to access the routing table for any address is linearly proportional to the length of the address field and these computations are reasonably performed by currently available microprocessor systems.</p>
    <heading>SUMMARY OF THE INVENTION</heading> <p>Thus the present invention relates to a system for routing a message between a source and a destination and which utilizes a message format that is structure-independent of the location of the message destination, said system comprising at least a first signal transceiver device having only a first fixed unique identification code wherever the transceiver device may be located; at least a second signal transceiver device for communicating with the first transceiver device and having only a second fixed unique identification code wherever the second transceiver device may be located; and routing nodes for coupling a transmitted signal from the first transceiver device to the second transceiver device at an unknown physical location within the system using a routing message format containing only the first and second transceiver fixed unique identification codes and addresses of the routing nodes with a message format that is structure-independent of any transceiver location code.</p>
    <p>Another aspect of the invention is an apparatus and method for implementing a routing table directory to provide for fast access times to look up routing information. This apparatus is an application of a novel associative memory utilizing arithmetic coding to associate a key presented to the memory with a record stored in the memory, but has a very-wide range of application in many different types of data processing systems. The associative memory includes an index table stored in memory and a record memory for storing the records of data. The index table is constructed such that each symbol of a key, a key being divided into a string of symbols and each symbol being defined by its position within the key and its value, addresses an index value in the index table memory. These index values are assigned such that the sum of index values for a given key is a unique value that is used to address the record memory. Several methods and apparatus are disclosed the permit random assignment of index values to new keys as they are presented, as well as for keys that are presented in sorted order for addition to the memory.</p>
    <p>Another aspect of the invention provides a method and apparatus for utilizing use-count tables created by the arithmetic coding process to determine the maximum number of key sets resulting from the set operations union and intersection, used to combine two or more different key sets. The intersection of the key for two or more relational database tables is essentially the relational join operations. This method can perform the relational join operations in a much faster and efficient method than presently utilized joined operations.</p>
    <heading>BRIEF DESCRIPTION OF THE DRAWINGS</heading> <p>The present invention will be more fully understood in connection with the accompanying drawings in which:</p>
    <p>FIG. 1 is a general diagrammatic representation of an Internet communication system that, as used in the prior art, uses information handling nodes and network addresses for each host that must be changed as the host moves from one communication network to another thereby requiring a complex and cumbersome system to enable data communication from a message transmitting host to a system receiving host; when modified by the present invention, the system of FIG. 1 enables a message routing system using a message format having an internal logical or physical structure that is totally independent of the message receiving host location address;</p>
    <p>FIG. 2 is a schematic representation of the circuitry in an individual system node using parallel processing to detect the address of the next node or nodes in the system that are to receive a packet of information;</p>
    <p>FIG. 3 is a schematic representation of an alternate circuit using serial processing at any particular node in the system to determine the address of any other node or nodes that are to receive the data packet; and</p>
    <p>FIG. 4 is a diagrammatic representation of the circuitry for enabling the message format used by the routing system to be totally independent of the internal logical or physical structure of the address of the receiving host to whom the message format is being routed and further illustrates the manner in which a destination address or source address can be compressed to provide a usable index for accessing the address directory.</p>
    <p>FIG. 5 is a schematic representation of components of an associative memory module.</p>
    <p>FIG. 6 is schematic representation of a circuit for learned key logic for the associative memory of FIG. <b>5</b>.</p>
    <p>FIG. 7 is a schematic representation of a circuit implementing symbol use count logic and delete key logic for the learned key logic circuit of FIG. <b>6</b>.</p>
    <p>FIG. 8 is a schematic representation of a circuit embodying a second method of implementing a method for adding keys to the associative memory of FIG. 5, comprising add key logic component of the learned key logic of FIG. <b>6</b>.</p>
    <p>FIG. 9 is a flow diagram describing the operation of a create new index logic component for the add key logic circuit of FIG. <b>8</b>.</p>
    <p>FIG. 10 is a flow diagram describing the operation of a change old index value component of the add key logic of FIG. <b>8</b>.</p>
    <p>FIG. 11 is a continuation of the flow diagram of FIG. 10 describing the operation of add the change old index value component.</p>
    <p>FIG. 12 is a continuation of the flow diagram of FIG. <b>11</b>.</p>
    <p>FIG. 13 is flow diagram describing the operation of a save new index logic component of the add key logic of FIG. <b>8</b>.</p>
    <p>FIGS. 14A and 14B are a flow diagram describing a method for assigning index values to an entire key set.</p>
    <p>FIGS. 15A, <b>15</b>B and <b>15</b>C are a flow diagram describing another method for assigning index values to an entire key set.</p>
    <p>FIG. 16 is a flow diagram describing a method for assigning an index value and expanding the directory to accommodate the new index value.</p>
    <p>FIG. 17 is a flow diagram describing a method for removing an index value and contracting the directory to accommodate the removed index value.</p>
    <p>FIG. 18 is a schematic representation of a circuit implementing symbol use count logic, maximum suffix logic, minimum suffix logic and delete key logic for the method of FIG. <b>15</b>.</p>
    <p>FIG. 19 is a schematic representation of an alternative embodiment of an associative memory module.</p>
    <p>FIG. 20 is a schematic representation of a circuit for learned key logic for the associative memory of FIG. <b>19</b>.</p>
    <p>FIG. 21 is a schematic representation of a circuit implementing symbol use-count logic and delete key logic for the learned key logic circuit of FIG. <b>20</b>.</p>
    <p>FIG. 22 is a flow diagram illustrating the method for assigning index values to an entire key set group, including all invalid symbol values.</p>
    <p>FIG. 23 is a schematic diagram for an associative set processor and its included circuitry.</p>
    <p>FIG. 24 is a flow diagram of a union function for use with the associative set processor of FIG. <b>23</b>.</p>
    <p>FIG. 25 is a flow diagram of a intersect function for use with the associative set processor of FIG. <b>23</b>.</p>
    <p>FIG. 26 is a flow diagram of a mask function for use with the associative set processor of FIG. <b>23</b>.</p>
    <p>FIG. 27 is a block diagram illustrating the use of an associative set processor to combine a plurality of use count tables.</p>
    <p>FIG. 28 is a block diagram illustrating the preparation of a result record memory from a plurality of results tables.</p>
    <p>FIG. 29 is a flow diagram illustrating the symbol sequence scanner logic of FIG. <b>28</b>.</p>
    <p>FIGS. 30A thru <b>30</b>D are flow diagrams of the highest thru lowest order bank functions.</p>
    <heading>DETAILED DESCRIPTION OF THE DRAWINGS</heading> <p>There are many communication networks existing today which are independent entities with respect to each other such as shown in FIG. <b>1</b>. Each system <b>1</b>-<b>5</b> uses a particular hardware technology appropriate for its own communication problems; some use high speed networks; others use slower speed networks to interconnect machines. There are long haul networks and local area networks (LANS). There are shared media networks such as ETHERNET, TOKEN RING, TOKEN BUS, FDDI and the like, each of which has a different physical media protocol. Each of these network information systems may have its own protocol for handling information within the system.</p>
    <p>When electrical wires or cables are used to couple shared media networks, the size of the net is limited by signal attenuation to a few hundred meters; thus, the name Local Area Networks. There is no reason to limit the area of coverage other than the restrictions of the media itself. With the increased use of fiber optics, the span of these shared media networks is expanding to several kilometers and eventually will be able to span the entire continent.</p>
    <p>In the prior art, when an external device or host such as an aircraft <b>10</b>, ship <b>12</b> or other receiver/transmitter (transceiver) station is communicating with anyone of these systems <b>1</b>-<b>5</b>, it must have an identification of its own which is recognized by the protocol of the system with which it is communicating. In such systems, if aircraft <b>10</b> wishes to communicate with ship <b>12</b>, aircraft <b>10</b> must transmit into the system, among other things, a fixed address of the message receiving ship <b>12</b>. The protocol of the system can then use the address information to route the message through the system to the ship <b>12</b> at the address indicated.</p>
    <p>However, when a host passes from one communication system to another, the address code of that host must be changed to be conformed with or admitted to the new communication system. Thus, if a host passes from an FDDI to an ETHERNET system, the address code of the host must be changed in order to enable the new system to accommodate it. This change may require a great deal of manipulation of data within the system and require expensive additional equipment to enable the appropriate changes to be made. Further, by the time one host (ship <b>12</b>) sends a message to the last known address of the moving host (aircraft <b>10</b>), the moving host may have entered the range of a new communication network and have a different address code thereby causing a problem in receiving the message sent with a network dependent address from the message sending host.</p>
    <p>The present invention modifies the system of FIG. 1 to overcome the disadvantages of the prior art by allowing each host to have a fixed unique identification code instead of an address code which changes to identify itself with whatever communication network it may operating. With the present invention, if host A passes from a first communication network system to a second network system (as for instance aircraft <b>10</b> flying from communication network <b>1</b> to network <b>2</b>) host A may be located by host B (ship <b>12</b>) who simply transmits into the communication routing system the unique identification code of the host A with which it desires to communicate. It does not know where in the system, or in a plurality of interconnected communication systems, the host A is located.</p>
    <p>The interconnecting systems shown in FIG. 1 include a plurality of nodes <b>16</b>, <b>20</b>, <b>24</b>, <b>26</b>, <b>30</b> and <b>32</b> forming multipath connections between the plurality of network communication systems <b>1</b>-<b>5</b>. The nodes can interface with each other even though they are in different communication systems simply by using protocols and procedures that are well-known in the art.</p>
    <p>If aircraft <b>10</b> desires to contact ship <b>12</b>, it simply transmits a message format including its own unique code and the unique identification code for ship <b>12</b> to the nearest system <b>14</b>. The receiving system <b>14</b> sends the message to node <b>18</b> which checks its memory tables to determine if it has stored the address of the last node (<b>26</b> or <b>32</b>) communicating with ship <b>12</b>. If not, it stores the unique identification code of aircraft <b>10</b>. It also forwards to all interconnecting nodes, except the one from which the message was received, <b>26</b> and <b>32</b> in this case, the message including the identification code of ship <b>12</b> as well as the identification code of aircraft <b>10</b>. In like manner, each of the interconnecting nodes <b>26</b> and <b>32</b> checks its memory storage tables to see if it has received and stored the identification code for either aircraft <b>10</b> or ship <b>12</b>. If not stored, it stores the unique identification code of aircraft <b>10</b> and the address of the forwarding node, and forwards that information to the succeeding nodes. Thus node <b>26</b> forwards that information to nodes <b>20</b> and <b>24</b> but would not forward it to node <b>32</b> since node <b>32</b> is also coupled to node <b>16</b> which has that information. Node <b>20</b> will be updated by node <b>26</b> since it is the closest node. Eventually, ship <b>12</b> will contact its nearest node <b>20</b> coupled to communication network system <b>5</b> through radio receiver <b>18</b> to identify itself. Source node <b>20</b> has the unique identification code for aircraft <b>10</b> stored in its memory table and will store the identification code and received route for ship <b>12</b> in its memory table. Node <b>20</b> will now contact the nearest node <b>26</b> from which it received the identification code for aircraft <b>10</b> and couple ship <b>12</b> to that node. Node <b>26</b> again will check its memory bank and find the nearest node from which it had received the identification code for aircraft <b>10</b> (node <b>16</b>). A communication path is thus completed between aircraft <b>10</b> and ship <b>12</b> and they can communicate with each other even though initially one did not know the location of the other in the system. It will be noted that in this case there were no specific address locations of either aircraft <b>10</b> or ship <b>12</b> in any of the message formats that were transmitted or received.</p>
    <p>They simply contained the identification code of the message source and message receiver that was stored by the nodes and the addresses of each node in the path having that information, and the information was recalled as necessary to establish communication paths between aircraft <b>10</b> and ship <b>12</b>.</p>
    <p>If ship <b>12</b> is moving and passes from the control of a first network communication system <b>4</b> to a second network communication system <b>5</b>, the nearest node <b>32</b> in the first communication system <b>4</b>, after a predetermined period of time, drops from its memory bank the identification code and routing information of ship <b>12</b>. However, the transmission by ship <b>12</b> of its identification code to the nearest node <b>20</b> in the second communication system <b>5</b> is recorded by that node and transmitted to the other nodes throughout the interconnected system so that each node now knows the updated location of node <b>20</b> that is nearest to ship <b>12</b>. In that manner, either aircraft <b>10</b> or ship <b>12</b>, even though either or both are moving, can continually communicate with each other through an interconnected system of communication networks without having the specific system address of the other.</p>
    <p>Since any given node may receive information from one or more nodes, standard protocol is used to determine the node from which the given node first received the information. That would be the closest node. If, in the event of a transmission back along that path, it was found that the closest node was for some reason out of the system, it could then pick one of the other possible routes and send the information to a different node along one of those routes.</p>
    <p>Further, each of the nodes must be able to recognize when a message is for a single node (unicast), a group of nodes (multicast) or all nodes (broadcast). Such requirements can be accomplished by systems that are already well-known in the art.</p>
    <p>Further, each node is an information source to some nodes and an information destination for other nodes. Thus, each node has to keep a source index table and a destination index table. See FIG. <b>2</b>. When aircraft <b>10</b> attempts to contact ship <b>12</b>, aircraft <b>10</b> transmits into the nearest node its own identification code as well as the identification code of ship <b>12</b>. The nearest node stores the source (aircraft <b>10</b>) identification code in a source index table and in a destination index table. If a node has the destination identification code stored, it also has stored the address of the node from which it received that information in both its source protection record and destination route record. Of course, it may have received that information from several nodes and the addresses of all of those nodes are stored as sources and destinations. The source protection record, when combined with the destination route record, eliminates the routes to all of the other nodes except the nearest route through the use of a buffered routing logic circuit. Thus a path is connected between the two closest nodes for carrying the packet of information from aircraft <b>10</b> to the next nearest node. This process repeats in each node until the information packet arrives at ship <b>12</b>.</p>
    <p>Referring again to FIG. 1, as aircraft <b>10</b> is detected by receiver <b>14</b>, the identification code information transmitted by aircraft <b>10</b> is fed into a communication network or system <b>1</b> and node or router <b>16</b> notifies the other nodes or routers in the system of the identification code. In like manner, as receiver <b>18</b> detects ship or vessel <b>12</b>, communication network or system <b>5</b> updates node or router <b>20</b> with the ship <b>12</b> identification code. It, in turn, notifies the other nodes or routers within the complex communication network or system. As receiver <b>22</b> detects the movement of aircraft <b>10</b> into its area, communication network or system <b>2</b> updates node or router <b>24</b> which then updates the other nodes or routers within the system. Node <b>16</b> no longer receives information from system <b>1</b> but now updates its information from system <b>2</b> through nodes or routers <b>24</b> and <b>26</b>. As aircraft <b>10</b> continues to move, receiver <b>28</b> will detect aircraft <b>10</b> and notify router <b>30</b> through system <b>3</b>. Again, router <b>30</b> notifies the other nodes or routers within the system. Node or router <b>24</b> will no longer receive its information from network <b>2</b> but will be updated through router <b>30</b> as to the identification code of aircraft <b>10</b>.</p>
    <p>The problem with such vehicle movement with the prior art system, as stated, is that each of the communication systems <b>1</b>-<b>5</b> are different networks and may use different types of media access protocols for operation which require the network address of the moving vehicle to be changed. Thus many communication networks service their stationary and mobile users with a wide variety of media ranging from satellite links, high frequency radio, local area networks (LANS) and dedicated point to point circuits as illustrated in FIG. <b>1</b>. Shipboard LANS, including SAFENET I (IEEE 802.5 Token Ring) and SAFENET II (ANSI X.3-139FDDI), are used to support command, control, communications and intelligence in certain systems. The use of standard ISO (International Standards Organization) Internet protocols and the development of very high performance, low latency packet-switched gate ways between these networks is critical to reliable communications between mobile vehicles.</p>
    <p>As stated, in the prior art, the aircraft <b>10</b> must have assigned to it a code representing its physical address with respect to communication system <b>1</b>. Physical addresses are associated with interface hardware. Thus, moving the hardware interface to a new machine or replacing a hardware interface that has failed changes the physical address of a particular host. In like manner, as the aircraft moves from system <b>1</b> to system <b>2</b> in FIG. 1, because system <b>2</b> may operate with a different media access protocol, the coding of the physical address of aircraft <b>10</b> must be changed to meet the standards of system <b>2</b>. This means that if ship <b>12</b> attempts to communicate with aircraft <b>10</b> using the physical address at the last known address location in system <b>1</b>, it cannot locate aircraft <b>10</b> without a new location code because aircraft <b>10</b> has moved into a new communication system network and has changed its physical address code.</p>
    <p>The novel system of the present invention modifies FIG. 1 to provide an Internet routing table that uses a flat logical address structure to provide fast and efficient route processing of both multicast and unicast message traffic. In the present system, the physical address structure is removed from the design and operation of the Internet routing by treating the message addresses as a symbol string without predetermined internal structure and processing them as if they are a unique identification code representing the host. This approach is made possible by employing an arithmetic code compression technique as a hashing function for the routing table access method. By managing and manipulating logical network addresses within the system, mobile end-systems can keep the same network identification code (not physical address) as they move from communication network to communication network. similarly, group or multicast addresses may be allocated without regard to their physical network connection. Thus, considering the use of the present system with the networks of FIG. 1, aircraft <b>10</b> and ship <b>12</b> maintain the same identification code even though they move from one of the networks <b>1</b>-<b>5</b> to another. When aircraft <b>10</b> is in communication with network <b>1</b>, node <b>16</b> notifies all of the other nodes <b>20</b>, <b>24</b>, <b>26</b>, <b>30</b> and <b>32</b> in the system that node <b>16</b> is in contact with aircraft <b>10</b>. In a like manner, when ship <b>12</b> is in communication with node <b>20</b> through network system <b>5</b>, node <b>20</b> notifies the other nodes in the system that it is in communication with ship <b>12</b>. If aircraft <b>10</b> moves to network system <b>2</b>, node <b>24</b> updates all of the other nodes in the system and their data is changed to identify node <b>24</b> as the new node in contact with aircraft <b>10</b>. This system then enables each node to store data representing the address of the last node communicating with a particular mobile vehicle and not the physical address of the vehicle. This allows communication from aircraft <b>10</b> to ship <b>12</b> throughout the various communication systems without either aircraft <b>10</b> or ship <b>12</b> being required to change network addresses as they move from access point to access point and without knowing the specific network location of the other.</p>
    <p>Each of the nodes <b>16</b>, <b>20</b>, <b>24</b>, <b>26</b>, <b>30</b> and <b>32</b>, may utilize any well-known means in the art for providing point-to-point and demand assignment access protocol message transmissions to communicate with each other. There are various systems well-known in the art which allow communication network systems using one protocol to communicate with another system using a second protocol and they will not be described here.</p>
    <p>The present system may be utilized as a Media Access Controller (MAC) multi-way switch in each node as an electronic module which detects the physical layer node address fields of the data packets arriving from one node and uses those addresses to route (switch or bridge) the packet to another node which is a path to the physical station with a particular node destination address. The MAC level multi-way switch examines the bits which constitute the node destination address field to identify which, if any, of the nodes connected to the switch should be presented the message packet for transmission. This operation is often called “destination address filtering.”</p>
    <p>A number of shared media networks previously mentioned have been standardized for common use and inter-operation of different vendor equipment. The most common of the LAN standards are ETHERNET, TOKEN BUS, TOKEN RING AND FDDI. Each of these shared media networks sends information as a variable length sequence of bits called a packet. Each packet has a fixed number of the initial bits transmitted which are dedicated both in position and size to a packet header. This header contains a destination address field and a source address field along with other housekeeping information bits. All four of the LAN standards listed above employ the same number of bits with the same meaning for both the source and destination address fields, although the housekeeping fields are different for each.</p>
    <p>Shared media networks operate basically in the same way. The media is shared so only one node or station (one MAC) may transmit at a time and all of the other nodes or stations listen. In order to identify the recipient of the message, a destination node address is located in a specific location at the beginning of each information frame. Each listening station examines these destination node address bits to determine if the packet is for it. The receiving station (the destination node) needs to know where to send a response to the received packet and thus the packet has source node address bits at a specific location (usually just after the destination node address). The major differences in the various LAN standards are transmission speed and the scheme each uses to guarantee that only one station at a time is allowed to transmit on the media.</p>
    <p>The Media Access Controller (MAC) is the defined entity in each of the above-listed LAN standards which connects the computer side logical level interface to the physical media. MAC isolates the logical data stream from the physical media so the circuitry on the computer side of the MAC only deals with the header and information bits.</p>
    <p>Thus, the MAC-level switch or bridge is an electronic module which connects similar or dissimilar physical shared media networks each of which employ identical addressing field definitions. The switch transfers information packets originating from stations or nodes on one network to destination stations or nodes on another network. If station A on a shared media network desires to send a packet to station F, then station A places codes representing “F” in the destination node address field and “A” in the source node address field of the packet header of the packet being transmitted. When the MAC of station A gains access to the shared media, it transmits the packet along with other packets it may have queued for transmission. Other connected MACs all receive the packet header and examine the destination node address field. Station F recognizes the address as his own and receives the remainder of the packet. All of the other stations on the network see that the packet is not for them and disregard the rest of the packet. Neither the source node address nor the destination node address are changed in any way.</p>
    <p>All of the standard LANS listed above have a group addressing scheme where one station may send one packet simultaneously to many other stations belonging to the group. This feature is called multicast and takes advantage of the shared media to send the packet just once rather than having to send an individual packet to each station in the group. Suppose station A wishes to send a packet to all stations in a group identified as <b>110</b> which includes stations identified as F, G and N. Station A would then put the group “110” in the destination node address field and “A” in the source node address field. When MAC A gains access to the first network, it transmit the packet. Stations F, G and N would then detect their group address and accept the packet. Other MACs would not.</p>
    <p>FIG. 2 is a schematic diagram of a MAC switch <b>38</b> which couples a Media Access Controller <b>34</b> at one node level to desired Media Access Controllers <b>40</b>, <b>42</b>, <b>44</b> and <b>46</b> at other levels.</p>
    <p>The MAC level switch <b>38</b> shown in FIG. 2 examines the source node address field of the incoming information to determine if any or all of the other connected nodes are protected from receiving the information from the incoming source. This operation is often called “source address filtering.”</p>
    <p>Thus in FIG. 2, MAC <b>34</b> may transmit data and clock information on lines <b>36</b> to switch <b>38</b> which determines which of the destination MACs <b>40</b>, <b>42</b>, <b>44</b> and <b>46</b> are to receive the information. In switch <b>38</b>, the data and clock signals on line <b>36</b> are serially coupled to a source address shift buffer <b>48</b> and then to destination address shift buffer <b>50</b>. The data is then transferred from destination shift buffer <b>50</b> to delay buffer <b>52</b> which is a first-in, first-out device. The output of delay buffer <b>52</b> on line <b>54</b> is coupled to the buffer routing logic <b>56</b> which generates an output on lines <b>58</b>, <b>60</b>, <b>62</b> and <b>64</b> depending upon the destination address filtering operation performed by the switch <b>38</b>.</p>
    <p>The Media Access Controller switch <b>38</b> transmits or forwards data it receives, and accepts data for transmission as eight parallel data bits called a data octet. It processes address symbols which are a fixed number of consecutive bits from the address bit string and may be from two to any number of bits in length. One size symbol is the “eight” bit octet which is the symbol size used in the address routing table circuits presented in FIGS. 2 and 3. The number of symbols in the maximum address length to be processed for a particular implementation is a design and management decision. The examples presented in FIGS. 2 and 3 use six octets as the maximum address length, since this is the length of the IEEE standard physical layer (MAC level) address used by Ethernet, Token Ring, and FDDI. The International Standards Organization (ISO) network layer (IP.ISO 124) employs a variable length, up to 20 octets, for the source and destination address <b>128</b> and <b>126</b>, as shown in FIG. <b>4</b>. The designs shown in FIG. <b>2</b> and FIG. 3 would be able to process IP.ISO <b>124</b> addresses <b>126</b>, <b>128</b> up to “six” octets in length. MAC <b>38</b> is responsible for aligning the data properly on the octet boundaries such that the destination and source addresses start and end on octet boundaries. Furthermore, in the LAN standards listed above, the source address field always immediately follows the destination address field and the two are always the same size. A common size for the address fields is 48 bits or 6 octets each. The address detection logic examines both the destination and source address fields represented by the octets shifted into buffer <b>48</b> and buffer <b>50</b>. Six octets are in each buffer. When the twelve octets are all stored, each octet is used as an address into a 256 element index table for that address octet position. This requires six destination index tables <b>66</b> and six source index tables <b>68</b>. The output of these tables (the contents of the location addressed by each octet) is then arithmetically combined in combiners <b>70</b> and <b>72</b>. One method of arithmetically combining these outputs adds the six outputs of the source index table <b>68</b> to compute the source index <b>74</b>. It also adds the six destination table <b>66</b> outputs to compute the route index <b>76</b>. The source index <b>74</b> is used as the address into the source protect table <b>78</b> and the output of that location is the source protection record <b>80</b> which is coupled to the routing logic <b>82</b>. Similarly, the route index <b>76</b> is used as the address of a location in the destination routing table <b>84</b> and the contents of that location is coupled to route record <b>86</b>. The outputs of the protect record <b>80</b> and route record <b>86</b> are used by the routing logic <b>56</b> in a well-known manner to determine which destination MAC is to receive the message.</p>
    <p>FIG. 2 may also operate as an internet level switch (router) <b>38</b>, operating on IP.ISO header <b>124</b> destination <b>126</b> and source addresses <b>128</b> by shifting in the IP destination and source addresses. When aircraft <b>10</b> in FIG. 1 transmits a packet with its unique internet source identification code to one of the nodes in a network, the source address of aircraft <b>10</b> is shifted from source address buffer <b>48</b> (FIG. 2) into learned address logic <b>88</b>. If that source address is a new address not stored in source index table as indicated by a zero detect, it is stored in both the source and destination index tables <b>66</b> and <b>68</b>. If, after a predetermined amount of time, that information is not confirmed by a subsequent transmission, the learned route logic <b>94</b> generates an output <b>97</b> to the learned address logic <b>88</b> telling it to delete the address from the both source and destination index tables <b>66</b> and <b>68</b>. This means that the aircraft <b>10</b> has moved to a different network and may be updating a new node in the new network. Subsequently, the new network node then sends a message to switch <b>38</b> in the old node and stores the source address of the new node in the route record <b>86</b> associated with the unique source address for aircraft <b>10</b>. By keeping track of the source addresses of the various nodes that are transmitting information concerning a particular identification code, learned route logic <b>94</b> causes the destination routing table <b>84</b> to delete old source nodes as destinations for particular incoming data packets and add the addresses of new nodes as the destination. The source protect table <b>78</b> in each node stores the source protect record <b>80</b> (also called the MultiCast Record List <b>134</b> in FIG. <b>4</b>), which has information defining a shortest path from a particular source to that node. This shortest path information is computed from the messages received from forwarding nodes using a shortest path spanning tree algorithm well known in the art. The source protect record <b>80</b> may be modified by management decision to prevent messages from a particular source identification code from being forwarded on particular paths to other nodes.</p>
    <p>The destination routing table <b>84</b> (also called the Outbound Record Linked List <b>132</b> in FIG. 4) contains the shortest path information from this node to the current connected nodes for each unique identification code currently stored in the source and destination index tables. The current route record <b>86</b> is this shortest path information for the destination address currently in buffer <b>50</b>. This information is computed from the messages received from forwarding nodes using a shortest path spanning tree algorithm well known in the art. Thus, in FIG. 1, if node <b>26</b> has received information from source nodes <b>16</b>, <b>24</b> and <b>32</b>, and it receives a data packet for node <b>20</b>, the protect record <b>80</b> from the source protect table <b>78</b> and the route record <b>86</b> in FIG. 2, when processed by the buffered routing logic <b>56</b>, will prevent node <b>26</b> from transmitting the information back to nodes <b>16</b>, <b>24</b> and <b>32</b> but allow it to be transmitted to the destination node <b>20</b>. Thus, the information from an incoming node or MAC <b>34</b> to a particular switch <b>38</b> may be transferred to the desired destination MAC <b>40</b>, <b>42</b>, <b>44</b> or <b>46</b> by the buffered routing logic <b>56</b> in the manner explained.</p>
    <p>In FIG. 2, the address detection logic employs separate tables and arithmetic processing elements for both the source and destination address detection. While this approach allows the arithmetic processing and record table access to be relatively slow the slower elements are not sufficiently economical in price to be cost effective. Neither does the circuit of FIG. 2 utilize the fact that because the data octets arrive sequentially, they could be processed through the index look-up table and partial arithmetic computed each octet time.</p>
    <p>FIG. 3 is a circuit diagram of an alternate logic layout for serial processing of the incoming data by a switch <b>96</b> which is similar to switch <b>34</b>. The data octets arrive sequentially and FIG. 3 discloses a logic layout which uses one bank of index table memory <b>98</b>, one bank of address record memory <b>100</b> and one arithmetic computation unit <b>102</b> to accomplish both source and destination address detection. In this approach, the octet data bits are coupled serially into octet register <b>104</b> and are used as the low order address bits into the index table <b>98</b>. A byte counter <b>106</b> which counts the address octets from one to twelve as they arrive in the octet register <b>104</b> is used as the high order address bits into the index table <b>98</b>. From byte count one to six, the arithmetic unit <b>102</b> partially computes the final index with each output from the index table. After byte count six, the computation for the destination address mask index is complete and transferred to the index buffer <b>108</b>. The arithmetic unit <b>102</b> is then reset and the six octets of source address are computed. By the time the source protection record index <b>110</b> has been computed, the data in destination route record <b>112</b> has been loaded into its output buffer on line <b>114</b>. The source protect record <b>110</b> is then accessed from a second bank of the mask memory <b>100</b> using the count twelve signal on line <b>116</b> as the high order address bit. This sequential detection approach shown in FIG. 3 places special performance requirements on the index table memory and each reiteration of the arithmetic computation. That is, the access to the index table <b>98</b> and the partial computation with the table output each must be complete in less than one octet time. However, the computation is delayed one octet clock time behind the table access. Each of these timing requirements is within the available speeds of commercially available VLSI computer memory and arithmetic components. Current DRAM memories regularly run at less than 300 nanosecond access times making all but the FDDI real-time address routing practical with DRAM parts. Static RAM memories are currently available with 50 nanosecond and faster access times which makes even FDDI routing realizable. The address record memory <b>100</b> is only required to be ⅙ the speed of the index memory <b>98</b> since there are six octets between completion of the first and second record indexes. The source protect record <b>110</b> and the destination route record <b>112</b> feed into the buffered routing logic <b>56</b> of FIG. 2 to select the outbound path (MAC) for the message.</p>
    <p>The record memory indexes may be computed by adding and accumulating the succession of six index table values to compute the mask memory index. Integer add/accumulator devices of 16 to 32 bit precision are currently available which execute a single add function in less than 80 nanoseconds. Many 16 and 32 bit microprocessors have integer add/accumulate times under 500 nanoseconds.</p>
    <p>The address directory access circuit overview is shown schematically in FIG. <b>4</b>. The arriving data packet contains a preamble <b>118</b>, the first protocol layer <b>120</b> which is the Media Access Control protocol header containing the physical media destination address of the MAC receiving the packet, the second protocol layer <b>122</b> which is the logical link control and the third protocol layer <b>124</b> which is the IP.ISO Internet layer. The remainder of the packet contains the message data and housekeeping information. The third protocol layer <b>124</b> contains the unique code identifier of the receiver as the destination address data <b>126</b> and the unique code identifier of the transmitter as the source address data <b>128</b>. The physical link data <b>120</b> is the actual communication channel hardware with its associated coding and modulation techniques. Physical link <b>120</b> is separated from the Internet data <b>124</b> by a combination of computer interface hardware and software called the logical link control entity data <b>122</b>. Besides logically isolating the Internet layer <b>124</b> from the physical layer <b>120</b>, the logical link control <b>122</b> provides a capability to multiplex packets from various higher level protocols such as TCP/IP, DECNET, and ISO/OSI over the same physical link. Each different protocol is assigned a different logical service access point (LSAP). Each LSAP is serviced by a separate set of software providing processing for each protocol as is well known with prior art. It is thus possible that one physical Internet router might be required to route packets of different protocols and therefore require two or more Internet software processes. This prospect is likely in an environment where existing networks using the TCP/IP protocols are phased over to the ISO/OSI protocols. This invention allows the same routing table access method to be employed by multiple protocols.</p>
    <p>The IP/ISO Internet protocol data <b>124</b> provides a connectionless or datagram service between nodes on a network. Data to be sent from one node to another is encapsulated in an Internet datagram with an IP header specifying the unique global network addresses of the destination and source node. This IP datagram is then encapsulated in the logical link control <b>122</b> and physical layer protocol headers <b>120</b> and sent to a router or node. The router strips off the incoming physical header <b>120</b> and the LLC header <b>122</b>. It looks up the destination and source addresses <b>126</b> and <b>128</b> in its routing table <b>130</b>, selects the appropriate outbound link, or a plurality of outbound links in the case of a multicast group destination address from table <b>132</b> and reduces the plurality of outbound links using restrictions from table <b>134</b> in the case of a multicast transmission and passes the IP datagram packet to those selected channels for LLC encapsulation and transmission. With multicast datagrams, the router must determine which outbound links represent the shortest path from the multicast source to the destinations which are members of this particular group. Without this source filtering, well-known in the art, a destination station within a group might receive many copies of the datagram transported over different paths. Such multicast “flooding” wastes networks bandwidth and causes unnecessary congestion on busy segments of the network.</p>
    <p>The ISO Internet Protocol (IP) header <b>124</b> has a number of fields. From the IP header format <b>124</b> it is apparent that the starting position and length of both the destination and source address fields are known or can be determined from the information within the IP header. The proposed routing table directory structure <b>130</b> needs only to know the length and values of the address octets to locate a unique table entry for that address. This novel directory access technique does not rely on any known structure of the address field other than knowing that it is a sequence containing a known number of symbols.</p>
    <p>It can be seen from the discussion of FIG. 4 that the circuit therein could be used in an alphanumeric system such as, for example only, a library wherein an author and/or book name could be used to access a data table storing all books by author and title. In that case, destination address <b>126</b> in FIG. 4 would be an alphanumeric string of data representing the author's name and/or book titles. The arithmetic compression techniques illustrated by blocks <b>138</b>, <b>142</b>, and <b>144</b> could be used to compress the alphanumeric string as needed to obtain an index <b>136</b> which would select the appropriate address in table <b>130</b> which would contain all of the library material by author and book title. The selected information could then be obtained through routing tables <b>132</b> and <b>134</b>.</p>
    <p>Since the destination and source address are from the same network address space, they have an identical form and can use the same directory. Source addresses must be individual nodes and cannot be group addresses. To constrain the Internet overhead, the initial versions of the ISO Internet have been restricted to 16 octets maximum. This is a huge number of possible addresses on the order of 10<sup>36 </sup>and should be more than adequate for many years of global Internet operation.</p>
    <p>Routing is accomplished by maintaining a routing table directory <b>130</b> at each node in the network as is well-known in the art. These tables are indexed by the destination and source address and contain information indicating which outbound communication links reach the destination node or nodes in the case of a multicast group address. The Internet routing task or program accesses the table <b>130</b>, gets the outbound route information, analyzes the route information and queues the packet for transmission on one or more of the outbound ports stored in tables <b>132</b> and constrained by the records in <b>134</b>. For all addresses, the Internet task also accesses the source address table which contains information defining which outbound ports should not be used for a multicast transmission to this group (destination address) from a particular source and other source filtered information.</p>
    <p>Efficient multicast transmission requires some evaluation of the shortest route to all members of the group from the source location. The present system utilizes the directory <b>130</b> and routing table structure <b>132</b> and <b>134</b> for the already existing Link-state approach. Other existing methods have similar needs and could be incorporated into the design if another routing method is employed by a network.</p>
    <p>The novel Internet routing task set forth herein is self learning. No information about any existing addresses or their routes need be stored in the task prior to start up. The routing information is entered into the routing table <b>130</b> as a result of the Internet routing protocol activity or network management protocols. When a router starts up, it sends out “I am here” messages using the Internet routing protocol. All of the adjacent routers or nodes send back IP routing protocol packets which, when combined with the input bound channel, contain the information necessary to fill in the routing tables for all active Internet addresses.</p>
    <p>The novel system uses arithmetic coding of the directory index <b>130</b> as shown by the diagrammatic illustration in FIG. <b>4</b>. Arithmetic coding is a powerful technique for obtaining the near minimum entropy compression of a sequence of data bits. Since a network address is just a sequence of binary data bits of known length, the minimum entropy compression of all the combinations of bit strings represented by all of the active network addresses should produce the shortest number of bits which would uniquely identify all of the addresses. This encoding could then be used as an index <b>136</b> into the routing directory <b>130</b>. Essentially arithmetic coding uses the distribution statistics of the symbols (in this case octet values) to divide a unit space into a unique fraction based on the sequence of symbols (octets) presented. As each symbol (octet) is presented, the unit space is subdivided into a smaller range. Symbols (Octets) with higher probability of occurrence reduce the range less than those with small probability, causing fewer bits to be used in encoding the higher probability octets. A detailed discussion of such method including program fragments and examples is disclosed in a paper published by Witten, Neal, and Cleary, <i>Communications of the ACM</i>, June, 1987. This paper is oriented to adaptive encoding and decoding of data streams and does not deal with the specific application of address detection. However, the method disclosed in that paper can be used for that purpose. Thus in FIG. 4, the destination address <b>126</b> is compressed by the arithmetic code process <b>138</b> to obtain an integer <b>140</b> which represents the address. If further compression is needed, the integer can be compressed through truncation <b>142</b> by methods well-known in the art and further compressed if needed by hashing <b>144</b>, a technique also well-known in the art. The resulting index <b>136</b> is then used to find the unique address in the compressed address directory <b>130</b>. The routing switch designs <b>38</b> and <b>96</b> shown in FIGS. 2 and 3 are specific implementations of the novel arithmetic compression process employed by this invention.</p>
    <p>After all the address octets have been processed, the last value is then the compressed value of the input address octet string. It is sufficiently compressed to be useful as a routing table index.</p>
    <p>The novel index table construction and address compression processing of this invention takes place as follows: Addresses can be fixed and variable length bit strings embedded in the Media Access Control (MAC) <b>120</b> and Internet protocol (IP.ISO) <b>124</b> headers of the received communication packet. The maximum size (Address_length) of an address which can be compressed is set by a management decision and the physical design of a particular implementation of the process.</p>
    <p>Symbols are consecutive sets of adjacent bits taken in sequence from the address bit string. Successive symbols may have a fixed overlap incorporating a fraction (Overlap fraction) of the same bits from the address bit string in an adjacent symbol. All the valid bits in the address string must be included in symbols processed. For a particular implementation of the process the symbols are a fixed number of bits in length (Symbol_size) which can vary from 2 bits to any number of bits. In the embodiments presented in FIGS. 2 and 3, a symbol is an “eight” bit octet. The number of symbol positions in an address string (Num_symbol_positions) is the length of the address string in bits divided by the symbol size minus the product of the symbol size and the overlap fraction. Thus,</p>
    <p>
      <maths> <formula-text>Divisor=Symbol_size−(Symbol_size×Overlap_fraction)Num_symbol_positions=Address_length/Divisor</formula-text> </maths> </p>
    <p>An address index table (<b>66</b>, <b>68</b> and <b>98</b> in FIGS. 2 and 3) has a number of banks equal to the number of symbol positions in the address string. Each bank of memory in the address index table has a number of memory locations (Bank_size) equal to “two” to the power of the symbol size. Sub-index values are stored in the non-zero locations of each bank. Thus,</p>
    <p>
      <maths> <formula-text>Bank_size=2 raised to the Symbol_size power.</formula-text> </maths> </p>
    <p>The address index table size (AI_table_size) is the product of the bank size (Bank_size) and the maximum number of symbol positions (Num_symbol_positions) being processed.</p>
    <p>The maximum number of non-zero entries, called the allowed maximum count (Allowed_max_count), in each bank of an address index table is set by a management decision. Addresses may be encoded into the address index table until the number of non-zero entries reaches the allowed maximum count for any symbol position. If the encoding of any address value into the address index table results in the number of non-zero entries in one of the symbol positions exceeding the maximum allowed number of entries, then the address cannot be encoded into the table until another entry in this symbol position is removed, that location made zero, and the current count decremented by one. Alternately, the allowed maximum count may be increased by a management decision and all the existing address bit strings must be recoded into the address index table using the new maximum non-zero entry values.</p>
    <p>The address index tables (<b>66</b>, <b>68</b> or <b>98</b>) are then incrementally filled in with sub-index values as particular address bit strings are encoded into the address tables. This processing takes the following steps.</p>
    <p>Initially the table (<b>66</b>, <b>68</b>, and <b>198</b> in FIGS. 2 and 3) is entirely filled with zero entries and the value of all locations in the table is set to zero.</p>
    <p>(1) A counter (Current_count) is established by the learned address logic <b>88</b> for each symbol position to keep track of the number of non-zero entries in this bank of the address index table and these counters are initially set to zero. In order to keep track of the number of addresses using a particular non-zero location in the address index table, a use counter is established in the learned address logic <b>88</b> for each non-zero location in each bank of the address index table.</p>
    <p>(2) The allowed maximum non-zero entries value for each symbol position is obtained from a management decision.</p>
    <p>(3) A range value (Range) is computed for each symbol position. The first range value is computed by setting the range for some symbol position to the allowed maximum count for that symbol position. The range value for the next symbol position is the range value for the previous symbol position times the allowed maximum count for this symbol position. The range value for each symbol position is the product of the range value of the next previously computed symbol position and the allowed maximum count for this symbol position. The order of the symbol positions used to compute the range values is only important in that the decoding operation used to recover the original address before encoding to an integer value must use the same symbol order as that used to compute the range values. The sequence of range value computations from the last address symbol to the first address symbol must be used to preserve hierarchical structure of the structure of the original address being encoded.</p>
    <p>
      <maths> <formula-text>Range (<i>I</i>)=Range (<i>I+</i>1) times Allowed_max_count (I)</formula-text> </maths> </p>
    <p>Each symbol from an address bit string to be encoded into the address index table is processed in the same sequence as that used to process the address symbols during receipt of the packets from a transmitter for routing table access.</p>
    <p>(1) Use the numeric value of the symbol as the address of the location in this symbol's bank of the address index table (<b>66</b>, <b>68</b> and <b>98</b>).</p>
    <p>(a) If the existing entry in this location of this bank of the address index table is not zero, then increment the use count for this location and no further processing of this symbol is required and the next symbol may begin processing.</p>
    <p>(b) If the existing entry at this location in this bank of address index table is zero, then non-zero entry value is computed by (1) incrementing the current count for this symbol position, (2) checking to be sure the incremented current count is less than or equal to the allowed maximum count for this symbol position, and</p>
    <p>(3) (if the count is not greater than the maximum) computing the value of the incremented current count multiplied by the range value for this octet position and divided by the allowed maximum count for this position and storing this value in this location in the address index table and setting the use count for this location to “one”. If the incremented current count is greater than the allowed maximum count for this symbol position, then this address cannot be encoded into the address index table and the management entity is notified that the address index table has overflowed unless another address is removed from the table making a use count go to “zero” and reducing the current count for this symbol position.</p>
    <p>(2) Continue processing address bit string symbols until the entire address has been encoded into the address index table by having for each symbol in the address a non-zero value for that symbol value location in every symbol position bank of the address index table.</p>
    <p>Address bit strings embedded in the incoming packets are compressed in the combine table outputs <b>70</b> and <b>72</b> in FIG. <b>2</b> and in arithmetic computation <b>102</b> of FIG. 3 to an integer value by adding together the stored values from the address index table bank for each symbol position where the symbol value is used as a location address into the bank for that symbol in the address index table. If any index table value accessed is zero, the processing stops and the zero detect <b>90</b> is activated. This zero indicates the address has not been encoded into the address index table.</p>
    <p>If the number of significant bits in the encoded integer are larger than the size of the compressed address directory <b>130</b>, then truncation <b>142</b> (removing some low order bits) and Modulo N hashing <b>144</b> (removing some of the high order bits) may be used to reduce the size of the encoded address integer to the number of locations in the compressed address directory <b>130</b>.</p>
    <p>To decode the original address from the encoded integer and to remove the encoded address from the address index table, the decoding process starts with the symbol position for which the Range value was set to the allowed maximum count and proceeds in the same symbol sequence as the Range values were computed.</p>
    <p>(a) Starting with the first range symbol position (the position that was set to the allowed maximum count), the encoded integer—before truncation or hashing—is searched in the low order bits for a value between 1 and the allowed maximum count for the symbol position. The result of this operation is the value obtained from the address index table for this symbol position and that table sub-index value was added to the integer value to create the final integer number.</p>
    <p>(b) The location for this remainder value in this symbol position bank of the address index table is found, the use count for this location is decremented by “one”, and the position of this location in the bank is the original symbol value for this symbol position. If the decremented use count is zero, then the current count is also decremented by one. If the current count reaches zero, then no addresses are encoded into this position in the address index table.</p>
    <p>(c) To decode the second symbol in the sequence of symbol positions used to compute the range values, the value from the previous operation is subtracted from the integer value. The resulting integer value is then searched for the low order bits for a sub-index value between the previous range value and this range value. This sub-index value is the value obtained from the address index table for this symbol position which was added to the integer value to create the final integer number. The location for this sub-index value in this bank of the address index table is found, the use count for this location is decremented by “one”, and the position of this location in the bank is the original symbol value for this symbol position. If the decremented use count is zero, then the current count is also decremented by one. If the current count reaches zero, then no addresses are encoded into this position in the address index table.</p>
    <p>(d) To decode each successive symbol in the sequence of symbol positions used to compute the range values, the sub-index value from the previous operation is subtracted from the integer value used in the previous operation. The resulting integer value is then searched in the low order bits for a sub-index value between the previous range and the current range for this symbol position. The resulting sub-index obtained with this operation is the value obtained from the address index table for this symbol position which was added to the integer value to create the final integer number. The location for this sub-index value in this bank of the address index table is found, the use count for this location is decremented by “one”, and the position of this location in the bank is the original symbol value for this symbol position. If the decremented use count is zero, then the current count is also decremented by one. If the current count reaches zero, then no addresses are encoded into this position in the address index table. This process is repeated until the integer value is reduced to zero.</p>
    <p>The sequence of symbol values produced are the symbol values used to encode the integer from the original address bit string. From these symbol values the original address bit string can be reconstructed by placing the symbol values in their symbol positions in the original bit string.</p>
    <p>Thus there has been disclosed a data communication system which uses a routing table access method that treats network addresses as variable length symbol strings without internal structure—i.e., as flat addresses—to simplify the handling of mobile end-systems simultaneously connected to multiple access points. The system utilizes high speed, Media Access Control and Internet processes which handle multicast messages to multiple, mobile hosts. The technique is also applicable to real time database applications such as a network name service which relates a logical name (alphanumeric name) to its universal identification code. For example, an automatic telephone directory service could use this system to enable entry of a particular name and receive the telephone number of that name. Thus, the novel system allows one entity having a universal identification number to communicate with any other entity in the system having a universal identification number but whose physical location is unknown. Because the Internet router system is based on a flat logical address space, it provides efficient routing of both multicast and unicast packets independent of the internal network address format or structure.</p>
    <p>Further, reversible arithmetic code compression techniques are used to reduce the size of the network address index and dynamic hashing is used to reduce the size of the routing table directory. Importantly, a message address is used that is structure-independent of the location or network attachment of the message receiver.</p>
    <p>Referring now to FIGS. 5-9, two additional methods of constructing index tables are disclosed.</p>
    <p>The routing table access method and apparatus described in connection with FIGS. 2-4 has, as already discussed, real time data base applications other than the date communications network of FIG. <b>1</b>. Those of ordinary skill in the art will readily recognize that the routing table access method and apparatus of FIGS. 2-4 describe an associative memory employed in context of a communications switching application. The possible applications of this same associative memory scheme are numerous and diverse; it is not confined to communications switching systems. For example, it has application in such diverse systems as those for on-line telephone directories, radar target tracking, and sonar signal classification—almost any system or application requiring or using high speed access to real-time databases where information is accessed with key values without knowledge of precisely where it is stored within a memory system. It is especially useful for systems utilizing very large key-spaces, when the number of keys that are actually used to access data records stored in memory constitute a fraction of the total number of possible keys. For these reasons, the two additional methods of constructing the index table will be described with reference to a generic application in a host system.</p>
    <p>Referring now to FIG. 5, this figure essentially illustrates the associative memory of FIG. 3, shown with the addition of learned logic <b>88</b> and <b>94</b> of FIG. <b>2</b>. The only difference between FIGS. 2 and 3 are the manner is which symbols comprising the addresses are processed: in parallel in FIG. 2; and in serial in FIG. <b>3</b>. The purpose of FIG. 5 is to introduce generic terminology for the associative memory of FIGS. 2-4. For example, the addresses, both destination and source, of FIGS. 2-4 are simply types of “keys”. A key is a unique string of bits that will be used to look up or access a “record” or a “key record”. The routing information or “address record” of FIGS. 2-4 is simply a type of “record”. A record is another, typically much longer and not necessarily unique, string of bits that the system in which the associative memory is located is trying to store, access, update or delete. In most applications, at least part of the key is found in the record. The key has a maximum predetermined length or number of bits, as previously explained, which are divided into “symbols” of predetermined length and positions. These symbols may or may not represent alphanumeric characters, as those of the ASCII code, or any other type of characters. The key, for example, may be part of a digitized waveform stored as a record. The symbols may also be overlapping—that is, share bits. There is no limitation on what the record and the key represent. They need only be a string of data values.</p>
    <p>An associative memory module <b>500</b>, a preferred embodiment of invention, is used with a host system. One such host system, embodying an associative memory module, is the communications switching apparatus of FIGS. 1-4. The associative memory module receives from the host system a key on input line <b>501</b> in a sequence of key symbols, Symbol[i], where i=1 to N and where N is the number of symbols in a key. Associative memory <b>500</b> processes one key symbol at a time. Associative memory module <b>500</b> may also be reconfigured to process all the symbols of the key at the same time, in parallel, as shown in FIG. <b>2</b>.</p>
    <p>A key symbol, when received, is stored in key symbol buffer <b>104</b>. Symbol counter <b>106</b> counts the symbols as they are received so that the position where the current symbol is stored in the key symbol buffer <b>104</b> is always known. The value of the symbol counter is the current symbol position “i”. As represented by block <b>503</b>, an address for index table <b>68</b> is generated from the position “i” and the value of the key symbol stored in the buffer <b>104</b>. The position of the symbol within the key taken from the symbol counter <b>106</b> selects a bank, Bank[i], in key index table memory <b>68</b>, and the value of the key symbol taken from buffer <b>104</b>, Symbol[i], is the offset address within the bank.</p>
    <p>Key index table memory <b>68</b> basically stores a table of values, called key index values. The memory storing this key index table must then be divided, either physically or logically, into banks <b>1</b> to N, as shown. Each bank is, in turn, divided, either physically or logically, into offset addresses that a predetermined number of bits that store a key index value. The size or number of bits addressed by the offset must be large enough to accommodate the size of index values stored therein, and the number of offset addresses depends on the size of the key symbols. The number and size of offset addresses depends entirely on the application.</p>
    <p>The index table memory <b>68</b> is any type of memory capable of, at minimum, storing a table of values: for example, a random access memory (RAM) or a read only memories (ROM). There is no inherent limitation of the storage media, whether it is electronic, magnetic, optical or some other type. Nor is there any limitation on the hardware configuration of the memory. The only limitation is that it can be addressed as just described, while, preferably, meeting desired performance criteria. Generally, a very fast memory is preferable so that keys are processed as rapidly as is necessary for the application. For example, where k number of bits are required for storing an index value, a single k-wide memory chip is likely to be the simplest and quickest way of implementing the index table memory, presuming the chip is large enough. Minimal address decode circuitry is required. On the other extreme, use extensive address decoding circuitry may slow performance. Cost, size, and durability constraints, restrictions posed by operating environment and many other design criteria associated with a particular application will determine what type of memory is best suited for implementing the index table. For example, where, as in several of the embodiments of the invention, data is written to the index table memory during processing of a key, the memory must be randomly accessed. Where index table memory is not updated, Read-Only random access memory may be used.</p>
    <p>The data value or index that is addressed is read onto line <b>505</b> to arithmetic computation logic circuitry <b>72</b>. Arithmetic computation logic is primarily comprised of a Modulo (P) adder, where P is approximately the number of logically addressable memory locations in key record memory <b>78</b>. In the preferred embodiment, P is chosen to be a prime number. Arithmetic computation logic circuitry <b>72</b> is initialized or set to zero before receipt of the first symbol in a key is presented on line <b>501</b>. As the index value is read onto bus <b>505</b> from the index table memory, symbol counter <b>106</b> provides an enabling or clock signal on line <b>507</b>. The enabling or clock signal from the symbol counter is delayed by delay device <b>509</b> by a time greater than the access time required for the index table memory <b>68</b> but less than the period between symbols presented on input bus <b>501</b>. When enabled, the arithmetic computation logic circuitry adds an index value on line <b>505</b> to a previously computed sum, in effect keeping running total. When the running total exceeds P, P is subtracted from the running total. The arithmetic computation logic circuitry thus performs a Modulo (P) addition of the index values stored in the index table memory for each symbol in the key to create a final sum called a record index. The record index is a data value that will be used as a logical address to the place within key record memory <b>78</b> in which the record corresponding to the key presented on input lines <b>501</b> is stored.</p>
    <p>Arithmetic computation logic circuitry also includes zero detect circuitry <b>90</b> for indicating that an index value received on line <b>505</b> from the index table memory <b>68</b> is zero. By definition, a zero value stored in an entry the index table for a symbol, as defined by its position within the key and its value, indicates that the symbol value has not been encoded into the index table and therefore no key record is stored in the key record memory <b>78</b> associated with the key that has been presented. The zero detect or “No Index” signal is provided on line <b>92</b> to the host system.</p>
    <p>The choice of zero as the value which indicates an index has not been assigned to that location in <b>68</b> is not critical to correct operation. Any bit pattern may be selected to indicate “no index” has been assigned. The index tables <b>68</b> are then initialized with that bit pattern and “zero detect” is changed to detect that pattern. Using bit patterns of all “zero” or all “ones” are convenient choices.</p>
    <p>Once the last symbol of the key is processed, the final sum or record index in the arithmetic computation logic circuit <b>72</b> is read to the record index buffer <b>74</b>, also called a key record memory address buffer. This value is the key record memory address that is presented on address lines <b>517</b> to key record memory <b>78</b> in order to access the record associated with that key. An enabling or clocking signal on line <b>513</b> causes the record index buffer <b>74</b> to store the record index and provide it on address lines <b>517</b> to the key record memory <b>517</b>. To generate the enabling or clocking signal on line <b>513</b>, the enabling signal provided to arithmetic computation logic circuit is divided by N, the number of symbols in the key, by divider circuitry <b>515</b>.</p>
    <p>Record memory <b>78</b> stores records of data that are accessed by presenting a key to the associative memory module <b>500</b> and decoding it into a record memory address as described above. Upon presentation to the record memory, the record memory address enables access of a record associated with the key and, with an appropriate read command (not shown) reads it onto output lines <b>519</b> to be stored by key record buffer <b>80</b> when enabled by a signal from delay element <b>515</b> (the delay element providing sufficient time for accessing the memory and reading out the record of data onto lines <b>519</b>).</p>
    <p>In essence, therefore, a record of data desired by a host system using the associative memory module <b>500</b> is accessed by presenting a key associated with that data and generating an address where the record is stored in a memory from a specially encoded index table <b>68</b>. The key is uniquely associated with that record of data, though the record of data is not necessarily uniquely associated with that key.</p>
    <p>How the record memory address is physically and logically constructed, as well as the form of the record memory address presented to the memory for access, are innumerable. The record memory address need only access the record of data associated with the key; how it does so depends on the memory chosen and the application. For example, the record memory address can be the actual physical address of the record where the memory bandwidth is equal to the largest size of any of the records stored. Where memory bandwidth is too small, the key memory address may be comprised of block-frame address, with a block-offset address being generated by separate circuitry (for example, a counter that would be included with the record memory <b>78</b>) that strobes block-offset address lines to read out the record of data. On the other hand, the record memory <b>78</b> may be constructed as a virtual memory of some type, where the record memory address is mapped to the actual location. The mapping circuitry is included within record memory <b>78</b>. A virtual memory implementation is generally not preferred, as this simply adds a second layer of mapping that slows access times. However, as the associative memory module <b>500</b> is designed to handle large numbers of keys, it may be desirable possibly to use it with some types of virtual memory.</p>
    <p>It should be further noted that the amount of memory space allocated for a record of data is usually fixed (though, if desired, it can be variable). If the record is too large, a pointer is stored in the record space pointing to the location of part or all of the actual record of data.</p>
    <p>No limitation is placed, as with like the index table memory <b>68</b>, on the actual hardware configuration or hardware of the key record memory <b>78</b>. Again, any media may be employed, preferably of a random access variety so that key records may be updated, added and deleted. However, some applications will need only ROM, which is generally faster. For reasons of speed, the type of memory should be chosen to have access times suitable to meet the particular application, subject to the limitations of space, cost, power consumption, heat dissipation, and durability.</p>
    <p>Where adding, deleting and updating records of data are desired, as with the communications system of FIGS. 1-4, several additional logic circuits are incorporated in the associative memory module <b>500</b>. These logic circuits may be dedicated circuits or programmable devices which implement the logical functions of the circuits. The host system for the associative memory module may also augment or be used in place of some or all of these devices to handle some or all of the processing that is carried out by this circuitry.</p>
    <p>To update a record already stored by record memory <b>78</b>, an “UPDATE” command on line <b>521</b> is presented to store record logic at the same time the record's associated key is placed on input key bus <b>501</b>. Store record logic <b>94</b> then writes the updated record stored by the host system in key record buffer <b>525</b> into record memory <b>78</b> at the record memory address generated from the key.</p>
    <p>Adding records and their keys requires that its key be “learned”. The key for the record to be added is presented to the associative memory module on input lines <b>501</b>; the record to be added is placed in key record buffer <b>523</b>; and an “ADD RECORD” command is given on line <b>517</b>. Each symbol of the key is processed as previously described. Frequently, at least one, and sometimes all but one, of the symbols in the key has already been encoded. If a symbol (as defined by its value and position within the key) has been encoded, learned key logic performs no function, and the key index values are read into arithmetic computation logic circuitry <b>72</b>. However, when zero detect circuitry <b>90</b> reads a zero on line <b>505</b> from the key index memory <b>68</b>, a zero detect signal is provided on line <b>92</b> to learned key logic <b>88</b>, as well as to the host system as a “No Index” signal. This “no index” or zero detect signal means that the table entry—the symbol position and value—contains a zero. At this point, learned key logic circuitry <b>88</b> generates a new key index value and provides it to key index table <b>68</b> on write index bus <b>520</b>. The index table memory then stores it in the entry of the key index table memory indicated by table address <b>503</b>. As will be discussed in connection with the remaining Figures, learned key logic circuitry <b>88</b> requires, in order to generate the new index value for the key symbol, the key symbol value and position, and index values on read index line <b>505</b>. Therefore, learned key logic is coupled to the key symbol buffer <b>104</b>, the symbol position counter <b>106</b>, and read index bus <b>505</b>.</p>
    <p>Processing the key symbols presented on lines <b>501</b> then continues as before, with learned key logic generating new key indexes as necessary. When all of the symbols of the key have been processed, and their corresponding key index values added to a record index value <b>74</b> by the arithmetic computation circuitry <b>72</b>, the record in buffer <b>523</b> is stored in the key record memory <b>78</b> at the location indicated by the record index.</p>
    <p>To delete records, the host system presents a “DELETE RECORD” command on line <b>519</b>. To perform the delete function, the key must be presented on input key bus <b>501</b>. Learned key logic <b>88</b> then deletes any key index value that is being used only by the key associated with that record by writing a zero into the table entry with write index bus <b>520</b>. Deleting any unused index values permits them to be reused for the un-encoded key symbols that may be subsequently presented, thereby providing more efficient use of the record memory <b>78</b>. The “deleted” record is simply overwritten with a new record when one is presented.</p>
    <p>Please note that where an ability to add, delete and update records is not desired, learned key logic circuitry is not necessary. All that is required is an encoded index table memory <b>68</b>, arithmetic computation circuitry <b>72</b>, key record memory <b>78</b> written with all of the records and suitable timing circuits and buffers. The index values that are stored in the index table memory <b>68</b> may be generated separately on a general purpose digital computer, from a known set of keys, and then stored in the memory. One of these methods for doing so has already been described in connection with FIGS. 2-4. Other methods will be described in connection with the remaining figures. If the index table memory is a ROM, for example, the index values are stored in the manner provided by the ROM device.</p>
    <p>Referring now to FIG. 6, learned key logic circuitry <b>88</b> includes three main components: add key logic circuitry <b>601</b>; symbol use count logic circuitry <b>603</b> and delete key logic circuitry <b>605</b>.</p>
    <p>The function of add key logic circuitry is to generate new keys that are provided to write index bus <b>520</b> for storing in the key index table memory <b>68</b> (FIG. <b>5</b>). In one embodiment, add key logic recycles key symbols to key symbol buffer <b>104</b> with bus <b>609</b>. Add key logic is coupled to symbol counter <b>106</b>, key symbol buffer <b>104</b>, read key index bus <b>505</b>, zero detect line <b>92</b> and “ADD RECORD” command line <b>517</b> so that it receives the current key symbol position or count, key symbol value and key index in addition to the zero detect and add command. Add key logic provides an increment (INC) command on line <b>607</b> to symbol use count logic <b>603</b> for each key symbol presented on line <b>501</b> during an add key operation.</p>
    <p>Symbol use count logic <b>603</b> tracks for each key symbol value and position, or entry in the key index table memory <b>68</b>, the number of different keys that share that particular symbol value and position. Symbol use count logic receives the symbol value and symbol position from key symbol buffer <b>104</b> and symbol counter <b>106</b>, and the increment command signal from add key logic on line <b>607</b>. A key index value for a particular symbol that is shared by more than one key cannot be deleted. If symbol use count logic circuitry indicates that a particular symbol has been encoded into the index table for only one key, then delete key logic circuitry <b>605</b> writes a zero to the write index bus <b>520</b>.</p>
    <p>Referring now to FIG. 7, symbol use count logic circuit <b>603</b> tracks the number of times a particular symbol, Symbol[i] in a particular symbol position or bank i, is used by different keys. The key index value assigned to Symbol[i], INDEX[i,Symbol[i], can be deleted when it is no longer being used by any key. Essentially, it uses a symbol use count table memory <b>801</b> that is constructed and addressed like the key index table memory <b>68</b> (FIG. <b>5</b>). As indicated by summer <b>802</b>, values in symbol counter <b>106</b> and key symbol buffer <b>104</b> are used as bank and offset addresses, respectively, to a particular table entry for the key currently being processed. The data value stored in each entry is the number of keys that are currently encoded that share or use the value Symbol[i] in position i.</p>
    <p>When the table memory <b>803</b> is addressed, the use count for Symbol[i] is read into counter <b>803</b>. When a key is being added, the value in counter <b>803</b> is then incremented by one with an INC command signal on line <b>707</b> from an add key logic circuit. In essence, this counts the number of times a particular symbol[i] has been presented to the associative memory as part of a key that is being added. When a record is being deleted, counter <b>803</b> is decremented by one with the delete record command on line <b>519</b>.</p>
    <p>After expiration of a period of time allowed for the step of incrementing or decrementing, the value in the counter <b>803</b> is written back into the table memory <b>801</b> at the same table address. It is, further, read by zero detect circuit <b>805</b>. If a zero count is detected during a delete record operation, a logic signal on line <b>807</b> goes high. This signal and the delete record command on line <b>509</b>, also a logic high signal, are provided to AND gate <b>809</b>, which is part of delete key logic circuit <b>605</b>. Both signals going high causes a zero to be written on to write index bus <b>520</b> by circuit <b>811</b>.</p>
    <p>Referring now to FIGS. 8 to <b>13</b>, these figures disclose a third method (in addition to the methods previously described in connection with FIGS. 2-4) of adding keys (the actual records may be stored later) using a different add key logic circuit. Basically, this method or process assigns key index values for key symbols when keys are presented in a monotonically sorted or lexigraphical order (either ascending or descending) for entry into the associative memory. The sorted order of the keys helps to eliminate “holes” for possible combinations of key symbols which are not presented in a sorted order or sequences, creating a near “perfect hashing” or “perfect packing”. Should a key be presented whose sum of key index values is the same as the sum of key index values for a previously entered key, current or previous key index value assignments are changes, and any previously stored key records are moved in memory to create a “hole” for the new key. The adding process is completed when the highest or last record memory location is filled.</p>
    <p>Referring now to FIG. 8 only, showing in schematic representation a dedicated circuit embodiment utilizing this method, add key logic circuitry <b>601</b> includes as major components: save table <b>901</b>; change table <b>903</b>; create index values logic circuit <b>905</b>; change old value logic circuit <b>907</b>; save new index logic circuit <b>909</b>; and a directory table <b>911</b>. The save table <b>901</b>, change table <b>903</b> and directory table <b>909</b> are data structures stored in a random access memory. The logic circuits <b>905</b>, <b>907</b> and <b>909</b> are shown to be dedicated circuits (possibly LSI or VLSI devices), but may implemented with programmed logic devices, general purpose computers, a microprocessor, or a combination of these performing the steps of the method.</p>
    <p>Both the save table and the change table have one row of values for each symbol position i in a key, i=1 to N, as shown by symbol position columns <b>913</b> in each table. Symbol counter <b>106</b> is therefore used to select a row in the save table, identified as Save[i], and in the change table, identified as Change[i]. Each table has three additional columns for storing values associated with Save[i] and Change[i]. The save table keeps values of the symbols for the current key being added.</p>
    <p>In the save table <b>901</b>, column <b>915</b> stores a value Save[i].symbol. This value is set equal to the symbol value, Symbol[i], from symbol buffer <b>104</b>. Thus, Save[i].symbol=Symbol[i]. Column <b>917</b> receives from the key index table on read key index bus <b>505</b> an index value for Symbol[i], Index[i,Symbol[i]], and stores it. The column <b>919</b> receives the zero detect logic signal on line <b>92</b> and stores a value for a variable Save[i].new. This value is “new” (actually a data value arbitrarily chosen to represent “new”) when a zero detect signal is received, indicating that the value for Save[i].index is new and that Symbol[i] had not been previously encoded into the key index table memory. Thus, Save[i].new=new. Otherwise, a data value representing “old” is stored: Save[i].new.=old.</p>
    <p>Symbol position counter <b>106</b> selects a row of the Save table corresponding to the key symbol position currently being processed. Selection enables the values in each column of the selected row to be accessed (read and written to) with bus <b>920</b>.</p>
    <p>The change table <b>903</b> keeps information on the last index values assigned for each symbol position to allow “holes” to be made for new keys and to move any records if required.</p>
    <p>The change table <b>903</b> stores the previous symbol, record index and key index values for each symbol position [i] that are need to generate the next key index values for the next new key presented to the associative memory. Change table <b>903</b> therefore has three columns, one for the last assigned values of the following variables or data elements: for the record index value, Change[i].record; for the key index value, Change[i].index; and for the symbol value, Change[i].symbol. Like the Save table, the symbol position counter selects the row in the table, enabling entries on that row to be accessed (for reading and writing) by bus <b>922</b>.</p>
    <p>A directory table <b>923</b> is also kept. A row of the table is selected with a data value generated by create index values logic <b>905</b> and save new index logic <b>909</b>. This value is notated simply as “sum”, as it is a sum of all of the key index values for a key that is being processed. The number of rows in the table equals the number of record locations in record memory <b>78</b>. The value “sum” is in fact equivalent to the record index value for the key being processed. Each row of the table has one entry, Change[sum].dir, for each record location in the record memory, sum=1 to P. This entry has one of two values; one representing the location is “assigned” and the other indicating the location is “unassigned”. This data structure may be set up in any memory element in the associative memory or host system. It can even be made part of the record memory <b>78</b> (FIG. <b>5</b>).</p>
    <p>Coupled between buses <b>920</b> and <b>922</b> are create index logic <b>905</b>, change old index logic <b>907</b> and save new index logic <b>909</b> which permit the logic elements to read and write values to the respective tables. Please note, however, the buses <b>920</b> and <b>922</b> are merely a functional representation, intended to simplify presentation. The actual data exchange structures between the different elements of add key logic <b>601</b> may differ substantially depending on the memory and logic elements selected to implement the data structures of the tables and the logic. For example, when implemented on a specially programmed general purpose digital computer, the data exchange structures will be those of the particular computer chosen.</p>
    <p>Save new index logic <b>909</b> is further coupled to the write key index table bus <b>520</b> so that new index values can be stored in the key index table memory <b>68</b>, as well as to key symbol buffer for recycling key symbol values.</p>
    <p>Referring now to FIGS. 8 and 9, illustrated is a flow diagram describing the operation of create index value logic <b>905</b>. Create index values logic <b>905</b> may be implemented with either dedicated circuitry or programmable logic circuitry, possibly shared with the other logic circuits in the associative memory module, or some combination of the two. In the latter case, the steps of the flow diagram would be implemented with programmed instructions.</p>
    <p>At start-up of the associative memory, as indicated by circle <b>1001</b>, all logic components are reset at step <b>1003</b>, and all tables initialized to zero (written with all zero values) at step <b>1005</b>. Step <b>1005</b> includes setting Index[i,Symbol[i]] to zero, for all i and Symbol[i]. When the host system presents a new key for addition or encoding into key index table memory <b>68</b> (FIG. <b>5</b>), it signals at step <b>1007</b> that a new key is being presented on key symbol bus <b>501</b> (FIG. 5) and the create new index value process begins. Step <b>1009</b>, (FIG. 8) indicates when each symbol within the key is presented for processing as indicated by the symbol count being greater than zero. When a symbol is presented, the create new index value process continues to decision step <b>1011</b>. If the new symbol is the first symbol of the key, then Sum is set equal to zero and i equals one. Further, a variable Any_New is set equal to “old”. Any_New is subsequently set to “new” if any Save[i].new=“new” from i=1 to N. In other words, “new” is entered in the new column <b>919</b> for any symbol position in the Save table; otherwise it is “old”. Any_New is a flag which indicates that one or more of the Save [i].new values is set to “new”.</p>
    <p>At decision block <b>1015</b>, if the key being presented to the associative memory is to be added, as indicated by the Add command signal on line <b>517</b> (FIG. 6) being turned on, create index logic performs the steps outlined in block <b>1017</b>. If the key is not being added, the created index value process ends. The process steps of block <b>1017</b> involve setting the Save table entry Save[i].symbol equal to the symbol value Symbol[i] from the key symbol buffer <b>104</b> (FIG. <b>6</b>).</p>
    <p>Create index value logic next reads, as indicated by decision block <b>1019</b>, the index value, Index[i.Symbol[i]], from the read index bus <b>505</b> (FIG. <b>5</b>), and if it is equal to zero, proceeds to the process steps of block <b>1023</b>. These steps include setting Save[i].index=Change[i].index+1; Any_New=“new”; and Save[i].new=“new”. Otherwise, the steps of block <b>1021</b> are undertaken: setting Save[i].index=Index[i,Symbol[i]]; and Save[i].new=“old”.</p>
    <p>After either the steps of block <b>1019</b> or block <b>1021</b> are performed, as the case may, the value assigned to the variable Sum is updated to Sum=Sum+Save[i].index at block <b>1025</b>, and i is incremented by one, i=i+1. If i is less the N, the number of symbols in a key, then the steps indicated by blocks <b>1011</b> to <b>1025</b> are repeated. Once i=N, then create index value logic signals change old index logic <b>907</b> (FIG. 8) and passes the current value for Sum, as represented by blocks <b>1029</b> and <b>1031</b>. The process of create index logic then ends until a new key is presented.</p>
    <p>Referring now to FIGS. 9 and 11, if the sum of the record index values is a record index value addressing a location in record memory <b>78</b> (FIG. 5) already having a key assigned to it, then this new key cannot be entered until either the previous key is moved to a new location or the new key's sum is increased until an unassigned location is found. Either of these moves are accomplished by increasing the value of an index value assigned to some previous key and also used by the new key being processed or increasing the value of an index newly assigned to this key.</p>
    <p>First, change old index logic <b>907</b> checks to see if the sum of the Index values for the new key, the sum of Index[i,Symbol[i]] from i=1 to N has been assigned. To do this, change old index value logic gets the value for Sum for create index logic <b>905</b> on bus <b>922</b>. As indicated by decision block <b>1103</b>, change old index value logic selects from the directory table <b>923</b> using the select line <b>925</b> the value for Directory[sum], which then reads this value out onto bus <b>922</b> for retrieval by change old index logic. If Directory[sum] equals “unassigned”, this indicates that the index values for the new key sum to a record index that has not previously been assigned to a key. Change old index logic then determines whether Any_New=“new”, as indicated by decision block <b>1105</b>. If Any_New=“old”, the process ends. If Any_New=“new”, then save new key logic <b>909</b> is signalled to begin and the value for the variable Sum passed to it, as indicated by blocks <b>1107</b> and <b>1109</b>, and the process carried out by change old index logic ends.</p>
    <p>If, on the other hand, Directory[sum] is assigned, the process of change old index logic continues at decision block <b>1111</b>. If Any_New=“old”, a previously assigned index value must be increased to make a “hole” for the new key. The process proceeds to the steps shown in FIG. 11, which are discussed in connection with that figure.</p>
    <p>Otherwise, if Any_New=“new”, indicating that one of the index values for the current key was newly assigned or created by create index value, this new index value is incremented by one, thereby incrementing Sum until an “unassigned” location in the Directory table, Directory[sum]=“unassigned”, is found. An “unassigned” value indicates that the that a record memory location addressed by the a record index value equaling Sum has not been assigned to a key and is available for storing a record associated with the new key.</p>
    <p>The steps for increasing the newly assigned index value are carried out by a loop shown between blocks <b>1113</b> to <b>1121</b>, the loop being repeated for each symbol position i from i=1 to N, as indicated by block <b>1113</b>. First, the value of Save[i].new is tested for whether it is “new” or “old”, as shown by block <b>1115</b>. If it is “old”, the process moves to the step of block <b>1117</b>, where i is incremented by 1 or, if i=N, is set equal to 1, and the loop restarts by returning to block <b>1113</b>. If Save[i].new=“new”, the process moves to steps shown by block <b>1119</b>. There, Save[i].index and Sum are incremented by one, and i is also incremented by 1 unless i=N, then it is set equal to 1. The incremented Sum value must be tested to see if it has been assigned; as shown in block <b>1121</b>, whether Directory[Sum]=“assigned”. If it has been “assigned”, the loop must continue at block <b>1113</b>. If unassigned, the new index value is saved by signalling save new index value logic <b>909</b> and passing the Sum value on line <b>926</b>, as indicated by blocks <b>1123</b> and <b>1125</b>.</p>
    <p>Referring now to FIGS. 8 and 10, where Directory[Sum]=“assigned” and Any_New=“old” at steps <b>1103</b> and <b>1111</b> in FIG. 10, the processes of change old index logic <b>907</b> carry on by increasing a previously assigned index value in order to make a “hole” in the record memory for the record associated with the new key. Three additional variables are required to continue the change old index value process. Directory_Position is a pointer to the Directory table <b>923</b> that will point to the record memory location at which the hole is made. Symbol_Position keeps track of the symbol position of the index value which will be increased to make a hole. As indicated by block <b>1201</b>, Directory_Position is initially set equal to Sum, and Symbol_Position is set equal to 0.</p>
    <p>Starting with block <b>1203</b>, a loop begins that is designed to find an index value in the change table <b>903</b> that was previously assigned to one of the symbols of the key currently being processed. To do this, the loop begins at i=1 and compares Change[i].Symbol in the change table and Save[i].symbol in the save table to see if Change[i].Symbol=Save[i].Symbol, as shown in block <b>1205</b>. Where Change[i].Symbol=Save[i].Symbol, two other conditions are tested. First, Change[i].record, the record index value or Sum at the time the Symbol[i] was assigned, is compared against the current Sum, as shown in block <b>1207</b>. Second, it is compared with Directory_Position, as shown by block <b>1209</b>. If Change[i].Symbol is greater than both, then: in block <b>1211</b>, Symbol_Position is set equal to i and Directory_Position is set equal to Change[i].Record; and, in block <b>1213</b> and decision block <b>1215</b>, i is incremented by one and the loop repeated until i=N. Otherwise, the steps of block <b>1211</b> are not performed and the loop repeated for i=i+1 until i=N. In effect, this loop is not only trying to find an index value in the save table having a symbol shared by the current or new key, it also finds, where there is more than one such symbol, the index value that, when assigned, had the largest record index value. The Directory_Position variable keeps track of the largest record index value found as the loop is performed.</p>
    <p>At the termination of this loop, change old index logic tests, at decision block <b>1217</b>, whether the final value for Directory_Position is greater than Sum. If not, then this new key was not in a sorted order with respect to previously presented keys and an error message is flashed to the host system, as indicated by block <b>1219</b>. Otherwise, it continues to another loop, starting with by block <b>1220</b>.</p>
    <p>Before beginning this loop, a variable Increase is set equal to 1, as shown in block <b>1222</b>. The value of increase is the number by which the records in the record memory must be moved to create the “hole”. The first step in the loop is to increase Sum by one, as shown in block <b>1221</b>. Next, at block <b>1223</b>, Sum is compared against Directory_Position. If it is less than Directory_Position, Directory[Sum] is looked up in the Directory table <b>923</b> to see if that record index has been assigned, as indicated by decision block <b>1225</b>. If it is assigned, one is added to the value of Increase, as shown in block <b>1227</b>. The loop repeated until Sum is either equal to Directory_Position or Directory[Sum] is “unassigned”.</p>
    <p>Referring now to FIG, <b>12</b>, once the processes of FIG. 12 are complete, change old index logic then signals store record logic <b>94</b> (FIG. <b>5</b>), as indicated by block <b>1301</b>, and passes to stored record logic the values for Directory_Position, Increase and Last Assigned (a value is assigned to this variable by save new index logic as shown in FIG. <b>13</b>). Store index logic utilizes these values to move a block of records within the record memory <b>78</b> (FIG. 5) addressed by record index values between Directory_Position and Last_Assigned to new a new block of locations addressed by record index values from Directory_Position+Increase to Last_Assign+Increase, thereby making the “hole” in the record memory for storing the record associated with the new key.</p>
    <p>Change old index value logic then updates the Save table and the Last_Assigned variable. “i” is set equal to Symbol_Position, and Save[i].Index=Change[i].Index+Increase, Save[i].New=“new”, and Last_Assigned=Last_Assigned+Increase, all as shown in block <b>1303</b>. Then, as indicated by blocks <b>1305</b>, <b>1307</b>, and <b>1309</b>, a loop is performed for each i beginning with i=Symbol_Position+1 and continuing to i&gt;N to update the Change table to reflect the movement of the records in the record memory by store record logic, particularly Change[i].Record. To do this, the loop tests Change[i].Record, as shown in block <b>1311</b>, to see if it is greater or equal to Directory_Position. If so, the step of block <b>1313</b> is performed, setting Change[i].Record=Change[i].Record+Increase.</p>
    <p>After completion of the loop at block <b>1309</b>, change old index value logic signals save new index value logic on line <b>926</b> and passes Sum, as shown by blocks <b>1315</b> and <b>1317</b>.</p>
    <p>Referring now to FIGS. 8 and 13, processes of save new index logic <b>909</b> begin with block <b>1401</b>, in which i=1 and Symbol Count=0. The remaining process steps are part of a loop that is set up by steps shown in blocks <b>1403</b>, <b>1405</b> and <b>1407</b> and repeated for each i, from i=1 to N. The loop therefore essentially sequences through each symbol position in the Save table <b>901</b>. For each symbol position, it reads the symbol value, Save[i].Symbol, from the Save table and writes it to symbol buffer <b>104</b> using bus <b>929</b>, as described in block <b>1409</b>. Writing the symbol value to the symbol buffer <b>104</b> also strobes the symbol counter <b>104</b>, as indicated by line <b>931</b>. After a delay, indicated by block <b>1411</b>, the value in symbol buffer <b>104</b> is tested against the value of Save[i].Symbol to ensure that the value of Save[i].Symbol has been placed in the symbol buffer, as shown in block <b>1413</b>.</p>
    <p>If, as indicated by decision block <b>1415</b>, the symbol position i has a new index value, Save[i].new=“new”, then the new index value is stored in the index memory <b>68</b> (FIG. 5) by simply writing it write index bus <b>520</b> (the symbol counter and symbol buffer already are set to select the correct symbol position and value entry). The new index value is also stored in the Change table <b>903</b>. Save new index logic further stores the symbol value and Sum, the sum of the index values, in the change table. These steps are shown in block <b>1417</b>, and described as: Index[i,Symbol[i]]=Save[i].Index; Change[i].Record=Sum; Change[i].Index=Save[i].Index; and Change[i].Symbol=Save[i].Symbol. The variable Last_Assign is also set equal to Sum, as indicated in block <b>1419</b>, but only if Sum is greater than Last_Assign. Otherwise, it remains unchanged.</p>
    <p>If Save[i].new=“old”, then the steps of block <b>1417</b> are not performed, as there are no new index values that need to be updated. As shown in step <b>1421</b>, only Change[i].Record needs to be updated by setting it equal to Sum, but only if Change[i].Symbol=Save[i].Symbol and Change[i].Record&gt;Sum.</p>
    <p>When i&gt;N, the processes of save new index logic <b>909</b> exit the loop and signal the host system that the new key has been added, as indicated by block <b>1423</b>. The value of variable Last_Assigned is passed to change old index logic <b>907</b> on line <b>927</b>, as indicated by block <b>1425</b>. This then completes the processes for adding a key according to a third method for keys presented in sorted order to the associative memory module <b>500</b> for adding. Further keys are added in the same manner.</p>
    <p>Referring now to FIGS. 3, <b>7</b> and <b>14</b>, there is illustrated the hardware and a flow diagram required for the assigning of index values to an entire key-set group using an alternative method for assigning index values. The use-count table (<b>801</b> of FIG. 7) is updated as a set of keys are presented to the system. Before the process of updating the use-count table begins, all positions within the use-count table are reset to zero or a null value at step <b>1500</b>. The first key is then presented at step <b>1502</b> to the system logic and the first symbol of the key is read at step <b>1504</b>.</p>
    <p>At step <b>1506</b>, the USE COUNT for the symbol value in the present symbol position is incremented by one to indicate a use of the symbol value. Next, a determination is made at step <b>1508</b> as to whether the final symbol has been presented for a key. If the last symbol has not been presented, control passes to step <b>1504</b> and the next symbol is read. If the last symbol for the key has been presented, step <b>1510</b> determines if another key is to be presented to the control logic. If another key is to be presented, control passes back to step <b>1502</b>. Otherwise, control will pass to step <b>1512</b>.</p>
    <p>At step <b>1512</b>, the BASE value for the least significant symbol position is set equal to one. For each subsequent symbol position or bank, the base value will equal the maximum index value for the previous symbol position. The CURRENT COUNT for the symbol position is then set equal to one at step <b>1514</b>. The control logic scans at step <b>1516</b> the least significant bank values of the use count table. The first symbol value entry for the bank is read at step <b>1517</b>. A determination is made at step <b>1518</b> if the initial use count table entry is greater than zero. If the entry is not greater than zero control passes back to step <b>1517</b> and the next symbol position for the present bank in the use-count table is read. If the value is greater than zero, an index value is assigned to the symbol at step <b>1520</b> and placed in the corresponding bank and position in the index table <b>98</b> of FIG. <b>3</b>.</p>
    <p>An inquiry at step <b>1540</b> determines if another symbol value exists for the present symbol position. If so, the CURRENT COUNT is incremented by one at step <b>1542</b> and control returns to step <b>1517</b>. When no further symbol values exists in the current bank, the control logic looks for the next bank at step <b>1546</b>. If another bank exists, the BASE value is set equal to the present BASE value times current count at step <b>1548</b> and control returns to step <b>1514</b>. Otherwise, all index values for the keys have been assigned and the process is complete.</p>
    <p>Referring now to FIGS. 7, <b>15</b> and <b>17</b> another process is illustrated for assigning index values to symbols for an entire key set. Initially all index-value tables and use-count values are reset to zero or a null value at step <b>1600</b>. This includes initializing values in the maximum suffix table <b>1910</b> to the minimum suffix symbol string and initializing the minimum suffix table <b>1920</b> values to the maximum suffix string. Next, a key is presented at step <b>1602</b> to the control logic and the first symbol of the key is read at step <b>1604</b>. The use count for the read symbol value at the present symbol position is incremented at step <b>1606</b> to indicate a use of the symbol value at the symbol position.</p>
    <p>An inquiry is made at step <b>1608</b> to determine if the suffix of the present symbol is greater in the collating order than the stored MAX SUFFIX. The suffix of a symbol in a key is the key ordered sequence of all the symbols of lower collating value than the current symbol. For example, the suffix of 3 in the key 12345 is 45 and the suffix of B in key ABCDE is CDE. The suffix relative size determination is based on the collating order of symbol in the suffix and not the index value. If the current suffix exceeds the previously stored MAX SUFFIX in collating order, the MAX SUFFIX is set equal to the present suffix at step <b>1610</b> and stored in the max suffix table <b>1910</b> (FIG. <b>18</b>).</p>
    <p>Should the suffix be less than MAX SUFFIX in collating order or after MAX SUFFIX is set equal to the present suffix, control passes to step <b>1612</b> where an inquiry is made to determine if the present suffix is less than the previously stored MIN SUFFIX symbol string. If so, at step <b>1614</b> the MIN SUFFIX is set equal to the present suffix symbol string and stored in the min suffix table <b>1920</b> (FIG. <b>18</b>). Otherwise, step <b>1616</b> determines if another symbol value exists within the present key. If another symbol exists, the next symbol is presented to the control logic at step <b>1604</b>; if not, step <b>1618</b> determines if another key must be presented to the control logic. Additional keys return control to step <b>1602</b>.</p>
    <p>Once all keys have been presented to the use count table <b>801</b> of <b>8</b> and <b>18</b>, max suffix table <b>1910</b> of FIG. 18, and min suffix table <b>1920</b> of FIG. 17, control passes to step <b>1620</b> to begin the process of assigning index values to the key symbols. The use count table <b>801</b> of FIG. <b>7</b> and FIG. 18 stores integer count values. The max <b>1910</b> and min <b>1920</b> suffix table memories store symbol sequences. At step <b>1620</b>, the base value for the least significant symbol position is set equal to one and the value for LAST NON-ZERO ENTRY is set equal to zero. Next at step <b>1622</b>, the value for CURRENT COUNT is set equal to one. The least significant bank in the use-count table is scanned at step <b>1624</b>. The initial symbol value in the bank is read at step <b>1626</b> and an inquiry is made at step <b>1628</b> to determine if the first symbol value use-count number is greater than zero. If not, control returns to step <b>1626</b> and the next symbol value in the bank is scanned. Otherwise, an inquiry is made at step <b>1630</b> to determine if the LAST NON-ZERO ENTRY value is greater than zero. If not, the symbol value is assigned an index value of one at step <b>1632</b>, LAST MAX SUFFIX is set at step <b>1633</b> equal to a null string, the CURRENT COUNT is incremented at step <b>1634</b> and the LAST NON-ZERO ENTRY value is set equal to one at step <b>1636</b>. Control then passes back to step <b>1626</b> and the USE COUNT value of the next symbol value in the use-count table is read.</p>
    <p>If inquiry step <b>1630</b> determines the last non-zero value is greater than zero, the symbol position is assigned at step <b>1632</b> an index value according to the following equation:</p>
    <p> Index value=last non-zero index value+max suffix index value for the last non-zero index value−min suffix index value for the present symbol value.</p>
    <p>The max suffix and min suffix index values are equal to the sum of the index values of the key symbols comprising the suffix. The CURRENT COUNT is incremented and the LAST NON-ZERO ENTRY value is set equal to the present index value at step <b>1634</b>. At <b>1643</b>, the last max-suffix value is set equal to the max-suffix value for the current position. The max and min suffix values for the least significant symbol position or bank are both zero.</p>
    <p>Inquiry step <b>1636</b> determines if the last symbol value for the bank has been scanned. If not, control returns to step <b>1626</b> and the next symbol value is read. If the last symbol value has been read, step <b>1638</b> determines if another symbol position exists in the use-count table and if so returns control to step <b>1622</b>; otherwise, the procedure is completed and all the symbol values have been assigned an index value.</p>
    <p>Referring now to FIGS. 7, <b>16</b> and <b>19</b> there is described a method for incrementally updating the index tables and directory table of the present invention. This dynamic directory sizing process allows the number of non-zero entries in the index value tables to expand and contract as new keys are added or deleted and to minimize the size of the directory. This method expands the ADD KEY and DELETE KEY logic (<b>601</b> and <b>605</b> of <b>88</b> in FIG. 6) processes earlier described. The USE-COUNT logic (<b>603</b> in FIGS. 6 and 7) remains the same. As before, the ADD-KEY logic will only operate when the ZERO DETECT (<b>92</b> of FIG. 6) indicates that a symbol value location in a bank of the index value table has no index value assigned or the compare keys (<b>2009</b> of FIG. 19) indicates a key mismatch. When the ZERO DETECT or key mismatch is indicated, the ADD KEY logic <b>601</b> activates the ADD-NEW-SYMBOL process. The ADD-NEW-SYMBOL process produces a non-zero index value for a symbol value which previously had a zero or null index value or in which the count flag was zero. In addition, the ADD-NEW-SYMBOL process increases the higher order index values above the new index value.</p>
    <p>The ADD-NEW-SYMBOL process operates as illustrated in FIG. <b>17</b>. First, several parameters are initialized at step <b>1700</b> to track the symbol positions within the index value table and directory table. The size of the spaces to be left to accommodate the new symbol value is calculated and set equal to NEW SIZE. NEW SIZE equals the base value of the bank where the partition point will occur. The size of the directory block to be moved, BLOCK SIZE, is set equal to the maximum index value in the bank were the partition point will occur before the index values are changed. The number of BLOCK SIZE directory blocks to be moved is calculated by dividing the size of the old directory by BLOCK SIZE. This value is set equal to NUMBER OF BLOCKS.</p>
    <p>Next, the partition point within the bank where the new symbol value will be added is determined at step <b>1702</b>. When count flags are used, the compare keys logic <b>2009</b> of FIG. 19 compares the new key with the stored key and provides the learned key logic <b>88</b> with the symbol positions and symbol values that are different between the two keys. One of the symbol positions is selected and the symbol value having a count flag equal to zero has its count flag set to one. At least one of the two symbol values must have its count flag set to zero or the symbols would not have the same index value.</p>
    <p>The partition point is the point at which any pre-existing index values will be lower in symbol value than the new symbol to be added. The partition point is determined by counting the number the of non zero count flags or non-zero index values from the beginning of a bank to the new symbol value including the new symbol value. When non-zero index values are counted, this count value is multiplied by the base of the present bank. The product is the index value for the new symbol. When count flags are used, the index value is already assigned to the partition point location in the index table. The new index value(s) within a bank is assigned at step <b>1704</b> by increasing each non-zero index value located higher in the bank by the base value for the bank. The symbol value of the partition point is saved in a register PARTITION SYMBOL and the index value for the partition point is saved in PARTITION INDEX.</p>
    <p>At step <b>1706</b> new base values for banks above the partition point in the collating sequence are computed based upon the added symbol value where a present base value equals the previous base value times the number of non-zero index values in the present bank. Then the size of the new directory is computed at step <b>1707</b> as the new base value for the most significant symbol position times the number of non-zero index values in that bank or symbol position. This is the same as the largest new index value in that bank.</p>
    <p>Next, memory space is appended to the top of the old directory at step <b>1708</b> to accommodate the new symbol value within the new directory. The amount of memory appended equals the new directory size minus the old directory size. First, the block between the top of the old directory and the index value of the next non-zero count flag above the partition point are moved at step <b>1709</b> from the old directory location to the end of the new directory location. The size of the first block equals the number of non-zero count flags or index values above the partition point to the end of the bank multiplied by the base value for the bank. The result is saved as ABOVE COUNT.</p>
    <p>At step <b>1710</b>, the key values in each of the NEW SIZE locations just below the block in the old directory moved at either step <b>1709</b> or <b>1712</b> are examined to determine if the symbol value at the partition point is greater than the PARTITION SYMBOL value. If the stored key symbol has a symbol value greater than PARTITION SYMBOL, the record associated with the key symbol is moved up from its current location in the old directory to the corresponding point in the NEW SIZE hole below the block just moved at either step <b>1709</b> or <b>1712</b>. If the symbol value is equal to or less than PARTITION SYMBOL the record is left in its present position in the old directory. This process creates a hole below the previously moved block with selected records moved into the hole in the new directory table at step <b>1710</b>. The hole size is equal to NEW SIZE. This hole accommodates entries using the new symbol value, including those which already used that value if count flags are used. At the end of the hole, another block of directory locations are added to the new directory at step <b>1712</b>. The size of this block equals BLOCK SIZE. This next block to be moved starts at the next location below the last location of the previous block moved from the old directory to the new directory by either step <b>1709</b> or <b>1712</b>.</p>
    <p>The elements of each block moved are selected in descending order between partition points in the old directory. An inquiry step <b>1714</b> determines if the final old directory block has been reached. The final block is already stored at the correct location in the new directory if the same memory location is used for both the new and old directory. If not the final block, the next new index value space of block size is skipped at step <b>1710</b>. The size of the final directory block equals BLOCK SIZE minus the size of the first block. This process of moving directory records from the old directory to the new directory allows the new directory to be built on top of the old directory location.</p>
    <p>Finally, at step <b>1718</b> the new index values for the symbol positions in the banks following the partition point are calculated using the new base values. The new index values are assigned by assigning the base value to each location in the bank from the first location up to and including the first location having a non-zero count flag or a non-zero index value. After each non-zero count flag or non-zero index value location, the index value assigned is increased by adding one more base value to the previous value until all previous non-zero index value or non-zero count flag entries in the bank have been assigned.</p>
    <p>When a key symbol is removed from the index table, the REMOVE KEY LOGIC executes a compact process. The compact process is the reverse of the expand process and removes the index value of the symbol from its bank of the index value table and adjusts the value of the remaining symbol value indexes to compact the directory to a minimal size.</p>
    <p>Referring now to FIG. 17, once a use of a symbol value discontinues at step <b>1800</b>, the use count for that symbol value is decremented by one at step <b>1802</b>. A determination is then made at step <b>1804</b> to determine if the use count for the symbol value equals zero. If not, the process stops and no further action is taken. Should the use count equal zero, then all the other use counts using this index value must also be zero, before the index value may be removed. In other words, all symbol values with the same index values must all have zero use counts before the REMOVE KEY LOGIC begins a compact process to decrease the size of the directory table and reassign index values in the index-value table.</p>
    <p>First, tracking parameters are set at step <b>1806</b>. These parameters include determining NEW SIZE, BLOCK SIZE, and NUMBER OF BLOCKS. These values are calculated is the same manner as described earlier for the ADD NEW SYMBOL process. The partition point of the bank where the symbol is to be removed is set equal to the index value of the removed symbol at step <b>1807</b> and the index values within the bank are reset by subtracting the base value from every non-zero index larger than the partition point in the bank at step <b>1808</b>. Next, the new base values for the index value table are computed at step <b>1810</b>. Then the size of the new directory NEW MAX is computed at <b>1812</b>. NEW MAX equals the base value of the most significant symbol position times the number of non-zero index values or valid flags plus one in that bank.</p>
    <p>The STORED RECORD LOGIC <b>94</b> moves the old directory to its new location. The MOVE directory process iterates over the old directory starting at the bottom and going up until all blocks have been processed. Initially the data between the beginning of the directory and the partition point is already the beginning of the new directory. Next, at step <b>1816</b> a group of data corresponding to directory locations utilizing the removed index value are skipped or removed from the directory. This group of removed data blocks is equal to the value of NEW SIZE.</p>
    <p>Next, a block of data directly after the removed block and equal to BLOCK SIZE is moved down to fill in the removed block of data at step <b>1818</b>. If inquiry step <b>1820</b> determines the last block has not been reached, control passes to step <b>1816</b> where a block of data is skipped in the old directory corresponding to NEW SIZE and a BLOCK SIZE number of entries are moved down to fill the removed data. Finally, the last block of data having a size corresponding to the value of BLOCK SIZE minus the length of the block of data between the beginning of the directory and the original partition point is moved below the final block at step <b>1822</b>.</p>
    <p>After the new directory has been created, new index values are assigned at step <b>1824</b> in the index value table and are calculated using the new base values and current count for the bank as described earlier. The new index values may be calculated at any point after the NEW BASE values are calculated <b>1810</b>. Once the new index values are assigned, the compact processing is complete.</p>
    <p>Referring now to FIGS. 19 to <b>21</b>, there is illustrated yet another embodiment of the invention. The embodiments in FIGS. 19 to <b>21</b> are slightly altered from the apparatus disclosed in FIGS. 5, <b>6</b> and <b>7</b> and enables index values to be assigned to valid and invalid key symbol locations within the INDEX VALUE TABLE <b>68</b>. This allows an index value to be calculated for record keys containing invalid key symbols. The calculated index value will point to a location in the neighborhood of index values for record data with similar key values.</p>
    <p>Referring now to FIG. 19, this figure illustrates the generic associative memory of FIG. 5, shown with the addition of count flag logic <b>2000</b> and in-use logic <b>2002</b>, flag count logic <b>2003</b> and compare keys logic <b>2009</b>. Other than the above mentioned components, the circuitry and logic are the same as described with respect to FIG. <b>5</b> and similar reference numbers have been used. The count flag logic <b>2000</b> counts the number of invalid key symbols in a key symbol string. An invalid key symbol is one whose corresponding valid symbol flag bit in the INDEX TABLE of FIG. 5 is zero. In the method of FIG. 19, all index table entries are non-zero (zero value entries may also be used) and each index table entry includes a valid symbol flag bit to indicate whether a symbol value is valid or invalid. The count flag logic <b>2000</b> determines the number of invalid symbols by checking the valid symbol flag bit for a symbol position in the INDEX VALUE TABLE <b>68</b> for each symbol presented. Each integer value in the INDEX VALUE TABLE <b>68</b> has an additional flag bit which is set to one (1), if the index value stored at that location is different from the next higher location in that bank. This occurs when the table location (i.e., the BANK and symbol value) was used to compute the index value stored at this location. The flag is set to zero (0) if the table location is not used to determine a record index value stored at this location. Index values stored at these zero flag locations are duplicate of the higher adjacent location.</p>
    <p>The memory in-use logic <b>2002</b> checks a memory in-use flag bit within the key record memory <b>78</b> to determine if record data is stored in the location pointed to by a record index <b>74</b> value. The bit is set to one (1) if data is currently stored at a location and zero (0) if no data is currently stored at the location. The flag count logic <b>2003</b> is the value from the count flag logic <b>2000</b> generated when the record index <b>74</b> is computed. In addition, the input key <b>501</b> being presented to the associative memory must be compared in compare keys logic <b>2009</b> to the sequence stored in the key record to determine if the keys are identical. If the input key <b>501</b> and the stored key <b>2010</b> are not identical, the learn key logic <b>88</b> is notified by the keys not equal flag line <b>2011</b>.</p>
    <p>Referring now to FIG. 20, this figure illustrates the learned key logic circuitry <b>88</b> from FIG. <b>19</b>. The learned key logic <b>88</b> functions in a similar manner as that discussed in FIG. <b>6</b>. Where appropriate, the reference numbers in FIGS. 6 and 20 are the same. The circuitry is similar to that of FIG. 6 with the following exceptions. The add key logic <b>601</b> no longer is connected to a zero detect line but instead receives input over the count flag line <b>2100</b>. The count flag line indicates when an invalid input key symbol has been detected. Also connected to the add key logic <b>601</b> is the flags count line <b>2102</b> which inputs to the add key logic <b>68</b> the number of invalid symbols contained within a key record stored in record memory <b>78</b>. The in-use flag line <b>2104</b> provides the add key logic <b>68</b> with an indication of whether a key record memory <b>78</b> location presently contains record data. The keys not equal flag line <b>2011</b> provides the add key logic <b>68</b> with an indication of whether the stored key (if there is a stored record) and the input key match. The delete key logic <b>605</b> receives commands over the compress logic line <b>2106</b> and the delete record line <b>519</b>.</p>
    <p>Referring now to FIG. 21 , there is shown the symbol use-count logic <b>603</b> and delete key logic <b>605</b>. The circuitry shown in FIG. 21 is similar to that of FIG. <b>7</b>. Where applicable the previous description and reference numbers remain the same. The circuitry functions in a similar fashion with the following exceptions. The compress line <b>2106</b>, as described in FIG. 20, enters the delete key logic <b>605</b> and connects to AND gate <b>809</b>. The compress signal command and a logical signal from the zero detect circuitry <b>805</b> are applied to AND gate <b>809</b>. Both signals being true causes the execute compress logic <b>2107</b> to compress record data to fill in locations vacated by removed data.</p>
    <p>Referring now to FIGS. 22<i>a </i>and <b>22</b> <i>b, </i>there is illustrated a flow diagram describing the method for assigning index values to an initial or entire key-set group including valid and invalid symbol values using an alternative method for assigning index values. The USE-COUNT TABLE (<b>801</b> of FIGS. 7 and 21) is updated as a set of keys are presented to the circuitry. Before the process of updating the USE-COUNT TABLE <b>801</b> begins, all positions within the USE-COUNT TABLE are reset to zero or a null value at step <b>2300</b>. The first key (for instance a text string or DNA sequence) is then presented at step <b>2302</b> to the system logic and the first symbol of the key is read at step <b>2304</b>.</p>
    <p>At step <b>2306</b>, the USE-COUNT for the symbol value in the present symbol position is incremented by one and the index table count flags set to one to indicate a use of the symbol value at the present symbol position. Next, a determination is made at step <b>2308</b> as to whether the final symbol has been presented for a key. If the last symbol has not been presented, control passes to step <b>2304</b> and the next symbol is read. If the last symbol for the key has been presented, step <b>2310</b> determines if another key is to be presented to the control logic. If another key is to be presented, control passes back to step <b>2302</b>. At step <b>2303</b>, the build index logic <b>2305</b> initiates the building of the INDEX VALUE TABLE.</p>
    <p>At step <b>2312</b>, the BASE value for the least significant symbol position is set equal to one. For each subsequent symbol position or BANK, the base value will equal the maximum index value for the previous symbol position. The CURRENT COUNT for the symbol position is then set equal to one at step <b>2314</b>. The control logic initially scans at step <b>2316</b> the least significant BANK values of the USE-COUNT TABLE. The first symbol value entry for the BANK is read at step <b>2317</b>. An index value is assigned to the symbol position in the INDEX VALUE TABLE at step <b>2320</b> by multiplying the CURRENT COUNT by the BASE VALUE and the result is placed in the corresponding BANK and position in the INDEX VALUE TABLE <b>68</b> of FIG. <b>19</b>.</p>
    <p>Inquiry step <b>2340</b> determines if another symbol value exists for the current symbol BANK. If so, a determination is made at step <b>2318</b> if the SYMBOL VALID FLAG entry equals zero. If the entry equals zero, control passes back to step <b>2317</b> and the next symbol position for the present BANK in the USE-COUNT TABLE is read and assigned an index value which is the same as the previously assigned index value. If the count flag equals one, CURRENT COUNT is incremented by one at step <b>2342</b> and control returns to step <b>2317</b>. When no further symbol values exists in the current BANK, the control logic determines if another BANK exist at step <b>2346</b>. If another BANK exists, the BASE value is set equal to the present BASE value times current count at step <b>2348</b> and control returns to step <b>2314</b>. Otherwise, all index values for the keys have been assigned and the process is complete.</p>
    <p>Once completed, each symbol position within the INDEX VALUE TABLE <b>68</b> is assigned an index value, including invalid symbol positions not used by the presently stored symbol key set. With all the index table locations assigned a value, one can rapidly determine the “closeness” of an input key string sequence containing invalid symbols to key sequences already encoded into the USE-COUNT TABLE. Once the initial INDEX VALUE TABLE <b>68</b> values have been assigned using the process of FIGS. 22<i>a </i>thru <b>22</b> <i>c, </i>additional keys may be added to associative memory. If the sum of the symbol index values identifies a location in RECORD MEMORY <b>78</b> where the IN-USE flag is not set (location not currently used) then the IN-USE flag is set and the record and key are stored with no modification to any index values in the INDEX VALUE TABLE <b>68</b>. The USE-COUNT TABLE is updated with counts for all the new key symbols. If RECORD MEMORY <b>78</b> location for the new key (i.e., the sum of the symbol index values) is IN-USE (IN-USE set) and the keys are different then the values in the INDEX VALUE TABLE <b>68</b> must be modified to make room for the new key using the method described in FIG. <b>16</b>.</p>
    <p>When a key is entered for which the sum of the symbol index values equals a record location which is already in use, and the key already stored in the location is different from the new key, the values in the INDEX VALUE TABLE <b>68</b> must be expanded to make room for the new key (or one of the keys must be discarded). The new key and the stored key are compared in the compare keys logic <b>2009</b>. The compare keys logic <b>2009</b> informs the learned key logic <b>88</b> of the symbol positions and symbol values that differentiate the two keys. Symbol positions with different symbol values must be assigned the same index value or the two keys would not have the same index sum. To distinguish the two keys, one of the different symbol values must be assigned a different index value. The process defined in FIG. 16 describes the method for assigning one symbol a new-index value and relocating all the effected key records.</p>
    <p>In yet another embodiment of the invention, the USE-COUNT TABLES for various key sets may be applied to an associative set processor to obtain information regarding maximum key set sizes resulting from set operations union or intersection of one or more key sets. Referring now to FIG. 25, there is shown a block diagram for an associative set processor <b>2400</b> and its included circuitry. Two separate memory locations contain the set A symbol USE-COUNT TABLE <b>2402</b> and the set B symbol USE-COUNT TABLE <b>2404</b>. It is to be understood that while the following description of operations relates to the use of two USE-COUNT TABLES, the operations are not limited to the union or intersection of two USE-COUNT TABLES. Both of these memory locations are connected to the associative set processor <b>2400</b>.</p>
    <p>The associative set processor <b>2400</b> is capable of performing a number of set operations. These operations include a union function <b>2406</b> for creating a table of all elements existing within the two USE-COUNT TABLES (<b>2402</b> and <b>2404</b>), an intersect function <b>2408</b> for creating a table containing all common elements between the two USE-COUNT TABLES and a mask function <b>2410</b> for combining a mask table, where some or all of the entries equals one (1), with a symbol USE-COUNT TABLE to create an output table, wherein each USE-COUNT position, having a value greater than zero (0) and the corresponding location in the mask table is equal to one (1), then the resulting table location is set to the USE-COUNT. The associative set processor <b>2400</b> outputs to a result table location <b>2412</b>. A table access counter <b>2414</b> allows the associative set processor <b>2400</b> to sequentially read through all the locations of the two input tables <b>2402</b> and <b>2404</b> and place the results of the set operation in the corresponding location of the result table <b>2412</b>. The table access counter includes the BANK and COUNT of FIG. <b>24</b>. At the end of an operation on two input tables, set A and set B, the maximum set size <b>2415</b> has been computed for the resulting set C which is the largest number of records in the set resulting from the same union, interest or mask operation being performed on the two key sets represented by table A <b>2402</b> and table B <b>2404</b>.</p>
    <p>Referring now to FIG. 24, there is shown a flow diagram illustrating the method for carrying out the union function <b>2406</b>. Initially, several counters are set at step <b>2500</b>. COUNT and BANK, the table access counter <b>2314</b>, are both set equal to one (1) and SUM is set equal to zero (0). MAX is set equal to the largest integer count. At step <b>2502</b>, the maximum value of the first COUNT and first BANK position between the first USE-COUNT TABLE and second USE-COUNT TABLE is determined and stored at RESULT. RESULT is added to SUM at step <b>2504</b>. Then RESULT is stored in the corresponding location of table <b>2412</b>. Next, COUNT is incremented by one (1) at step <b>2506</b>, and inquiry step <b>2508</b> determines if the value of COUNT has exceeded the size of the largest bank position. If the value of COUNT is less than the size of the bank position control passes back to step <b>2502</b> to determine the maximum value of the next position within the bank of the USE-COUNT TABLES A <b>2402</b> and B <b>2404</b>. The RESULT is stored in TABLE C <b>2412</b>. Once the maximum value of all symbol positions within a bank have been determined by (COUNT&gt;BANK size) at <b>2508</b>, control passes to step <b>2510</b> where COUNT is set equal to one (1). If SUM is less than MAX the value of the MAX is set equal to SUM. SUM is then set equal to zero (0), and BANK is incremented by one (1). Inquiry step <b>2512</b> determines if another bank exists, and proceeds to step <b>2502</b> to determine the maximum values within the next bank. If other banks do not exist, the value of MAX is output at step <b>2514</b> into maximum set size <b>2415</b> (FIG. <b>23</b>). The value of MAX stored in maximum set size <b>2415</b> (FIG. 23) represents the maximum number of RECORD MEMORY <b>78</b> entries that could result from a union of the key sets of the RECORD MEMORIES corresponding to USE-COUNT TABLES A and B. That is a union of the keys of RECORD MEMORIES A and B can result in a RECORD MEMORY C with no more than MAX key records.</p>
    <p>Referring now to FIG. 25, there is illustrated a flow diagram of the operation of the intersect function <b>2408</b>. Counters are initialized at step <b>2600</b>. These counters include COUNT and BANK, which are set equal to one (1), and the SUM counter, which is set equal to zero (0). MAX is set to the largest count value. The initial value of RESULT is determined by finding the minimum value in the first BANK, first COUNT position of the A and B USE-COUNT TABLES (<b>2402</b>, <b>2404</b>) at step <b>2602</b>. RESULT is added to the value of SUM at step <b>2604</b> and the value of RESULT is output to the RESULT TABLE <b>2412</b>. Next, COUNT is incremented by one (1) at step <b>2506</b> and inquiry step <b>2608</b> determines if the COUNT is greater than the size of the present bank. If count is less than the present bank size, control returns to step <b>2602</b>. Otherwise at step <b>2610</b>, COUNT is reset to one (1), the BANK value is incremented by one (1) and the value of MAX is set equal to SUM if SUM is less than MAX. SUM is then reset to zero (0).</p>
    <p>Inquiry step <b>2612</b> determines if another bank exists within the USE-COUNT TABLES. If additional banks exists control returns to step <b>2602</b>. If all banks have been reviewed by the intersect function, the value of MAX is output to maximum set size <b>2415</b> (FIG. 24) at step <b>2514</b> by the associative processor. MAX represents the maximum number of key records contained in the record memory C from an intersect of the keys of record memories A and B.</p>
    <p>Referring now to FIG. 26, there is shown the method for performing the mask function of the associative set processor <b>2400</b>. The mask table may be either table A or B. Counters are initialized at step <b>2700</b>, wherein COUNT and BANK are set equal to one (1) and SUM is set equal to zero (0). MAX is set to the largest count value. Decision step <b>2702</b> determines if the value in the symbol position presently pointed to by the COUNT and BANK counters in USE-COUNT TABLES A and B, are both greater than zero (0). If so, then RESULT is set equal to the maximum value at this symbol position in either USE-COUNT TABLE A or B. If the symbol position in USE-COUNT TABLES A and B are not both greater than zero (0), RESULT is set equal to zero (0). SUM is then set at step <b>2704</b> equal to the value of SUM plus RESULT and the value of RESULT is output to the RESULT TABLE <b>2412</b>.</p>
    <p>COUNT is incremented at step <b>2706</b> and inquiry step <b>2708</b> determines if COUNT is greater than the size of the present bank. If COUNT is less than or equal to BANK SIZE then all symbol positions within a bank have not been examined and control returns to step <b>2702</b>. If all symbol positions have been examined, control passes to step <b>2710</b>, COUNT is reset to one (1) and BANK is incremented by one (1). Also at step <b>2710</b>, if SUM is less than the value of MAX, MAX is set equal to SUM then SUM is set equal to zero (0). Inquiry step <b>2712</b> determines if another bank exists to be examined. If another bank exists control passes to step <b>2702</b>. If no other banks are present, the value of MAX is output at step <b>2714</b> to indicate the maximum number of key records that can be in the key record memory resulting from the mask operation.</p>
    <p>Referring now to FIG. 27, a series of USE-COUNT or INDEX tables <b>2800</b>(<i>a</i>) through <b>2800</b>(<i>k</i>) may be combined by a series of set operations into a result table <b>2802</b>. This sequence of set operations is performed on like tables (either USE-COUNT or INDEX) using the associative set processor <b>2400</b>. Initially, the RESULT table <b>2802</b> has all its entries set to the counts in the first table <b>2800</b>(<i>a</i>). The table select switch <b>2810</b> selects the next table <b>2800</b>(<i>b</i>) and the set operation is performed with set A stored in the result table <b>2802</b>. Result table <b>2802</b> holds the USE-COUNT results of the operation between the first two record memories tables, for example the results of A intersect B. The input table selector switch <b>2810</b> is then set to the third USE-COUNT Table C <b>2800</b>(<i>c</i>) and the set operation with the result table <b>2802</b> is preformed, for example R union C. is (A intersection B) union C. The input and output table selection switches (<b>2810</b> and <b>2812</b>) are controlled by the associative set processor <b>2400</b> and sequence through all the USE-COUNT tables for all the record memory to be combined according to a user specified sequence of operations to perform the required set operations on each input USE-COUNT table. The result of each set operation includes a MAX value <b>2806</b> which is the maximum number of key records which meet the combined set operations. If during the processing, no union operations are left to be performed and the MAX value is zero (0), then there are no records in the resulting set, all the values in one bank of the result table <b>2802</b> are zero (0), and processing may stop with a null result. If after processing all the input tables, MAX is greater than zero (0), then the result table <b>2802</b> stores the resulting USE-COUNT table. This resulting USE-COUNT table may be used to filter all the original record memories to produce the record memory data set resulting from the sequence of operations. The resulting record memory can have no more than the final MAX records.</p>
    <p>To filter the original record memory data sets, the following operations are executed. First the result table <b>2802</b> containing the resulting USE-COUNTS for the sequence of set operations is intersected using the associative set processor <b>2400</b> with a unit table <b>2812</b> containing all one counts in every location. This intersection operation produces a results MASK table where every entry is either zero (0) if the result count was zero (0), or one (1) if the result count was greater than zero (0). Using the associative set processor <b>2400</b>, a MASK operation as illustrated in FIG. 26 is performed with each of the initial input index tables <b>2800</b>(<i>a</i>), <b>2800</b>(<i>b</i>) . . . <b>2800</b>(<i>k</i>) to produce result index tables <b>2802</b>(<i>a</i>), <b>2802</b>(<i>b</i>) . . . <b>2802</b>(<i>k</i>) for the original record memory data sets. If the MAX value is zero (0), then the results set has no records.</p>
    <p>Referring now to FIG. 28, the results table <b>2802</b> in FIG. 27 containing the USE-COUNTS resulting from a sequence of set operations is used to generate an result index table <b>2900</b> using one of the index table creation processes previously described in FIGS. 5 to <b>22</b>. Wherein similar functional elements to those previously described in FIGS. 5 to <b>22</b> are used, the same reference numerals have been utilized and the previous drawings and related description may be referred to for a more detailed disclosure of the functional element. By cycling through only the combinations of index values greater than zero (0) in each input index result table <b>2802</b>, only the records belonging to the resulting set are selected from the record memory for each original set. The table selector switch <b>2902</b> and the record memory selector switch <b>2904</b> provide access to a result index table <b>2802</b>(<i>n</i>) and its associated record memory <b>2906</b>(<i>n</i>). For each resulting index table <b>2802</b>(A), <b>2802</b>(B) . . . <b>2802</b>(K) the record memory <b>2906</b>(A), <b>2906</b>(B) . . . <b>2906</b>(K) is accessed for each combination of non-zero index values. For each such record memory location which has a record stored indicated by INUSE flag bit <b>2002</b>, that record is placed in the results record memory <b>2908</b>. The location in the results record memory <b>2908</b> is computed using the sum of index values from the new result index table <b>2900</b>.</p>
    <p>FIG. 29, is a flow chart of the symbol sequence scanner logic <b>2910</b> of FIG. <b>28</b>. The scanner sequences through the all input result index table <b>2802</b>(A) . . . <b>2802</b>(K) at step <b>3000</b> and selects one at a time. At steps <b>3002</b> through <b>3010</b> the scanner generates all the non-zero input record indexes for the table. These are the records which could possibly meet the results set of a sequence of set operations between this set and all of other sets. First, the highest order bank or symbol position is scanned for a non-zero index value or count flag at step <b>3004</b>. For each non-zero value found in the highest order bank, all the lower order bank values are scanned at step <b>3006</b> through <b>3010</b> and each non-zero index value is used to compute a record index. A record index is the sum of a non-zero index value from bank. FIG. 30<i>a </i>shows a flow chart for the highest order bank process. INPUT is the index value at the current symbol value location in the masked input index table <b>67</b>. OUTPUT is the index value from the result index table <b>2900</b> for the same location. FIGS. 30<i>b </i>and <b>30</b> <i>c </i>are continuations of the flow chart for the next lower order bank processes. A partial index sum INPUT-COUNT and OUTPUT-COUNT is kept for each bank. FIG. 30<i>d </i>illustrates the lowest order bank process where all INUSE=true records are copied from the input record memory to the results record memory. Each record is stored at a location which is the sum of the index values from the result index table <b>2900</b> of FIG. <b>28</b>.</p>
    <p>Although preferred and alternative embodiments of the present invention have been illustrated in the accompanying Drawings and described in the foregoing Detailed Description, it will be understood that the invention is not limited to the embodiments disclosed, but is capable of numerous rearrangements, modifications and substitutions of parts and elements without departing from the spirit of the invention.</p>
    </div></div></div><div class="patent-section patent-tabular-section"><a id="backward-citations"></a><div class="patent-section-header"><span class="patent-section-title">Patent Citations</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th">Cited Patent</th><th class="patent-data-table-th">Filing date</th><th class="patent-data-table-th">Publication date</th><th class="patent-data-table-th">Applicant</th><th class="patent-data-table-th">Title</th></tr></thead><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US3355556">US3355556</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">May 18, 1964</td><td class="patent-data-table-td patent-date-value">Nov 28, 1967</td><td class="patent-data-table-td ">American Telephone &amp; Telegraph</td><td class="patent-data-table-td ">Automatic mobile radio telephone switching system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US3678391">US3678391</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Apr 6, 1970</td><td class="patent-data-table-td patent-date-value">Jul 18, 1972</td><td class="patent-data-table-td ">Sylvania Electric Prod</td><td class="patent-data-table-td ">Digital communication system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US3979733">US3979733</a></td><td class="patent-data-table-td patent-date-value">May 9, 1975</td><td class="patent-data-table-td patent-date-value">Sep 7, 1976</td><td class="patent-data-table-td ">Bell Telephone Laboratories, Incorporated</td><td class="patent-data-table-td ">Digital data communications system packet switch</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4276643">US4276643</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Mar 14, 1979</td><td class="patent-data-table-td patent-date-value">Jun 30, 1981</td><td class="patent-data-table-td ">Agence Nationale De Valorisation De La Recherche (Anvar)</td><td class="patent-data-table-td ">Method of and means for routing binary messages through a multinode data-transmission system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4494230">US4494230</a></td><td class="patent-data-table-td patent-date-value">Jun 25, 1982</td><td class="patent-data-table-td patent-date-value">Jan 15, 1985</td><td class="patent-data-table-td ">At&amp;T Bell Laboratories</td><td class="patent-data-table-td ">Fast packet switching system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4597078">US4597078</a></td><td class="patent-data-table-td patent-date-value">Oct 19, 1983</td><td class="patent-data-table-td patent-date-value">Jun 24, 1986</td><td class="patent-data-table-td ">Digital Equipment Corporation</td><td class="patent-data-table-td ">Bridge circuit for interconnecting networks</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4603416">US4603416</a></td><td class="patent-data-table-td patent-date-value">Dec 12, 1983</td><td class="patent-data-table-td patent-date-value">Jul 29, 1986</td><td class="patent-data-table-td ">Michel Servel</td><td class="patent-data-table-td ">(Time division multiplex) switching system for routing trains of constant length data packets</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4606002">US4606002</a></td><td class="patent-data-table-td patent-date-value">Aug 17, 1983</td><td class="patent-data-table-td patent-date-value">Aug 12, 1986</td><td class="patent-data-table-td ">Wang Laboratories, Inc.</td><td class="patent-data-table-td ">B-tree structured data base using sparse array bit maps to store inverted lists</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4644351">US4644351</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">May 8, 1984</td><td class="patent-data-table-td patent-date-value">Feb 17, 1987</td><td class="patent-data-table-td ">Motorola, Inc.</td><td class="patent-data-table-td ">Two way personal message system with extended coverage</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4661951">US4661951</a></td><td class="patent-data-table-td patent-date-value">Jan 9, 1985</td><td class="patent-data-table-td patent-date-value">Apr 28, 1987</td><td class="patent-data-table-td ">U.S. Philips Corporation</td><td class="patent-data-table-td ">Communication network in which at least one station comprises a determination-type message filtering device</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4706081">US4706081</a></td><td class="patent-data-table-td patent-date-value">Dec 14, 1984</td><td class="patent-data-table-td patent-date-value">Nov 10, 1987</td><td class="patent-data-table-td ">Vitalink Communications Corporation</td><td class="patent-data-table-td ">Method and apparatus for bridging local area networks</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4742511">US4742511</a></td><td class="patent-data-table-td patent-date-value">Jun 13, 1985</td><td class="patent-data-table-td patent-date-value">May 3, 1988</td><td class="patent-data-table-td ">Texas Instruments Incorporated</td><td class="patent-data-table-td ">Method and apparatus for routing packets in a multinode computer interconnect network</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4797881">US4797881</a></td><td class="patent-data-table-td patent-date-value">Mar 12, 1987</td><td class="patent-data-table-td patent-date-value">Jan 10, 1989</td><td class="patent-data-table-td ">Sytek, Inc.</td><td class="patent-data-table-td ">Bridge system for connecting networks</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4812843">US4812843</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Aug 11, 1987</td><td class="patent-data-table-td patent-date-value">Mar 14, 1989</td><td class="patent-data-table-td ">Champion Iii C Paul</td><td class="patent-data-table-td ">For providing traffic information to subscribers</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4833701">US4833701</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jan 27, 1988</td><td class="patent-data-table-td patent-date-value">May 23, 1989</td><td class="patent-data-table-td ">Motorola, Inc.</td><td class="patent-data-table-td ">Trunked communication system with nationwide roaming capability</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4843622">US4843622</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Apr 4, 1988</td><td class="patent-data-table-td patent-date-value">Jun 27, 1989</td><td class="patent-data-table-td ">Nec Corporation</td><td class="patent-data-table-td ">Communication control system capable of searching a called telephone set in a mobile radio telephone network</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4866431">US4866431</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Feb 22, 1988</td><td class="patent-data-table-td patent-date-value">Sep 12, 1989</td><td class="patent-data-table-td ">Telefind Corp.</td><td class="patent-data-table-td ">Paging system hub switch</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4875208">US4875208</a></td><td class="patent-data-table-td patent-date-value">Jan 26, 1988</td><td class="patent-data-table-td patent-date-value">Oct 17, 1989</td><td class="patent-data-table-td ">Hitachi, Ltd.</td><td class="patent-data-table-td ">Transmission method for control information in communication network</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4887265">US4887265</a></td><td class="patent-data-table-td patent-date-value">Mar 18, 1988</td><td class="patent-data-table-td patent-date-value">Dec 12, 1989</td><td class="patent-data-table-td ">Motorola, Inc.</td><td class="patent-data-table-td ">Packet-switched cellular telephone system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4896319">US4896319</a></td><td class="patent-data-table-td patent-date-value">Mar 31, 1988</td><td class="patent-data-table-td patent-date-value">Jan 23, 1990</td><td class="patent-data-table-td ">American Telephone And Telegraph Company, At&amp;T Bell Laboratories</td><td class="patent-data-table-td ">Identification and authentication of end user systems for packet communications network services</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4912756">US4912756</a></td><td class="patent-data-table-td patent-date-value">Apr 7, 1989</td><td class="patent-data-table-td patent-date-value">Mar 27, 1990</td><td class="patent-data-table-td ">Unilink Corporation</td><td class="patent-data-table-td ">Method and apparatus for error-free digital data transmission during cellular telephone handoff, etc.</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4916691">US4916691</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Oct 28, 1988</td><td class="patent-data-table-td patent-date-value">Apr 10, 1990</td><td class="patent-data-table-td ">American Telephone And Telegraph Company</td><td class="patent-data-table-td ">Telecommunications switching system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4922503">US4922503</a></td><td class="patent-data-table-td patent-date-value">Oct 28, 1988</td><td class="patent-data-table-td patent-date-value">May 1, 1990</td><td class="patent-data-table-td ">Infotron Systems Corporation</td><td class="patent-data-table-td ">In a data communications system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4953162">US4953162</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Aug 26, 1987</td><td class="patent-data-table-td patent-date-value">Aug 28, 1990</td><td class="patent-data-table-td ">Lyons Paul J</td><td class="patent-data-table-td ">Multipath local area network</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4989204">US4989204</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Feb 9, 1989</td><td class="patent-data-table-td patent-date-value">Jan 29, 1991</td><td class="patent-data-table-td ">Nec Corporation</td><td class="patent-data-table-td ">High throughput communication method and system for a digital mobile station when crossing a zone boundary during a session</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5095480">US5095480</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jun 16, 1989</td><td class="patent-data-table-td patent-date-value">Mar 10, 1992</td><td class="patent-data-table-td ">Fenner Peter R</td><td class="patent-data-table-td ">Message routing system for shared communication media networks</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5168498">US5168498</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">May 3, 1990</td><td class="patent-data-table-td patent-date-value">Dec 1, 1992</td><td class="patent-data-table-td ">British Telecommunications Public Limited Company</td><td class="patent-data-table-td ">Mobile communications system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5365520">US5365520</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Mar 27, 1992</td><td class="patent-data-table-td patent-date-value">Nov 15, 1994</td><td class="patent-data-table-td ">Motorola, Inc.</td><td class="patent-data-table-td ">Dynamic signal routing</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5490258">US5490258</a></td><td class="patent-data-table-td patent-date-value">Sep 29, 1992</td><td class="patent-data-table-td patent-date-value">Feb 6, 1996</td><td class="patent-data-table-td ">Fenner; Peter R.</td><td class="patent-data-table-td ">Associative memory for very large key spaces</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5842224">US5842224</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jun 30, 1994</td><td class="patent-data-table-td patent-date-value">Nov 24, 1998</td><td class="patent-data-table-td ">Fenner; Peter R.</td><td class="patent-data-table-td ">Method and apparatus for source filtering data packets between networks of differing media</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5860136">US5860136</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Dec 28, 1993</td><td class="patent-data-table-td patent-date-value">Jan 12, 1999</td><td class="patent-data-table-td ">Fenner; Peter R.</td><td class="patent-data-table-td ">Method and apparatus for use of associated memory with large key spaces</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/EP0255767A2?cl=en">EP0255767A2</a></td><td class="patent-data-table-td patent-date-value">Jul 22, 1987</td><td class="patent-data-table-td patent-date-value">Feb 10, 1988</td><td class="patent-data-table-td ">AT&amp;amp;T Corp.</td><td class="patent-data-table-td ">Selective broadcasting arrangement for local area networks</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="http://www.google.com/url?id=8ohpBAABERAJ&amp;q=http://worldwide.espacenet.com/publicationDetails/biblio%3FCC%3DFR%26NR%3D2513472A2%26KC%3DA2%26FT%3DD&amp;usg=AFQjCNHvL9Ry49cW7PZwgR4RwMgPbCQzSA">FR2513472A2</a></td><td class="patent-data-table-td patent-date-value"></td><td class="patent-data-table-td patent-date-value"></td><td class="patent-data-table-td "> </td><td class="patent-data-table-td citation-no-title">Title not available</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="http://www.google.com/url?id=8ohpBAABERAJ&amp;q=http://worldwide.espacenet.com/publicationDetails/biblio%3FCC%3DGB%26NR%3D2189112A%26KC%3DA%26FT%3DD&amp;usg=AFQjCNHGoFKuSwojLme_Fex6aW8t4_r1LA">GB2189112A</a></td><td class="patent-data-table-td patent-date-value"></td><td class="patent-data-table-td patent-date-value"></td><td class="patent-data-table-td "> </td><td class="patent-data-table-td citation-no-title">Title not available</td></tr></table><div class="patent-section-footer">* Cited by examiner</div></div><div class="patent-section patent-tabular-section"><a id="npl-citations"></a><div class="patent-section-header"><span class="patent-section-title">Non-Patent Citations</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th colspan="3"class="patent-data-table-th">Reference</th></tr></thead><tr><td class="patent-data-table-td ">1</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Bartee, T.C. et al., "<a href='http://scholar.google.com/scholar?q="C31+Information+Systems+Internetwork+Study%2C"'>C31 Information Systems Internetwork Study,</a>" Institute for Defense Analyses, Apr. 1984.</td></tr><tr><td class="patent-data-table-td ">2</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Deering, Stephen E., "<a href='http://scholar.google.com/scholar?q="Multicast+Routing+in+Internetworks+and+Extended+LANs%2C"'>Multicast Routing in Internetworks and Extended LANs,</a>" pp. 55-64, 1988 ACM.</td></tr><tr><td class="patent-data-table-td ">3</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Elden, Walter L. et al., "<a href='http://scholar.google.com/scholar?q="LAN+Interoperability+Study+of+Protocols+Needed+for+Distributed+Command+and+Control%2C"'>LAN Interoperability Study of Protocols Needed for Distributed Command and Control,</a>" Final Technical Report, Mar. 1985.</td></tr><tr><td class="patent-data-table-td ">4</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Estrin, Deborah, "<a href='http://scholar.google.com/scholar?q="Interconnection+Protocols+for+Interorganization+Networks%2C"'>Interconnection Protocols for Interorganization Networks,</a>" Reprinted from IEEE J. Selected Areas Commun., vol. SAC-5, No. 9, pp. 1480-1491, Dec. 1987.</td></tr><tr><td class="patent-data-table-td ">5</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">G. Parr, "<a href='http://scholar.google.com/scholar?q="A+More+Fault+Tolerant+Approach+to+Address+Resolution+for+a+Multi-Lan+System+of+Ethernets%2C"'>A More Fault Tolerant Approach to Address Resolution for a Multi-Lan System of Ethernets,</a>" Network Working Group, Request for Comments: 1029, May 12, 1988, pp. 1-16, University of Ulster.</td></tr><tr><td class="patent-data-table-td ">6</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">G. Parr, "<a href='http://scholar.google.com/scholar?q="Address+Resolution+for+an+Intelligent+Filtering+Bridge+Running+on+a+Subnetted+Ethernet+System%2C"'>Address Resolution for an Intelligent Filtering Bridge Running on a Subnetted Ethernet System,</a>" Institute of Informatics, Computer Science Dept., 1987, pp. 48-70, Univ. of Ulster at Coleraine, County Londonderry, N. Ireland.</td></tr><tr><td class="patent-data-table-td ">7</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Kleinrock, Leonard et al., "<a href='http://scholar.google.com/scholar?q="Hierarchical+Routing+for+Large+Networks%2C+Performance+Evaluation+and+Optimization%2C"'>Hierarchical Routing for Large Networks, Performance Evaluation and Optimization,</a>" Reprinted from Computer Networks, vol. 1, pp. 155-174, Jan. 1977.</td></tr><tr><td class="patent-data-table-td ">8</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Shoch, John F., "<a href='http://scholar.google.com/scholar?q="Inter-Network+Naming%2C+Addressing%2C+and+Routing%2C"'>Inter-Network Naming, Addressing, and Routing,</a>" Reprinted from IEEE Proc. COMPCON, pp. 72-79, 1978.</td></tr><tr><td class="patent-data-table-td ">9</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Sunshine, Carl A., "<a href='http://scholar.google.com/scholar?q="Addressing+Problems+in+Multi-Network+Systems%2C"'>Addressing Problems in Multi-Network Systems,</a>" Reprinted from IEEE Proc. INFOCOM, pp. 12-18, 1982.</td></tr><tr><td class="patent-data-table-td ">10</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Tsuchiya, Paul F, "<a href='http://scholar.google.com/scholar?q="The+Landmark+Hierarchy%3A+A+New+Hierarchy+for+Routing+in+Very+Large+Networks%2C"'>The Landmark Hierarchy: A New Hierarchy for Routing in Very Large Networks,</a>" The Mitre Corporation, pp. 35-42, 1988 ACM.</td></tr><tr><td class="patent-data-table-td ">11</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Tsudik, Gene, "<a href='http://scholar.google.com/scholar?q="Implications+of+Fragmentation+and+Dynamic+Routing+for+Internet+Datagram+Authentication%2C"'>Implications of Fragmentation and Dynamic Routing for Internet Datagram Authentication,</a>" Networks and Distributed Systems Laboratory, Computer Science Department, University of Southern California and IBM Los Angeles Scientific Center, pp 22-30.</td></tr><tr><td class="patent-data-table-td ">12</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">Wai Sum Lai, "<a href='http://scholar.google.com/scholar?q="Packet+Forwarding%2C"'>Packet Forwarding,</a>" IEEE Communications Magazine, Jul. 12, 1988, pp. 8-17, vol. 26, No. 7.</td></tr></table><div class="patent-section-footer"></div></div><div class="patent-section patent-tabular-section"><a id="forward-citations"></a><div class="patent-section-header"><span class="patent-section-title">Referenced by</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th">Citing Patent</th><th class="patent-data-table-th">Filing date</th><th class="patent-data-table-th">Publication date</th><th class="patent-data-table-th">Applicant</th><th class="patent-data-table-th">Title</th></tr></thead><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7099336">US7099336</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Aug 20, 2001</td><td class="patent-data-table-td patent-date-value">Aug 29, 2006</td><td class="patent-data-table-td ">Broadcom Corporation</td><td class="patent-data-table-td ">Method and apparatus for filtering packets based on flows using address tables</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7145906">US7145906</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jul 16, 2004</td><td class="patent-data-table-td patent-date-value">Dec 5, 2006</td><td class="patent-data-table-td ">Fenner Investments, Ltd.</td><td class="patent-data-table-td ">Packet switching node</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7162491">US7162491</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Feb 1, 2002</td><td class="patent-data-table-td patent-date-value">Jan 9, 2007</td><td class="patent-data-table-td ">Beacon Information Technology Inc.</td><td class="patent-data-table-td ">Data processing system, data processing method and computer program</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7251659">US7251659</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Dec 4, 2003</td><td class="patent-data-table-td patent-date-value">Jul 31, 2007</td><td class="patent-data-table-td ">Sprint Communications Company L.P.</td><td class="patent-data-table-td ">Method and system for managing resource indexes in a networking environment</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7313236">US7313236</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Apr 9, 2003</td><td class="patent-data-table-td patent-date-value">Dec 25, 2007</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">Methods and apparatus for secure and adaptive delivery of multimedia content</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7529230">US7529230</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Aug 24, 2005</td><td class="patent-data-table-td patent-date-value">May 5, 2009</td><td class="patent-data-table-td ">Research In Motion Limited</td><td class="patent-data-table-td ">Wireless router system and method</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7623657">US7623657</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jul 23, 2007</td><td class="patent-data-table-td patent-date-value">Nov 24, 2009</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">Methods and apparatus for secure and adaptive delivery of multimedia content</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7644061">US7644061</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jun 11, 2007</td><td class="patent-data-table-td patent-date-value">Jan 5, 2010</td><td class="patent-data-table-td ">Sprint Communications Company L.P.</td><td class="patent-data-table-td ">Managing resource indexes in a networking environment</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7885356">US7885356</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Dec 26, 2007</td><td class="patent-data-table-td patent-date-value">Feb 8, 2011</td><td class="patent-data-table-td ">Kabushiki Kaisha Toshiba</td><td class="patent-data-table-td ">Receiver and receiving method</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7920555">US7920555</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Dec 7, 2001</td><td class="patent-data-table-td patent-date-value">Apr 5, 2011</td><td class="patent-data-table-td ">Futurewei Technologies, Inc.</td><td class="patent-data-table-td ">Composite trunking</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8051284">US8051284</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jun 19, 2008</td><td class="patent-data-table-td patent-date-value">Nov 1, 2011</td><td class="patent-data-table-td ">Panasonic Corporation</td><td class="patent-data-table-td ">Encryption communications system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8078774">US8078774</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jun 5, 2008</td><td class="patent-data-table-td patent-date-value">Dec 13, 2011</td><td class="patent-data-table-td ">Cardullo Mario W</td><td class="patent-data-table-td ">Method and system for tracking</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8161129">US8161129</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Aug 9, 2006</td><td class="patent-data-table-td patent-date-value">Apr 17, 2012</td><td class="patent-data-table-td ">Sony Corporation</td><td class="patent-data-table-td ">Communication system, network system, information controller and terminal equipment</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8190147">US8190147</a></td><td class="patent-data-table-td patent-date-value">Jun 20, 2008</td><td class="patent-data-table-td patent-date-value">May 29, 2012</td><td class="patent-data-table-td ">Honeywell International Inc.</td><td class="patent-data-table-td ">Internetworking air-to-air network and wireless network</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8284674">US8284674</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">May 28, 2010</td><td class="patent-data-table-td patent-date-value">Oct 9, 2012</td><td class="patent-data-table-td ">Honeywell International Inc.</td><td class="patent-data-table-td ">Aircraft data link network routing</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8401002">US8401002</a></td><td class="patent-data-table-td patent-date-value">Jun 22, 2005</td><td class="patent-data-table-td patent-date-value">Mar 19, 2013</td><td class="patent-data-table-td ">Research In Motion Limited</td><td class="patent-data-table-td ">Exchange and use of globally unique device identifiers for circuit-switched and packet switched integration</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8570990">US8570990</a></td><td class="patent-data-table-td patent-date-value">Dec 4, 2007</td><td class="patent-data-table-td patent-date-value">Oct 29, 2013</td><td class="patent-data-table-td ">Honeywell International Inc.</td><td class="patent-data-table-td ">Travel characteristics-based ad-hoc communication network algorithm selection</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8755675">US8755675</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Apr 11, 2007</td><td class="patent-data-table-td patent-date-value">Jun 17, 2014</td><td class="patent-data-table-td ">Texas Instruments Incorporated</td><td class="patent-data-table-td ">Flexible and efficient memory utilization for high bandwidth receivers, integrated circuits, systems, methods and processes of manufacture</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US20070201358">US20070201358</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Aug 9, 2006</td><td class="patent-data-table-td patent-date-value">Aug 30, 2007</td><td class="patent-data-table-td ">Yoji Kawamoto</td><td class="patent-data-table-td ">Communication System, Network System, Information Controller and Terminal Equipment</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US20070247936">US20070247936</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Apr 11, 2007</td><td class="patent-data-table-td patent-date-value">Oct 25, 2007</td><td class="patent-data-table-td ">Texas Instruments Incorporated</td><td class="patent-data-table-td ">Flexible and efficient memory utilization for high bandwidth receivers, integrated circuits, systems, methods and processes of manufacture</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US20100232295">US20100232295</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">May 28, 2010</td><td class="patent-data-table-td patent-date-value">Sep 16, 2010</td><td class="patent-data-table-td ">Honeywell International Inc.</td><td class="patent-data-table-td ">Aircraft data link network routing</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US20120275459">US20120275459</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Apr 30, 2012</td><td class="patent-data-table-td patent-date-value">Nov 1, 2012</td><td class="patent-data-table-td ">Juniper Networks, Inc.</td><td class="patent-data-table-td ">Processing packets by a network device</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/WO2006093616A2?cl=en">WO2006093616A2</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Feb 3, 2006</td><td class="patent-data-table-td patent-date-value">Sep 8, 2006</td><td class="patent-data-table-td ">Exar Corp</td><td class="patent-data-table-td ">Network address filter including random access memory</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/WO2006136027A1?cl=en">WO2006136027A1</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jun 22, 2006</td><td class="patent-data-table-td patent-date-value">Dec 28, 2006</td><td class="patent-data-table-td ">Research In Motion Ltd</td><td class="patent-data-table-td ">Exchange and use of globally unique device identifiers for circuit-switched and packet switched integration</td></tr></table><div class="patent-section-footer">* Cited by examiner</div></div><div class="patent-section patent-tabular-section"><a id="classifications"></a><div class="patent-section-header"><span class="patent-section-title">Classifications</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th"> </th><th class="patent-data-table-th"> </th></tr></thead><tr><td class="patent-data-table-td ">U.S. Classification</td><td class="patent-data-table-td "><span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://www.uspto.gov/web/patents/classification/uspc370/defs370.htm&usg=AFQjCNEr5EDctcusna2HU7Iww2g4dx3BIw#C370S392000">370/392</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://www.uspto.gov/web/patents/classification/uspc370/defs370.htm&usg=AFQjCNEr5EDctcusna2HU7Iww2g4dx3BIw#C370S400000">370/400</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://www.uspto.gov/web/patents/classification/uspc370/defs370.htm&usg=AFQjCNEr5EDctcusna2HU7Iww2g4dx3BIw#C370S349000">370/349</a></span></td></tr><tr><td class="patent-data-table-td ">International Classification</td><td class="patent-data-table-td "><span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://web2.wipo.int/ipcpub/&usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&notion=scheme&version=20130101&symbol=H04L0012560000">H04L12/56</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://web2.wipo.int/ipcpub/&usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&notion=scheme&version=20130101&symbol=G06F0012020000">G06F12/02</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://web2.wipo.int/ipcpub/&usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&notion=scheme&version=20130101&symbol=H04W0008260000">H04W8/26</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://web2.wipo.int/ipcpub/&usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&notion=scheme&version=20130101&symbol=H04W0040020000">H04W40/02</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://web2.wipo.int/ipcpub/&usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&notion=scheme&version=20130101&symbol=H04W0080040000">H04W80/04</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://web2.wipo.int/ipcpub/&usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&notion=scheme&version=20130101&symbol=H04J0003240000">H04J3/24</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://web2.wipo.int/ipcpub/&usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&notion=scheme&version=20130101&symbol=H04L0012280000">H04L12/28</a></span></td></tr><tr><td class="patent-data-table-td ">Cooperative Classification</td><td class="patent-data-table-td "><span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=Y10S707/99933">Y10S707/99933</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=Y10S707/99932">Y10S707/99932</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=Y10S707/99931">Y10S707/99931</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=H04W80/04">H04W80/04</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=H04W8/26">H04W8/26</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=H04L45/742">H04L45/742</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=H04L12/4625">H04L12/4625</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=H04L45/16">H04L45/16</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=H04L29/06">H04L29/06</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=H03M7/4006">H03M7/4006</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=8ohpBAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=H04W40/02">H04W40/02</a></span></td></tr><tr><td class="patent-data-table-td ">European Classification</td><td class="patent-data-table-td "><span class="nested-value">H04W40/02</span>, <span class="nested-value">H04L45/16</span>, <span class="nested-value">H04L45/742</span>, <span class="nested-value">H03M7/40A</span>, <span class="nested-value">H04L12/46B7B</span>, <span class="nested-value">H04L29/06</span></td></tr></table><div class="patent-section-footer"></div></div><div class="patent-section patent-tabular-section"><a id="legal-events"></a><div class="patent-section-header"><span class="patent-section-title">Legal Events</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th">Date</th><th class="patent-data-table-th">Code</th><th class="patent-data-table-th">Event</th><th class="patent-data-table-th">Description</th></tr></thead><tr><td class="patent-data-table-td patent-date-value">Jan 8, 2013</td><td class="patent-data-table-td ">FP</td><td class="patent-data-table-td ">Expired due to failure to pay maintenance fee</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Effective date: </span><span class="nested-value">20121116</span></div></td></tr><tr><td class="patent-data-table-td patent-date-value">Nov 16, 2012</td><td class="patent-data-table-td ">LAPS</td><td class="patent-data-table-td ">Lapse for failure to pay maintenance fees</td><td class="patent-data-table-td "></td></tr><tr><td class="patent-data-table-td patent-date-value">Jul 2, 2012</td><td class="patent-data-table-td ">REMI</td><td class="patent-data-table-td ">Maintenance fee reminder mailed</td><td class="patent-data-table-td "></td></tr><tr><td class="patent-data-table-td patent-date-value">Oct 13, 2009</td><td class="patent-data-table-td ">RR</td><td class="patent-data-table-td ">Request for reexamination filed</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Effective date: </span><span class="nested-value">20060309</span></div></td></tr><tr><td class="patent-data-table-td patent-date-value">Dec 23, 2008</td><td class="patent-data-table-td ">B1</td><td class="patent-data-table-td ">Reexamination certificate first reexamination</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Free format text: </span><span class="nested-value">THE PATENTABILITY OF CLAIMS 3, 5, 8, 12, 13 AND 17 IS CONFIRMED. CLAIMS 1, 4, 6, 9-11 AND 14 ARE CANCELLED. CLAIMS 2, 7, 15 AND 16 ARE DETERMINED TO BE PATENTABLE AS AMENDED.</span></div></td></tr><tr><td class="patent-data-table-td patent-date-value">Mar 26, 2008</td><td class="patent-data-table-td ">FPAY</td><td class="patent-data-table-td ">Fee payment</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Year of fee payment: </span><span class="nested-value">4</span></div></td></tr><tr><td class="patent-data-table-td patent-date-value">Oct 11, 2005</td><td class="patent-data-table-td ">CC</td><td class="patent-data-table-td ">Certificate of correction</td><td class="patent-data-table-td "></td></tr><tr><td class="patent-data-table-td patent-date-value">Jan 25, 2002</td><td class="patent-data-table-td ">AS</td><td class="patent-data-table-td ">Assignment</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Owner name: </span><span class="nested-value">FENNER INVESTMENTS, LTD., TEXAS</span></div><div class="nested-key-value"><span class="nested-key">Free format text: </span><span class="nested-value">ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:4 EAGLE MAGIC, LLC;REEL/FRAME:012558/0315</span></div><div class="nested-key-value"><span class="nested-key">Effective date: </span><span class="nested-value">20020103</span></div></td></tr><tr><td class="patent-data-table-td patent-date-value">Aug 28, 2000</td><td class="patent-data-table-td ">AS</td><td class="patent-data-table-td ">Assignment</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Owner name: </span><span class="nested-value">4 EAGLE MAGIC, LLC, TEXAS</span></div><div class="nested-key-value"><span class="nested-key">Free format text: </span><span class="nested-value">ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:FENNER, PETER R.;REEL/FRAME:011067/0164</span></div><div class="nested-key-value"><span class="nested-key">Effective date: </span><span class="nested-value">20000801</span></div></td></tr></table><div class="patent-section-footer"></div></div><div class="modal-dialog" id="patent-images-lightbox"><div class="patent-lightbox-controls"><div class="patent-lightbox-rotate-controls"><div class="patent-lightbox-rotation-text">Rotate</div><div class="rotate-icon rotate-ccw-icon"></div><div class="rotate-icon rotate-cw-icon"></div></div><div class="patent-lightbox-index-counter"></div><a class="patent-lightbox-fullsize-link" target="_blank">Original Image</a><div class="patent-drawings-control patent-drawings-next"><img class="patent-drawings-button-img"src="/googlebooks/images/kennedy/page_right.png" alt="Next page"width="21" height="21" /></div><div class="patent-drawings-control patent-drawings-prev"><img class="patent-drawings-button-img"src="/googlebooks/images/kennedy/page_left.png" alt="Previous page"width="21" height="21" /></div></div><div class="modal-dialog-content"><div class="patent-lightbox-image-holder"><div class="patent-lightbox-placeholder"></div></div></div></div><script>_OC_initPatentsAtb({image_not_available_html: " Image not available"});</script></div></div></div></td></tr></table><script>(function() {var href = window.location.href;if (href.indexOf('?') !== -1) {var parameters = href.split('?')[1].split('&');for (var i = 0; i < parameters.length; i++) {var param = parameters[i].split('=');if (param[0] == 'focus') {var elem = document.getElementById(param[1]);if (elem) {elem.focus();}}}}})();</script><script>_OC_addFlags({LockSrc:"/books/javascript/lock_8a2b04e7bf975d5171d8e4c0b6365c7a.js", Host:"http://www.google.com/", IsBooksRentalEnabled:1, IsWebstoreDisplayCaseEnabled:1, IsObfuscationEnabled:1, IsBrowsingHistoryEnabled:1, IsWebReaderSvgEnabled:0, IsGeoLayerEnabled:1, IsImageModeNotesEnabled:1, IsCopyMenuItemEnabled:1, IsGiftingEnabled:0, IsWebReaderUniversalPaginatorEnabled:0, IsOfflineBubbleEnabled:1, IsReaderEnabledForPlayRequests:1, IsFutureOnSaleVolumesEnabled:1, IsOfflineRestrictedCopyEnabled:1, IsBooksUnifiedLeftNavEnabled:1, IsRestrictedCopyEnabled:1, IsZipitFolderCollectionEnabled:1, IsEndOfSampleRecommendationsEnabled:1, IsRatingsOnBookcardsEnabled:1, IsAdsDisabled:0, IsIframePageDisplayEnabled:0, IsEmbeddedMediaEnabled:1, IsImageModeAnnotationsEnabled:1, IsMyLibraryGooglePlusEnabled:1, IsImagePageProviderEnabled:0, IsBookcardListPriceSmall:0, IsInternalUser:0, IsBooksShareButtonEnabled:0, IsPreOrdersEnabled:0, IsDisabledRandomBookshelves:0, WebstoreDisplayCasePosition:3});_OC_Run({"enable_p13n":false,"add_vol_to_collection_base_url":"http://www.google.com/patents?op=add\u0026sig=ACfU3U2lOcaUHXnqyCPMTWFhq5pnxOf98A\u0026id=8ohpBAABERAJ","remove_vol_from_collection_base_url":"http://www.google.com/patents?op=remove\u0026sig=ACfU3U1ia0jWjjfVjQrmOW_AZ9RmcxDppg\u0026id=8ohpBAABERAJ","logged_in":false,"p13n_save_user_settings_url":"http://www.google.com/patents?op=edit_user_settings\u0026sig=ACfU3U29VCQ_KCm_mT2tSML7TR_SDPa8_A","is_cobrand":false,"sign_in_url":"https://www.google.com/accounts/Login?service=\u0026continue=http://www.google.com/patents%3Fhl%3Den\u0026hl=en","is_play_enabled":true}, {"volume_id":"","is_ebook":true,"volumeresult":{"has_flowing_text":false,"has_scanned_text":true,"can_download_pdf":false,"can_download_epub":false,"is_pdf_drm_enabled":false,"is_epub_drm_enabled":false,"download_pdf_url":"http://www.google.com/patents/download/Data_packet_routing_for_mobile_networks.pdf?id=8ohpBAABERAJ\u0026output=pdf\u0026sig=ACfU3U0fQi4lRCM-rhV4kxkT0RVDWfs5nQ"},"sample_url":"http://www.google.com/patents/reader?id=8ohpBAABERAJ\u0026printsec=frontcover\u0026output=reader\u0026source=gbs_atb_hover","is_browsable":true,"is_public_domain":true}, {});</script><div id="footer_table" style="font-size:83%;text-align:center;position:relative;top:20px;height:4.5em;margin-top:2em"><div style="margin-bottom:8px"><a href=http://www.google.com/><nobr>Google&nbsp;Home</nobr></a> - <a href=//www.google.com/patents/sitemap/><nobr>Sitemap</nobr></a> - <a href=http://www.google.com/googlebooks/uspto.html><nobr>USPTO Bulk Downloads</nobr></a> - <a href=/intl/en/privacy/><nobr>Privacy Policy</nobr></a> - <a href=/intl/en/policies/terms/><nobr>Terms of Service</nobr></a> - <a href=https://support.google.com/faqs/answer/2539193?hl=en><nobr>About Google Patents</nobr></a> - <a href="http://www.google.com/tools/feedback/intl/en/error.html" onclick="try{_OC_startFeedback({productId: '72792',locale: 'en'});return false;}catch(e){}"><nobr>Send Feedback</nobr></a></div><span>Data provided by IFI CLAIMS Patent Services</span><br><span >&copy;2012 Google</span></div> <script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-27188110-1");pageTracker._setCookiePath("/patents/");pageTracker._trackPageview();</script> </body></html>