<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><title>Patent US5153591 - Method and apparatus for encoding, decoding and transmitting data in ... - Google Patents</title><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){var d=void 0!=b?b:(new Date).getTime();this.t[a]=[d,c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(e){}};this.tick("start",null,a)}var a;window.performance&&(a=window.performance.timing);var f=a?new e(a.responseStart):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart,d=a.responseStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_",
"_wtsrt",d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();})();
</script><link rel="stylesheet" href="/patents/css/_8a2b04e7bf975d5171d8e4c0b6365c7a/kl_intl_patents_bundle.css" type="text/css" /><script src="/books/javascript/atb_8a2b04e7bf975d5171d8e4c0b6365c7a__en.js"></script><script>function googleTranslateElementInit() {new google.translate.TranslateElement({pageLanguage: "en",gaTrack: true,gaId: "UA-27188110-1",multilanguagePage: true});}</script><script src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script><meta name="DC.type" content="Patent"><meta name="DC.title" content="Method and apparatus for encoding, decoding and transmitting data in compressed form"><meta name="DC.contributor" content="Alan D. Clark" scheme="inventor"><meta name="DC.contributor" content="British Telecommunications Public Limited Company" scheme="assignee"><meta name="DC.date" content="1989-7-4" scheme="dateSubmitted"><meta name="DC.description" content="Data compression and decompression utilizing, e.g., the Ziv-Lempel algorithm is simplified by utilizing a tree structure for the dictionary in which alternative symbols at a given position in a symbol sequence (a,b,c) are linked by linking pointers R of a first type and successive symbols (ab,bc,ca,aba,abb,abc) are linked by linking pointers D of a second type. For example, the sequence ab may continue with any one of the symbols a,b, and c grouped together by R pointers in a list below the final symbol of the sequence ab. Each symbol is defined by an associated pair of D and R pointers, in conjunction with a parent pointer P which identifies its parent. Symbols having no D pointers extending therefrom are pruned from the tree and transferred to a free list as shown in FIG. 8(b)."><meta name="DC.date" content="1992-10-6" scheme="issued"><meta name="DC.relation" content="EP:0127815:A2" scheme="references"><meta name="DC.relation" content="EP:0148008:A2" scheme="references"><meta name="DC.relation" content="US:4464650" scheme="references"><meta name="DC.relation" content="US:4906991" scheme="references"><meta name="DC.relation" content="US:4990910" scheme="references"><meta name="DC.relation" content="US:5003307" scheme="references"><meta name="DC.relation" content="WO:1986000479:A1" scheme="references"><meta name="citation_reference" content="IBM Technical Disclosure Bulletin, vol. 14, No. 11, Apr. 1972, Koch, &quot;Representation of Tree Data Structures for Manipulation and Search Operation Data&quot;, pp. 3521-3522."><meta name="citation_reference" content="IBM Technical Disclosure Bulletin, vol. 14, No. 11, Apr. 1972, Koch, Representation of Tree Data Structures for Manipulation and Search Operation Data , pp. 3521 3522."><meta name="citation_reference" content="IBM Technical Disclosure Bulletin, vol. 20, No. 8, Jan. 1978, Winterbottom, &quot;General Purpose Database Structure&quot;, pp. 3320-3323."><meta name="citation_reference" content="IBM Technical Disclosure Bulletin, vol. 20, No. 8, Jan. 1978, Winterbottom, General Purpose Database Structure , pp. 3320 3323."><meta name="citation_reference" content="IBM Technical Disclosure Bulletin, vol. 25, No. 11B, Apr. 1983, Crus et al, &quot;Method for Deleting Records from a Hierarchical Data Base&quot;, pp. 5886-5888."><meta name="citation_reference" content="IBM Technical Disclosure Bulletin, vol. 25, No. 11B, Apr. 1983, Crus et al, Method for Deleting Records from a Hierarchical Data Base , pp. 5886 5888."><meta name="citation_patent_number" content="US:5153591"><meta name="citation_patent_application_number" content="US:07/623,809"><link rel="canonical" href="http://www.google.com/patents/US5153591"/><meta property="og:url" content="http://www.google.com/patents/US5153591"/><meta name="title" content="Patent US5153591 - Method and apparatus for encoding, decoding and transmitting data in compressed form"/><meta name="description" content="Data compression and decompression utilizing, e.g., the Ziv-Lempel algorithm is simplified by utilizing a tree structure for the dictionary in which alternative symbols at a given position in a symbol sequence (a,b,c) are linked by linking pointers R of a first type and successive symbols (ab,bc,ca,aba,abb,abc) are linked by linking pointers D of a second type. For example, the sequence ab may continue with any one of the symbols a,b, and c grouped together by R pointers in a list below the final symbol of the sequence ab. Each symbol is defined by an associated pair of D and R pointers, in conjunction with a parent pointer P which identifies its parent. Symbols having no D pointers extending therefrom are pruned from the tree and transferred to a free list as shown in FIG. 8(b)."/><meta property="og:title" content="Patent US5153591 - Method and apparatus for encoding, decoding and transmitting data in compressed form"/><meta property="og:type" content="book"/><meta property="og:site_name" content="Google Books"/><meta property="og:image" content="http://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"/><link rel="image_src" href="http://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"/><script>(function(){try{var aa=function(a,b,c,d){d=d||{};d._sn=["cfg",b,c].join(".");window.gbar.logger.ml(a,d)};var g=window.gbar=window.gbar||{},l=window.gbar.i=window.gbar.i||{},m={},n;function _tvn(a,b){var c=parseInt(a,10);return isNaN(c)?b:c}function _tvf(a,b){var c=parseFloat(a);return isNaN(c)?b:c}function _tvv(a){return!!a}function p(a,b,c){(c||g)[a]=b}g.bv={n:_tvn("2",0),r:"",f:".67.",e:"0",m:_tvn("0",1)};
function q(a,b,c){var d="on"+b;if(a.addEventListener)a.addEventListener(b,c,!1);else if(a.attachEvent)a.attachEvent(d,c);else{var f=a[d];a[d]=function(){var a=f.apply(this,arguments),b=c.apply(this,arguments);return void 0==a?b:void 0==b?a:b&&a}}}var s=function(a){return function(){return g.bv.m==a}},ba=s(1),ca=s(2);p("sb",ba);p("kn",ca);l.a=_tvv;l.b=_tvf;l.c=_tvn;l.i=aa;var da=window.gbar.i.i;var t,u,v,w;function ea(a){v=a}function fa(a){var b;if(b=v&&window.encodeURIComponent)b=a.href,b=!b.match(/^http[s]?:\/\/accounts\.google\.[^/]*\/ClearSID/i)&&!b.match(/^http[s]?:\/\/[^/]*\/accounts\/ClearSID/i);if(b=b&&encodeURIComponent(v()))a.href=a.href.replace(/([?&]continue=)[^&]*/,"$1"+b)}function ga(a){window.gApplication&&(a.href=window.gApplication.getTabUrl(a.href))}
function ha(a){var b=document.forms[0].q,c=window.encodeURIComponent&&b&&b.value,b=b&&b.placeholder;c&&c!=b&&(a.href=a.href.replace(/([?&])q=[^&]*|$/,function(a,b){return(b||"&")+"q="+encodeURIComponent(c)}))}n=l.a("")?ga:ha;
function x(a,b,c,d,f,e){var h=document.getElementById(a);if(h){var k=h.style;k.left=d?"auto":b+"px";k.right=d?b+"px":"auto";k.top=c+"px";k.visibility=u?"hidden":"visible";f&&e?(k.width=f+"px",k.height=e+"px"):(x(t,b,c,d,h.offsetWidth,h.offsetHeight),u=u?"":a)}}
var y=[],ia=function(a,b){y.push(b)},ja=function(a){a=a||window.event;var b=a.target||a.srcElement;a.cancelBubble=!0;null==t&&(a=document.createElement(Array.every||window.createPopup?"iframe":"div"),a.frameBorder="0",t=a.id="gbs",a.src="javascript:''",b.parentNode.appendChild(a),q(document,"click",z));var c=b,b=0;"gb3"!=c.className&&(c=c.parentNode);a=c.getAttribute("aria-owns")||"gbi";var d=c.offsetWidth,f=20<c.offsetTop?46:24;document.getElementById("tphdr")&&(f-=3);var e=!1;do b+=c.offsetLeft||
0;while(c=c.offsetParent);var c=(document.documentElement.clientWidth||document.body.clientWidth)-b-d,h,d=document.body,k=document.defaultView;k&&k.getComputedStyle?(d=k.getComputedStyle(d,""))&&(h=d.direction):h=d.currentStyle?d.currentStyle.direction:d.style.direction;h="rtl"==h;if("gbi"==a){for(d=0;k=y[d++];)k();A(null,window.navExtra);h&&(b=c,e=!0)}else h||(b=c,e=!0);u!=a&&z();x(a,b,f,e)},z=function(){u&&x(u,0,0)},A=function(a,b){var c,d=document.getElementById("gbi"),f=a;f||(f=d.firstChild);
for(;b&&(c=b.pop());){var e=d,h=c,k=f;w||(w="gb2");e.insertBefore(h,k).className=w}},ka=function(a,b,c){if((b=document.getElementById(b))&&a){a.className="gb4";var d=document.createElement("span");d.appendChild(a);d.appendChild(document.createTextNode(" | "));d.id=c;b.appendChild(d)}},la=function(){return document.getElementById("gb_70")},ma=function(){return!!u};p("qs",n);p("setContinueCb",ea);p("pc",fa);p("tg",ja);p("close",z);p("addLink",ka);p("almm",A);p("si",la);p("adh",ia);p("op",ma);var B=function(){},C=function(){},F=function(a){var b=new Image,c=D;b.onerror=b.onload=b.onabort=function(){try{delete E[c]}catch(a){}};E[c]=b;b.src=a;D=c+1},E=[],D=0;p("logger",{il:C,ml:B,log:F});var G=window.gbar.logger;var H={},na={},I=[],oa=l.b("0.1",.1),pa=l.a("1",!0),qa=function(a,b){I.push([a,b])},ra=function(a,b){H[a]=b},sa=function(a){return a in H},J={},K=function(a,b){J[a]||(J[a]=[]);J[a].push(b)},ta=function(a){K("m",a)},L=function(a,b){var c=document.createElement("script");c.src=a;c.async=pa;Math.random()<oa&&(c.onerror=function(){c.onerror=null;B(Error("Bundle load failed: name="+(b||"UNK")+" url="+a))});(document.getElementById("xjsc")||document.getElementsByTagName("body")[0]||
document.getElementsByTagName("head")[0]).appendChild(c)},N=function(a){for(var b=0,c;(c=I[b])&&c[0]!=a;++b);!c||c[1].l||c[1].s||(c[1].s=!0,M(2,a),c[1].url&&L(c[1].url,a),c[1].libs&&m.d&&m.d(c[1].libs))},O=function(a){K("gc",a)},P=null,ua=function(a){P=a},M=function(a,b,c){if(P){a={t:a,b:b};if(c)for(var d in c)a[d]=c[d];try{P(a)}catch(f){}}};p("mdc",H);p("mdi",na);p("bnc",I);p("qGC",O);p("qm",ta);p("qd",J);p("lb",N);p("mcf",ra);p("bcf",qa);p("aq",K);p("mdd","");p("has",sa);
p("trh",ua);p("tev",M);var Q=l.b("0.1",.001),R=0;
function _mlToken(a,b){try{if(1>R){R++;var c,d=a,f=b||{},e=encodeURIComponent,h=["//www.google.com/gen_204?atyp=i&zx=",(new Date).getTime(),"&jexpid=",e("17483"),"&srcpg=",e("prop=22"),"&jsr=",Math.round(1/Q),"&ogev=",e("8pvtU4zcK8iUogTeq4F4"),"&ogf=",g.bv.f,"&ogrp=",e("1"),"&ogv=",e("1407723702.0"),"&oggv="+e("es_plusone_gc_20140723.0_p0"),"&ogd=",e("com"),"&ogc=",e("JPN"),"&ogl=",e("en")];f._sn&&(f._sn="og."+
f._sn);for(var k in f)h.push("&"),h.push(e(k)),h.push("="),h.push(e(f[k]));h.push("&emsg=");h.push(e(d.name+":"+d.message));var r=h.join("");S(r)&&(r=r.substr(0,2E3));c=r;var Aa=window.gbar.logger._aem(a,c);F(Aa)}}catch(Na){}}var S=function(a){return 2E3<=a.length},va=function(a,b){return b};function T(a){B=a;p("_itl",S,G);p("_aem",va,G);p("ml",B,G);a={};H.er=a}l.a("")?T(function(a){throw a;}):l.a("1")&&Math.random()<Q&&T(_mlToken);I.push(["m",{url:"//ssl.gstatic.com/gb/js/scm_7385cc5883250b43a39405734c1bea59.js"}]);g.mcf("c",{});g.sg={c:""};if(l.a("1")){var wa=l.a("");I.push(["gc",{auto:wa,url:"//ssl.gstatic.com/gb/js/abc/gci_91f30755d6a6b787dcc2a4062e6e9824.js",libs:"googleapis.client:plusone:gapi.iframes"}]);var xa={version:"gci_91f30755d6a6b787dcc2a4062e6e9824.js",index:"",lang:"en"};H.gc=xa;var U=function(a){window.googleapis&&window.iframes?a&&a():(a&&O(a),N("gc"))};p("lGC",U);l.a("1")&&p("lPWF",U)};window.__PVT="";if(l.a("1")&&l.a("1")){var V=function(a){U(function(){K("pw",a);N("pw")})};p("lPW",V);I.push(["pw",{url:"//ssl.gstatic.com/gb/js/abc/pwm_45f73e4df07a0e388b0fa1f3d30e7280.js"}]);var W=[],ya=function(a){W[0]=a},za=function(a,b){var c=b||{};c._sn="pw";B(a,c)},Ba={signed:W,elog:za,base:"https://plusone.google.com/u/0",loadTime:(new Date).getTime()};H.pw=Ba;var X=function(a,b){for(var c=b.split("."),d=function(){var b=arguments;a(function(){for(var a=g,d=0,e=c.length-1;d<e;++d)a=a[c[d]];a[c[d]].apply(a,b)})},f=g,e=0,h=c.length-1;e<h;++e)f=
f[c[e]]=f[c[e]]||{};return f[c[e]]=d};X(V,"pw.clk");X(V,"pw.hvr");p("su",ya,g.pw)};function Ca(){function a(){for(var b;(b=e[h++])&&"m"!=b[0]&&!b[1].auto;);b&&(M(2,b[0]),b[1].url&&L(b[1].url,b[0]),b[1].libs&&m.d&&m.d(b[1].libs));h<e.length&&setTimeout(a,0)}function b(){0<f--?setTimeout(b,0):a()}var c=l.a("1"),d=l.a(""),f=3,e=I,h=0,k=window.gbarOnReady;if(k)try{k()}catch(r){da(r,"ml","or")}d?p("ldb",a):c?q(window,"load",b):b()}p("rdl",Ca);var Da={D:1,H:2,da:3,p:4,W:5,M:6,F:7,g:8,ha:9,U:10,L:11,T:12,S:13,N:14,Q:15,P:16,fa:17,w:18,O:19,ga:20,ea:21,u:22,G:23,ja:24,ka:25,ia:26,A:27,j:28,o:29,k:30,ca:31,Z:32,$:33,J:34,K:35,ba:36,aa:37,Y:38,B:39,R:40,v:41,X:42,V:43,h:48,C:49,I:500},Y=[1,2,3,4,5,6,9,10,11,13,14,28,29,30,34,35,37,38,39,40,41,42,43,48,49,500];var Z=l.b("0.001",1E-4),Ea=l.b("1",1),Fa=!1,Ga=!1;if(l.a("1")){var Ha=Math.random();Ha<=Z&&(Fa=!0);Ha<=Ea&&(Ga=!0)}var Ia=Da,$=null;function Ja(){var a=0,b=function(b,d){l.a(d)&&(a|=b)};b(1,"");b(2,"");b(4,"");b(8,"");return a}
function Ka(a,b){var c=Z,d=Fa,f;f=a;if(!$){$={};for(var e=0;e<Y.length;e++){var h=Y[e];$[h]=!0}}if(f=!!$[f])c=Ea,d=Ga;if(d){d=encodeURIComponent;g.rp?(f=g.rp(),f="-1"!=f?f:"1"):f="1";c=["//www.google.com/gen_204?atyp=i&zx=",(new Date).getTime(),"&oge=",a,"&ogex=",d("17483"),"&ogev=",d("8pvtU4zcK8iUogTeq4F4"),"&ogf=",g.bv.f,"&ogp=",d("22"),"&ogrp=",d(f),"&ogsr=",Math.round(1/c),"&ogv=",d("1407723702.0"),"&oggv="+
d("es_plusone_gc_20140723.0_p0"),"&ogd=",d("com"),"&ogl=",d("en"),"&ogc=",d("JPN"),"&ogus=",Ja()];if(b){"ogw"in b&&(c.push("&ogw="+b.ogw),delete b.ogw);var k;f=b;e=[];for(k in f)0!=e.length&&e.push(","),e.push(La(k)),e.push("."),e.push(La(f[k]));k=e.join("");""!=k&&(c.push("&ogad="),c.push(d(k)))}F(c.join(""))}}function La(a){"number"==typeof a&&(a+="");return"string"==typeof a?a.replace(".","%2E").replace(",","%2C"):a}C=Ka;p("il",C,G);var Ma={};H.il=Ma;setTimeout(function(){C(Ia.g)},0);}catch(e){window.gbar&&gbar.logger&&gbar.logger.ml(e,{"_sn":"cfg.init"});}})();
(function(){try{var b=window.gbar.i.i;var c=window.gbar;var f=function(d){try{var a=document.getElementById("gbom");a&&d.appendChild(a.cloneNode(!0))}catch(e){b(e,"omas","aomc")}};c.aomc=f;}catch(e){window.gbar&&gbar.logger&&gbar.logger.ml(e,{"_sn":"cfg.init"});}})();
(function(){try{var a=window.gbar;a.mcf("pm",{p:""});}catch(e){window.gbar&&gbar.logger&&gbar.logger.ml(e,{"_sn":"cfg.init"});}})();
(function(){try{window.gbar.rdl();}catch(e){window.gbar&&gbar.logger&&gbar.logger.ml(e,{"_sn":"cfg.init"});}})();
if (window['_OC_timingAction']) {window['_OC_timingAction']('patents_refpage');}</script><style>#gbar,#guser{font-size:13px;padding-top:1px !important;}#gbar{float:left;height:22px}#guser{padding-bottom:7px !important;text-align:right}.gbh,.gbd{border-top:1px solid #c9d7f1;font-size:1px}.gbh{height:0;position:absolute;top:24px;width:100%}#gbs,.gbm{background:#fff;left:0;position:absolute;text-align:left;visibility:hidden;z-index:1000}.gbm{border:1px solid;border-color:#c9d7f1 #36c #36c #a2bae7;z-index:1001}.gb1{margin-right:.5em}.gb1,.gb3{zoom:1}.gb2{display:block;padding:.2em .5em}.gb2,.gb3{text-decoration:none !important;border-bottom:none}a.gb1,a.gb4{text-decoration:underline !important}a.gb1,a.gb2,a.gb3,a.gb4{color:#00c !important}.gbi .gb3,.gbi .gb2,.gbi .gb4{color:#dd8e27 !important}.gbf .gb3,.gbf .gb2,.gbf .gb4{color:#900 !important}a.gb2:hover{background:#36c;color:#fff !important}#gbar .gbz0l{color:#000 !important;cursor:default;font-weight:bold;text-decoration:none !important}
#gbar { padding:.3em .6em !important;}</style></head><body  topmargin="3" marginheight="3"><div id=gbar><nobr><a onclick=gbar.qs(this);gbar.logger.il(1,{t:1}); class=gb1 id=gb_1 href="https://www.google.com/search?sa=N&tab=tw">Search</a> <a onclick=gbar.qs(this);gbar.logger.il(1,{t:2}); class=gb1 id=gb_2 href="http://www.google.com/search?hl=en&tbm=isch&source=og&sa=N&tab=ti">Images</a> <a onclick=gbar.qs(this);gbar.logger.il(1,{t:8}); class=gb1 id=gb_8 href="http://maps.google.com/maps?hl=en&sa=N&tab=tl">Maps</a> <a onclick=gbar.qs(this);gbar.logger.il(1,{t:78}); class=gb1 id=gb_78 href="https://play.google.com/?hl=en&sa=N&tab=t8">Play</a> <a onclick=gbar.qs(this);gbar.logger.il(1,{t:36}); class=gb1 id=gb_36 href="http://www.youtube.com/results?sa=N&tab=t1">YouTube</a> <a onclick=gbar.logger.il(1,{t:5}); class=gb1 id=gb_5 href="http://news.google.com/nwshp?hl=en&tab=tn">News</a> <a onclick=gbar.logger.il(1,{t:23}); class=gb1 id=gb_23 href="https://mail.google.com/mail/?tab=tm">Gmail</a> <a onclick=gbar.logger.il(1,{t:25}); class=gb1 id=gb_25 href="https://drive.google.com/?tab=to">Drive</a> <a class=gb3 href="http://www.google.com/intl/en/options/" onclick="this.blur();gbar.tg(event);return !1" aria-haspopup=true><u>More</u> <small>&#9660;</small></a><div class=gbm id=gbi><a onclick=gbar.logger.il(1,{t:24}); class=gb2 id=gb_24 href="https://www.google.com/calendar?tab=tc">Calendar</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:51}); class=gb2 id=gb_51 href="http://translate.google.com/?hl=en&sa=N&tab=tT">Translate</a><a onclick=gbar.logger.il(1,{t:17}); class=gb2 id=gb_17 href="http://www.google.com/mobile/?hl=en&tab=tD">Mobile</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:10}); class=gb2 id=gb_10 href="http://www.google.com/search?hl=en&tbo=u&tbm=bks&source=og&sa=N&tab=tp">Books</a><a onclick=gbar.logger.il(1,{t:212}); class=gb2 id=gb_212 href="https://wallet.google.com/manage/?tab=ta">Wallet</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:6}); class=gb2 id=gb_6 href="http://www.google.com/search?hl=en&tbo=u&tbm=shop&source=og&sa=N&tab=tf">Shopping</a><a onclick=gbar.logger.il(1,{t:30}); class=gb2 id=gb_30 href="http://www.blogger.com/?tab=tj">Blogger</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:27}); class=gb2 id=gb_27 href="http://www.google.com/finance?sa=N&tab=te">Finance</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:31}); class=gb2 id=gb_31 href="https://plus.google.com/photos?sa=N&tab=tq">Photos</a><a onclick=gbar.qs(this);gbar.logger.il(1,{t:12}); class=gb2 id=gb_12 href="http://www.google.com/search?hl=en&tbo=u&tbm=vid&source=og&sa=N&tab=tv">Videos</a><div class=gb2><div class=gbd></div></div><a onclick=gbar.logger.il(1,{t:66}); href="http://www.google.com/intl/en/options/" class=gb2>Even more &raquo;</a></div></nobr></div><div id=guser width=100%><nobr><span id=gbn class=gbi></span><span id=gbf class=gbf></span><span id=gbe></span><a target=_top id=gb_70 href="https://www.google.com/accounts/Login?service=&continue=http://www.google.com/patents%3Fhl%3Den&hl=en" class=gb4>Sign in</a><div style="display: none"><div class=gbm id=gbd5 aria-owner=gbg5><div class=gbmc><ol id=gbom class=gbmcc></ol></div></div></div></nobr></div><div class=gbh style=left:0></div><div class=gbh style=right:0></div><div role="alert" style="position: absolute; left: 0; right: 0;"><a href="http://www.google.com/patents/us5153591?hl=en&amp;output=html_text" title="Screen reader users: click this link for accessible mode. Accessible mode has the same essential features but works better with your reader."><img border="0" src="http://www.google.com/images/cleardot.gif"alt="Screen reader users: click this link for accessible mode. Accessible mode has the same essential features but works better with your reader."></a></div><div id="guser"><nobr></nobr></div><div style="clear:both;"></div><div id="gb-top-search-box" class="gb-top-search-box-small gb-reset"><table><tr><td class="logo"><a href="http://www.google.com/patents" class="logo-link"><img class="logo-img" src="/intl/en/images/logos/google_logo_41.png" alt="Go to Google Books Home" height="41"/></a></td><td><form action="http://www.google.com/search" name="f" id="vheadf" method="get"><span id="hf"></span><input type="hidden" name="tbm" value="pts"/><input type="hidden" name="tbo" value="1"/><input type="hidden" name="hl" value="en"/><table><tr><td><div class="inputs"><table><tr><td><div class="text-input"><input type="text" name="q" id="vheadq" class="text" maxlength="2048" size="31" value="" title="Search Patents" accesskey="s" autocomplete="off"/><script>window._OC_autoDir &&window._OC_autoDir('vheadq', 'tia-vheadq');</script></div></td><td><div class="submit-input"><input name="btnG" class="submit" type="submit" value=""/></div></td></tr></table></div></td><td class="col-ext-links"><div class="ext-links"><a href="http://www.google.com/advanced_patent_search">&lt;nobr&gt;Advanced Patent Search&lt;/nobr&gt;</a></div></td></tr></table></form></td></tr></table></div><div class="kd-appbar"><h2 class="kd-appname"><a href="/patents">Patents</a></h2><div class="kd-buttonbar left" id="left-toolbar-buttons"><a id="appbar-write-review-link" href=""></a><a id="appbar-view-print-sample-link" href=""></a><a id="appbar-view-ebook-sample-link" href=""></a><a id="appbar-patents-prior-art-finder-link" href="https://www.google.com/patents/related/US5153591"></a><a id="appbar-patents-discuss-this-link" href="http://www.google.com/url?id=fEY0BAABERAJ&amp;q=http://patents.stackexchange.com/redirect/google-patents%3Fpatent%3DUS5153591&amp;usg=AFQjCNE8AMzuuu1_cj6WXCXVw9OdAJl_IQ" data-is-grant="true"></a><a id="appbar-read-patent-link" href="//docs.google.com/viewer?url=patentimages.storage.googleapis.com/pdfs/US5153591.pdf"></a><a id="appbar-download-pdf-link" href="//patentimages.storage.googleapis.com/pdfs/US5153591.pdf"></a></div><div class="kd-buttonbar right" id="right-toolbar-buttons"></div></div><div id="books-microdata" itemscope=""itemtype="http://schema.org/Book"itemid="http://www.google.com/patents/US5153591" style="display:none"><span itemprop="description">Data compression and decompression utilizing, e.g., the Ziv-Lempel algorithm is simplified by utilizing a tree structure for the dictionary in which alternative symbols at a given position in a symbol sequence (a,b,c) are linked by linking pointers R of a first type and successive symbols (ab,bc,ca,aba,abb,abc)...</span><span itemprop="url">http://www.google.com/patents/US5153591?utm_source=gb-gplus-share</span><span class="main-title" itemprop="name">Patent US5153591 - Method and apparatus for encoding, decoding and transmitting data in compressed form</span><img itemprop="image" src="http://www.google.com/patents?id=&amp;printsec=frontcover&amp;img=1&amp;zoom=1"alt="Patent US5153591 - Method and apparatus for encoding, decoding and transmitting data in compressed form" title="Patent US5153591 - Method and apparatus for encoding, decoding and transmitting data in compressed form"></div><div style="display: none"><ol id="ofe-gear-menu-contents" class="gbmcc"><li class="gbe gbmtc"><a class="gbmt goog-menuitem-content" id="" href="http://www.google.com/advanced_patent_search">Advanced Patent Search</a></li></ol></div><table id="viewport_table" cellpadding="0" style="clear:both" cellspacing="0"><tr><td id="viewport_td"><div class=vertical_module_list_row><div id=intl_patents class=about_content><div id=intl_patents_v><table class="patent-bibdata"><tr><td class="patent-bibdata-heading">Publication number</td><td class="single-patent-bibdata">US5153591 A</td></tr><tr><td class="patent-bibdata-heading">Publication type</td><td class="single-patent-bibdata">Grant</td></tr><tr><td class="patent-bibdata-heading">Application number</td><td class="single-patent-bibdata">US 07/623,809</td></tr><tr><td class="patent-bibdata-heading">Publication date</td><td class="single-patent-bibdata">Oct 6, 1992</td></tr><tr><td class="patent-bibdata-heading">Filing date</td><td class="single-patent-bibdata">Jul 4, 1989</td></tr><tr><td class="patent-bibdata-heading">Priority date<span class="patent-tooltip-anchor patent-question-icon"data-tooltip-text="The priority date is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the date listed."></span></td><td class="single-patent-bibdata">Jul 5, 1988</td></tr><tr><td class="patent-bibdata-heading">Fee status<span class="patent-tooltip-anchor patent-question-icon"data-tooltip-text="The fee status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status or dates listed."></span></td><td class="single-patent-bibdata">Paid</td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">Also published as</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="/patents/CA1330838C">CA1330838C</a>, </span><span class="patent-bibdata-value"><a href="/patents/DE68907812D1">DE68907812D1</a>, </span><span class="patent-bibdata-value"><a href="/patents/DE68907812T2">DE68907812T2</a>, </span><span class="patent-bibdata-value"><a href="/patents/EP0350281A1">EP0350281A1</a>, </span><span class="patent-bibdata-value"><a href="/patents/EP0350281B1">EP0350281B1</a>, </span><span class="patent-bibdata-value"><a href="/patents/WO1990000837A1">WO1990000837A1</a></span></span></td></tr><tr class="patent-bibdata-list-row alternate-patent-number"><td class="patent-bibdata-heading">Publication number</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value">07623809, </span><span class="patent-bibdata-value">623809, </span><span class="patent-bibdata-value">US 5153591 A, </span><span class="patent-bibdata-value">US 5153591A, </span><span class="patent-bibdata-value">US-A-5153591, </span><span class="patent-bibdata-value">US5153591 A, </span><span class="patent-bibdata-value">US5153591A</span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">Inventors</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="http://www.google.com/search?tbo=p&tbm=pts&hl=en&q=ininventor:%22Alan+D.+Clark%22">Alan D. Clark</a></span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">Original Assignee</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="http://www.google.com/search?tbo=p&tbm=pts&hl=en&q=inassignee:%22British+Telecommunications+Public+Limited+Company%22">British Telecommunications Public Limited Company</a></span></span></td></tr><tr class="patent-bibdata-list-row "><td class="patent-bibdata-heading">Export Citation</td><td><span class="patent-bibdata-value-list"><span class="patent-bibdata-value"><a href="/patents/US5153591.bibtex">BiBTeX</a>, </span><span class="patent-bibdata-value"><a href="/patents/US5153591.enw">EndNote</a>, </span><span class="patent-bibdata-value"><a href="/patents/US5153591.ris">RefMan</a></span></span></td></tr><tr class="patent-internal-links"><td colspan=2><span class="patent-bibdata-value"><a href="#backward-citations">Patent Citations</a> (7),</span> <span class="patent-bibdata-value"><a href="#npl-citations">Non-Patent Citations</a> (6),</span> <span class="patent-bibdata-value"><a href="#forward-citations">Referenced by</a> (102),</span> <span class="patent-bibdata-value"><a href="#classifications">Classifications</a> (14),</span> <span class="patent-bibdata-value"><a href="#legal-events">Legal Events</a> (6)</span> </td></tr><tr><td colspan=2 class="patent-bibdata-external-link-spacer-top"></td></tr><tr class="patent-bibdata-external-link-spacer-bottom"></tr><tr><td colspan=2><span class="patent-bibdata-heading">External Links:&nbsp;</span><span><span class="patent-bibdata-value"><a href="http://www.google.com/url?id=fEY0BAABERAJ&q=http://patft.uspto.gov/netacgi/nph-Parser%3FSect2%3DPTO1%26Sect2%3DHITOFF%26p%3D1%26u%3D/netahtml/PTO/search-bool.html%26r%3D1%26f%3DG%26l%3D50%26d%3DPALL%26RefSrch%3Dyes%26Query%3DPN/5153591&usg=AFQjCNEHo-IRg_8NEH6U0pDv1BjSz1Hdlg">USPTO</a>, </span><span class="patent-bibdata-value"><a href="http://www.google.com/url?id=fEY0BAABERAJ&q=http://assignments.uspto.gov/assignments/q%3Fdb%3Dpat%26pat%3D5153591&usg=AFQjCNGq9uv7D_JvsFCvW7IRUckZGL4jyA">USPTO Assignment</a>, </span><span class="patent-bibdata-value"><a href="http://www.google.com/url?id=fEY0BAABERAJ&q=http://worldwide.espacenet.com/publicationDetails/biblio%3FCC%3DUS%26NR%3D5153591A%26KC%3DA%26FT%3DD&usg=AFQjCNE-iCoqY7BwSM-O323gHsWgWqj-Zw">Espacenet</a></span></span></td></tr><tr class="patent-bibdata-group-spacer"></tr></table><div class="number-and-title"><span class="patent-title"><invention-title mxw-id="PT53700066" lang="EN" load-source="patent-office">Method and apparatus for encoding, decoding and transmitting data in compressed form</invention-title></span><br><span class="patent-number">US 5153591 A</span></div><div class="patent-section patent-abstract-section"><div class="patent-section-header"><span class="patent-section-title">Abstract</span></div><div class="patent-text"><abstract mxw-id="PA37163578" lang="EN" load-source="patent-office"> <div class="abstract">Data compression and decompression utilizing, e.g., the Ziv-Lempel algorithm is simplified by utilizing a tree structure for the dictionary in which alternative symbols at a given position in a symbol sequence (a,b,c) are linked by linking pointers R of a first type and successive symbols (ab,bc,ca,aba,abb,abc) are linked by linking pointers D of a second type. For example, the sequence ab may continue with any one of the symbols a,b, and c grouped together by R pointers in a list below the final symbol of the sequence ab. Each symbol is defined by an associated pair of D and R pointers, in conjunction with a parent pointer P which identifies its parent. Symbols having no D pointers extending therefrom are pruned from the tree and transferred to a free list as shown in FIG. 8(b).</div>
  </abstract></div></div><div class="patent-section patent-drawings-section"><div class="patent-section-header"><span class="patent-section-title">Images<span class="patent-section-count">(12)</span></span></div><div class="patent-drawings-body"><div class="patent-drawings-carousel"><div class="drawings"><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/pages/US5153591-1.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/pages/US5153591-1.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/pages/US5153591-2.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/pages/US5153591-2.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/pages/US5153591-3.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/pages/US5153591-3.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/pages/US5153591-4.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/pages/US5153591-4.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/pages/US5153591-5.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/pages/US5153591-5.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/pages/US5153591-6.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/pages/US5153591-6.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/pages/US5153591-7.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/pages/US5153591-7.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/pages/US5153591-8.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/pages/US5153591-8.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/pages/US5153591-9.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/pages/US5153591-9.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/pages/US5153591-10.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/pages/US5153591-10.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/pages/US5153591-11.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/pages/US5153591-11.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div><div class="patent-image"><div class="patent-thumbnail"><a href="//patentimages.storage.googleapis.com/pages/US5153591-12.png"><img class="patent-thumbnail-image" alt="Patent Drawing"src="//patentimages.storage.googleapis.com/thumbnails/pages/US5153591-12.png" /></a></div><div class="patent-thumbnail-caption">&nbsp;</div></div></div></div><div class="patent-drawings-control patent-drawings-prev"><img class="patent-drawings-button-img" alt="Previous page"src="/googlebooks/images/kennedy/page_left.png"width="21" height="21" /></div><div class="patent-drawings-control patent-drawings-next"><img class="patent-drawings-button-img" alt="Next page"src="/googlebooks/images/kennedy/page_right.png"width="21" height="21" /></div></div></div><div class="patent-post-drawings"></div><div class="patent-section patent-claims-section"><div class="patent-section-header"><span class="patent-section-title">Claims<span class="patent-section-count">(68)</span></span></div><div class="patent-text"><div mxw-id="PCLM4563774" lang="EN" load-source="patent-office" class="claims">
    <claim-statement>I claim:</claim-statement> <div class="claim"> <div num="1" class="claim">
      <div class="claim-text">1. A method of compressing input data comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="2" class="claim">
      <div class="claim-text">2. A method as claimed in claim 1 wherein all the indexed memory locations forming the dictionary are tested before the next symbol to be stored is stored in a freed memory location.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="3" class="claim">
      <div class="claim-text">3. A method as claimed in claim 1 wherein those indexed memory locations which do not contain nodes of the search tree are linked by pointers to form a free list and nodes of the search tree are deleted by re-setting points to bypass the deleted nodes and connecting them to the free list, whereby the search tree is maintained as a connected whole.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="4" class="claim">
      <div class="claim-text">4. A method as claimed in claim 1 wherein the input data consists of a stream of binary digits representing characters, and the symbols stored in the search tree are each made up of sequences of binary digits, and wherein the number of bits per sequence is selected by the processor, the number of bits per character of the input data either being unknown or being different from the number of bits per sequence selected by the processor.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="5" class="claim">
      <div class="claim-text">5. A method as claimed in claim 1 wherein each linking pointer of the second type points to a first stored symbol of an ordered list of alternative stored symbols of the search tree and successive stored symbols in said ordered list are connected by linking pointers of the first type which point to each succeeding stored symbol in said list.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="6" class="claim">
      <div class="claim-text">6. A method as claimed in claim 5 wherein linking pointers of the first type are used to search through the list of alternative stored symbols to find a match for the most recently read input symbol and, if a match is found, to obtain the pointer of the second type, if present.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="7" class="claim">
      <div class="claim-text">7. A method as claimed in claim 1 wherein each linking pointer of the second type points to any one of a list of alternative stored symbols of the search tree, the stored symbols in said list being connected to each other by pointers of the first type pointing in one direction and also by pointers of the first type pointing in the opposite direction so as to enable any stored symbol in the list to be accessed.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="8" class="claim">
      <div class="claim-text">8. A method as claimed in claim 1 wherein, before the input data is processed, the memory is initially provided with stored symbols each of which corresponds to a sequence of symbols likely to occur in the input data, said initially provided stored symbols being stored as nodes in the search tree.</div>
    </div>
    </div> <div class="claim"> <div num="9" class="claim">
      <div class="claim-text">9. A method of compressing input data comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries modified by the proviso that recently created nodes of the search tree are protected against deletion.</div>
    </div>
    </div> <div class="claim"> <div num="10" class="claim">
      <div class="claim-text">10. A method of compressing input data comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries wherein each node of the search tree is associated with a respective counter which is incremented each time the associated node is used, and the compressed output data comprises codewords whose lengths are related to the contents of the counters such that the shortest codewords represent the most frequently used nodes.</div>
    </div>
    </div> <div class="claim"> <div num="11" class="claim">
      <div class="claim-text">11. A method of compressing input data comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries wherein the nodes of the search tree are stored in order in the memory and the order in which they are stored is re-arranged by raising the ordinal value of a node after it has been used whereby rarely used nodes acquire a low ordinary value, and are deleted.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="12" class="claim">
      <div class="claim-text">12. A method as claimed in claim 11 wherein the ordinal value of the used node is increased by one, and the ordinal value of the node immediately above the used node is decreased by one, whereby these two nodes exchange ordinal values.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="13" class="claim">
      <div class="claim-text">13. A method as claimed in claim 11 wherein the ordinal value of the used node is increased to the maximum value, and the ordinal values of all the nodes above the used node are decreased by one.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="14" class="claim">
      <div class="claim-text">14. A method as claimed in claim 11 wherein each node of the search tree has an associated length index and the compressed output data comprises codewords whose lengths are related to the length indices such that the shortest codewords represent nodes with highest ordinal values.</div>
    </div>
    </div> <div class="claim"> <div num="15" class="claim">
      <div class="claim-text">15. A method of compressing input data comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries wherein the input data includes spaces between sequences of symbols and the process of generating a new stored path of the search tree is terminated when such a space is detected.</div>
    </div>
    </div> <div class="claim"> <div num="16" class="claim">
      <div class="claim-text">16. A method of compressing input data comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries wherein the input data consists of a stream of binary digits representing characters, and the symbols stored in the search tree are each made up of sequences of binary digits, and wherein the number of bits per sequence is selected by the processor, the number of bits per character of the input data either being unknown or being different from the number of bits per sequence selected by the processor and wherein the processor is arranged to perform the selection in response to an external command signal from a user.</div>
    </div>
    </div> <div class="claim"> <div num="17" class="claim">
      <div class="claim-text">17. A method of compressing input data comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries wherein the input data consists of a stream of binary digits representing characters, and the symbols stored in the search tree are each made up of sequences of binary digits, and wherein the number of bits per sequence is selected by the processor, the number of bits per character of the input data either being unknown or being different from the number of bits per sequence selected by the processor and wherein the number of bits per sequence is initially varied and the resulting compression ratio between the input data and the output data is measured, and the number of bits per sequence for the stored symbols of the search tree is selected on the basis of the measured compression ratio.</div>
    </div>
    </div> <div class="claim"> <div num="18" class="claim">
      <div class="claim-text">18. A method of compressing input data comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries wherein the dictionary is reinitialised in response to a command signal received, in use, from an associated decoder.</div>
    </div>
    </div> <div class="claim"> <div num="19" class="claim">
      <div class="claim-text">19. A method of compressing input data comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries wherein, in use, a checksum for the dictionary is periodically calculated and a corresponding output signal generated.</div>
    </div>
    </div> <div class="claim"> <div num="20" class="claim">
      <div class="claim-text">20. A method of compressing input data comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries wherein the dictionary is retained for further use, and including performing a checksum calculation on the dictionary prior to any such further use, receiving a corresponding checksum from another such dictionary, comparing the checksums and reinitalising the dictionary if the checksums are not identical.</div>
    </div>
    </div> <div class="claim"> <div num="21" class="claim">
      <div class="claim-text">21. A method of storing data comprising compressing the data by a method comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries, and storing the compressed data in a mass storage medium.</div>
    </div>
    </div> <div class="claim"> <div num="22" class="claim">
      <div class="claim-text">22. A method of decoding compressed data which has been compressed by a method comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries, reading successive characters of the compressed data with a processor provided with a memory, storing in the memory a dictionary in the form of a search tree of symbols which is built up from the compressed data, and utilising the search tree to translate the compressed data to decoded data, stored symbol in the search tree being linked by linking pointers of two distinct types; a point of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and the same prefix and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="23" class="claim">
      <div class="claim-text">23. A method as claimed in claim 22 wherein all the indexed memory locations forming the dictionary are tested before the next symbol to be stored is stored in a freed memory location.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="24" class="claim">
      <div class="claim-text">24. A method as claimed in claim 22 wherein those indexed memory locations which do not contain nodes of the search tree are linked by pointers to form a free list and nodes of the search tree are deleted by re-setting pointers to bypass the deleted nodes and connecting them to the free list, whereby the search tree is maintained as a connected whole.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="25" class="claim">
      <div class="claim-text">25. A method as claimed in claim 22 wherein each linking pointer of the second type points to a first stored symbol of an ordered list of alternative stored symbols of the search tree and successive stored symbols in said ordered list are connected by linking pointers of the first type which point to each succeeding stored symbol in said list.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="26" class="claim">
      <div class="claim-text">26. A method as claimed in claim 22 wherein each linking pointer of the second type points to any one of a list of alternative stored symbols of the search tree, the stored symbols in said list being connected to each other by pointers of the first type pointing in one direction and also by pointers of the first type pointing in the opposite direction so as to enable any stored symbol in the list to be accessed.</div>
    </div>
    </div> <div class="claim"> <div num="27" class="claim">
      <div class="claim-text">27. A method of decoding compressed data which has been compressed by a method comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries comprising reading successive characters of the compressed data with a processor provided with a memory, storing in the memory a dictionary in the form of a search tree of symbols which is built up from the compressed data, and utilising the search tree to translate the compressed data to decoded data, stored symbol in the search tree being linked by linking pointers of two distinct types; a point of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and the same prefix and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries modified by the proviso that recently created nodes of the search tree are protected against deletion.</div>
    </div>
    </div> <div class="claim"> <div num="28" class="claim">
      <div class="claim-text">28. A method of decoding compressed data which has been compressed by a method comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries comprising reading successive characters of the compressed data with a processor provided with a memory, storing in the memory a dictionary in the form of a search tree of symbols which is built up from the compressed data, and utilising the search tree to translate the compressed data to decoded data, stored symbol in the search tree being linked by linking pointers of two distinct types; a point of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and the same prefix and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries wherein each node of the search tree is associated with a respective counter which is incremented each time the associated node is used, the shortest codewords are allocated to the most frequently used nodes, and the compressed data to be decoded comprises codewords of which the shortest codewords represent the most frequently used nodes of the search tree of a corresponding encoder.</div>
    </div>
    </div> <div class="claim"> <div num="29" class="claim">
      <div class="claim-text">29. A method of decoding compressed data which has been compressed by a method comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries comprising reading successive characters of the compressed data with a processor provided with a memory, storing in the memory a dictionary in the form of a search tree of symbols which is built up from the compressed data, and utilising the search tree to translate the compressed data to decoded data, stored symbol in the search tree being linked by linking pointers of two distinct types; a point of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and the same prefix and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries wherein the nodes of the search tree are stored in order in the memory and the order in which they are stored is re-arranged by raising the ordinal value of a node after it has been used whereby rarely used nodes acquire a low ordinary value, and are deleted.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="30" class="claim">
      <div class="claim-text">30. A method as claimed in claim 29 wherein each node of the search tree has an associated length index such that the shortest codewords represent nodes with the highest ordinal values and the compressed data to be decoded comprisee codewords whose lengths are related to the length indices such that the shortest codewords represent highest ordinal value nodes of the search tree of a corresponding encoder.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="31" class="claim">
      <div class="claim-text">31. A method as claimed in claim 29 wherein the ordinal value of the used node is increased by one, and the ordinal value of the node immediately above the used node is decreased by one, whereby these two nodes exchange ordinal values.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="32" class="claim">
      <div class="claim-text">32. A method as claimed in claim 29 wherein the ordinal value of the used node is increased to the maximum value, and the ordinal values of all the nodes above the used code are decreased by one.</div>
    </div>
    </div> <div class="claim"> <div num="33" class="claim">
      <div class="claim-text">33. A method of decoding compressed data which has been compressed by a method comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries comprising reading successive characters of the compressed data with a processor provided with a memory, storing in the memory a dictionary in the form of a search tree of symbols which is built up from the compressed data, and utilising the search tree to translate the compressed data to decoded data, stored symbol in the search tree being linked by linking pointers of two distinct types; a point of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and the same prefix and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries including detecting when received compressed data corresponds to empty or free memory locations and generating a corresponding output signal.</div>
    </div>
    </div> <div class="claim"> <div num="34" class="claim">
      <div class="claim-text">34. A method of decoding compressed data which has been compressed by a method comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries comprising reading successive characters of the compressed data with a processor provided with a memory, storing in the memory a dictionary in the form of a search tree of symbols which is built up from the compressed data, and utilising the search tree to translate the compressed data to decoded data, stored symbol in the search tree being linked by linking pointers of two distinct types; a point of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and the same prefix and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries wherein the dictionary is retained for further use, and including performing a checksum calculation on the dictionary prior to any such further use, receiving a corresponding checksum from another such dictionary, comparing the checksums and reinitialising the dictionary if the checksums are not identical.</div>
    </div>
    </div> <div class="claim"> <div num="35" class="claim">
      <div class="claim-text">35. A method of transmitting data comprising encoding the data by a method comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries, transmitting the resulting compressed data to a remote location, and decoding the compressed data by a corresponding method comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries comprising reading successive characters of the compressed data with a processor provided with a memory, storing in the memory a dictionary in the form of a search tree of symbols which is built up from the compressed data, and utilising the search tree to translate the compressed data to decoded data, stored symbol in the search tree being linked by linking pointers of two distinct types; a point of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and the same prefix and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols, determining when the memory is full, testing and deleting sequential indexed memory locations of the search tree if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node whereby the resulting freed memory locations are made available for new dictionary entries.</div>
    </div>
    </div> <div class="claim"> <div num="36" class="claim">
      <div class="claim-text">36. An encoder for compressing input data comprising a processor capable of receiving successive symbols of input data, a memory having indexed memory locations, means for storing in the memory a search tree of symbols which has paths representative of strings of symbols in the input data, and means for matching symbol strings in the input data with previously stored paths in the search tree and for generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="37" class="claim">
      <div class="claim-text">37. An encoder as claimed in claim 36 wherein the processor is further arranged to test all the indexed memory locations forming the dictionary before the next symbol to be stored is stored in a freed memory location.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="38" class="claim">
      <div class="claim-text">38. An encoder as claimed in claim 36 wherein each linking pointer of the second type points to a first stored symbol of an ordered list of alternative stored symbols of the search tree and successive stored symbols in said ordered list are connected by linking pointers of the first type which point to each succeeding stored symbol in said list.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="39" class="claim">
      <div class="claim-text">39. An encoder as claimed in claim 36 wherein the processor is arranged to link by pointers those indexed memory locations which do not contain nodes of the search tree to form a free list and to delete nodes of the search tree by re-setting pointers to bypass the deleted nodes and connecting them to a free list, whereby the search tree is maintained as a connected whole.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="40" class="claim">
      <div class="claim-text">40. An encoder as claimed in claim 36 for encoding input data consisting of a stream of binary digits representing characters, wherein the symbols stored in the search tree are each made up of sequences of binary digits, and wherein the processor is arranged to select the number of bits per sequence such as to be different from the number of bits per character of the input data, if known.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="41" class="claim">
      <div class="claim-text">41. An encoder as claimed in claim 40 wherein the number of bits per sequence selected by the processor is initially varied and the resulting compression ratio between the input data and the output data is measured, and the number of bits per sequence for the stored symbols of the search tree is selected on the basis of the measured compression ratio.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="42" class="claim">
      <div class="claim-text">42. An encoder as claimed in claim 36 wherein each linking pointer of the second type points to any one of a list of alternative stored symbols of the search tree, the stored symbols in said list being connected to each other by pointers of the first type pointing in one direction and also by pointers of the first type pointing in the opposite direction so as to enable any stored symbol in the list to be accessed.</div>
    </div>
    </div> <div class="claim"> <div num="43" class="claim">
      <div class="claim-text">43. An encoder for compressing input data comprising a processor capable of receiving successive symbols of input data, a memory having indexed memory locations, means for storing in the memory a search tree of symbols which has paths representative of strings of symbols in the input data, and means for matching symbol strings in the input data with previously stored paths in the search tree and for generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries and wherein the process is arranged to protect recently created nodes of the search tree against deletion.</div>
    </div>
    </div> <div class="claim"> <div num="44" class="claim">
      <div class="claim-text">44. An encoder for compressing input data comprising a processor capable of receiving successive symbols of input data, a memory having indexed memory locations, means for storing in the memory a search tree of symbols which has paths representative of strings of symbols in the input data, and means for matching symbol strings in the input data with previously stored paths in the search tree and for generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries and wherein each node of the search tree is associated with a respective counter which is incremented each time the associated node is used, and the processor is arranged to provide compressed output data comprising codewords whose lengths are related to the contents of the counters such that the shortest codewords represent the most frequently used nodes.</div>
    </div>
    </div> <div class="claim"> <div num="45" class="claim">
      <div class="claim-text">45. An encoder for compressing input data comprising a processor capable of receiving successive symbols of input data, a memory having indexed memory locations, means for storing in the memory a search tree of symbols which has paths representative of strings of symbols in the input data, and means for matching symbol strings in the input data with previously stored paths in the search tree and for generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries and wherein the nodes of the search tree are stored in order in the memory and the processor is arranged to re-arrange the order in which they are stored by raising the ordinal value of a node after it has been used whereby rarely used nodes acquire a low ordinal value, and to delete nodes having the lowest ordinal values.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="46" class="claim">
      <div class="claim-text">46. An encoder as claimed in claim 45 wherein the ordinal value of the used node is increased by one, and the ordinal value of the node immediately above the used node is decreased by one, whereby these two nodes exchange ordinal values.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="47" class="claim">
      <div class="claim-text">47. An encoder as claimed in claim 45 wherein the ordinal value of the used node is increased to the maximum value, and the ordinal values of all the nodes above the used node are decreased by one.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="48" class="claim">
      <div class="claim-text">48. An encoder as claimed in claims 45, 46 or 47 wherein each node of the search tree has an associated length index and the processor is arranged to provide compressed output data comprising codewords whose lengths are related to the length indices such that the shortest codewords represent nodes with the highest ordinal values.</div>
    </div>
    </div> <div class="claim"> <div num="49" class="claim">
      <div class="claim-text">49. An encoder for compressing input data comprising a processor capable of receiving successive symbols of input data, a memory having indexed memory locations, means for storing in the memory a search tree of symbols which has paths representative of strings of symbols in the input data, and means for matching symbol strings in the input data with previously stored paths in the search tree and for generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries and for encoding input data including spaces between sequences of symbols and wherein the processor is arranged to terminate the process of generating a new stored path of the search tree when such a space is detected.</div>
    </div>
    </div> <div class="claim"> <div num="50" class="claim">
      <div class="claim-text">50. An encoder for compressing input data comprising a processor capable of receiving successive symbols of input data, a memory having indexed memory locations, means for storing in the memory a search tree of symbols which has paths representative of strings of symbols in the input data, and means for matching symbol strings in the input data with previously stored paths in the search tree and for generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries and wherein the input data is of a stream of binary digits representing characters, wherein the symbols stored in the search tree are each made up of sequences of binary digits, and wherein the processor is arranged to select the number of bits per sequence such as to be different from the number of bits per character of the input data, if known and wherein the processor is arranged to perform the selection in response to an external command signal from a user.</div>
    </div>
    </div> <div class="claim"> <div num="51" class="claim">
      <div class="claim-text">51. An encoder for compressing input data comprising a processor capable of receiving successive symbols of input data, a memory having indexed memory locations, means for storing in the memory a search tree of symbols which has paths representative of strings of symbols in the input data, and means for matching symbol strings in the input data with previously stored paths in the search tree and for generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries and wherein, in use, the processor is responsive to a command signal received from an associated decoder to reinitialise its dictionary.</div>
    </div>
    </div> <div class="claim"> <div num="52" class="claim">
      <div class="claim-text">52. An encoder for compressing input data comprising a processor capable of receiving successive symbols of input data, a memory having indexed memory locations, means for storing in the memory a search tree of symbols which has paths representative of strings of symbols in the input data, and means for matching symbol strings in the input data with previously stored paths in the search tree and for generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries and wherein, in use, the processor periodically calculates a checksum for the dictionary and generates a corresponding output signal.</div>
    </div>
    </div> <div class="claim"> <div num="53" class="claim">
      <div class="claim-text">53. An encoder for compressing input data comprising a processor capable of receiving successive symbols of input data, a memory having indexed memory locations, means for storing in the memory a search tree of symbols which has paths representative of strings of symbols in the input data, and means for matching symbol strings in the input data with previously stored paths in the search tree and for generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries and wherein the dictionary is retained for further use and the processor is arranged to perform a checksum calculation on the dictionary prior to any such further use and to generate a corresponding output signal, to compare this checksum with a corresponding checksum received, in use, from an associated decoder, and to reinitialise the dictionary to an initial state if the checksums are not identical.</div>
    </div>
    </div> <div class="claim"> <div num="54" class="claim">
      <div class="claim-text">54. A decoder for decoding compressed data comprising a processor capable of receiving successive symbols of compressed data, a memory having indexed memory locations and means for storing in the memory a dictionary in the form of a search tree of symbols, the processor being arranged to build up the search tree from the compressed data and to utilise the search tree to translate the compressed data to decoded data, stored symbols in the search tree being linked by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="55" class="claim">
      <div class="claim-text">55. A decoder as claimed in claim 54 wherein in use, each linking pointer of the second type points to a first stored symbol of an ordered list of alternative stored symbols of the search tree and successive stored symbols in said ordered list are connected by linking pointers of the first type which point to each succeeding stored symbol in said list.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="56" class="claim">
      <div class="claim-text">56. A decoder as claimed in claim 54 wherein in use, each linking pointer of the second type points to any one of a list of alternative stored symbols of the search tree, the stored symbols in said list being connected to each other by pointers of the first type pointing in one direction and also by pointers of the first type pointing in the opposite direction so as to enable any stored symbol in the list to be accessed.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="57" class="claim">
      <div class="claim-text">57. A decoder as claimed in claim 54 wherein the processor is further arranged to test all the indexed memory locations forming the dictionary before the next symbol to be stored is stored in a freed memory location.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="58" class="claim">
      <div class="claim-text">58. A decoder as claimed in claim 54 wherein the processor is arranged to link by pointers those indexed memory locations which do not contain nodes of the search tree link by pointers to form a free list and to delete nodes of the search tree by re-setting pointers to bypass the deleted nodes and connecting them to the free list, whereby the search tree is maintained as a connected whole.</div>
    </div>
    </div> <div class="claim"> <div num="59" class="claim">
      <div class="claim-text">59. A decoder for decoding compressed data comprising a processor capable of receiving successive symbols of compressed data, a memory having indexed memory locations and means for storing in the memory a dictionary in the form of a search tree of symbols, the processor being arranged to build up the search tree from the compressed data and to utilise the search tree to translate the compressed data to decoded data, stored symbols in the search tree being linked by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries and wherein the processor is arranged to protect recently created nodes of the search tree against deletion.</div>
    </div>
    </div> <div class="claim"> <div num="60" class="claim">
      <div class="claim-text">60. A decoder for decoding compressed data comprising a processor capable of receiving successive symbols of compressed data, a memory having indexed memory locations and means for storing in the memory a dictionary in the form of a search tree of symbols, the processor being arranged to build up the search tree from the compressed data and to utilise the search tree to translate the compressed data to decoded data, stored symbols in the search tree being linked by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries and wherein each node of the search tree is associated with a respective counter which is associated with a respective counter which is incremented each time the associated node is used, and the processor is arranged to provide compressed output data comprising codewords whose lengths are related to the contents of the counters such that the shortest codewords represent the most frequently used nodes.</div>
    </div>
    </div> <div class="claim"> <div num="61" class="claim">
      <div class="claim-text">61. A decoder for decoding compressed data comprising a processor capable of receiving successive symbols of compressed data, a memory having indexed memory locations and means for storing in the memory a dictionary in the form of a search tree of symbols, the processor being arranged to build up the search tree from the compressed data and to utilise the search tree to translate the compressed data to decoded data, stored symbols in the search tree being linked by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries and wherein the nodes of the search tree are stored in order in the memory and the processor is arranged to re-arrange the order in which they are stored by raising the ordinal value of a node after it has been used whereby rarely used nodes acquire a low ordinal value, and to delete nodes having the lowest ordinal value.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="62" class="claim">
      <div class="claim-text">62. A decoder as claimed in claim 61 wherein the ordinal value of the used node is increased by one, and the ordinal value of the node immediately above the used node is decreased by one, whereby these two nodes exchange ordinal values.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="63" class="claim">
      <div class="claim-text">63. A decoder as claimed in claim 61 wherein the ordinal value of the used node is increased to the maximum value, and the ordinal values of all the nodes above the used node are decreased by one.</div>
    </div>
    </div> <div class="claim-dependent"> <div num="64" class="claim">
      <div class="claim-text">64. A decoder as claimed in claim 61 wherein each node of the search tree has an associated length index and the processor is arranged to provide compressed output data comprising codewords whose lengths are related to the length indices such that the shortest codewords represent nodes with the highest ordinal values.</div>
    </div>
    </div> <div class="claim"> <div num="65" class="claim">
      <div class="claim-text">65. A decoder for decoding compressed data comprising a processor capable of receiving successive symbols of compressed data, a memory having indexed memory locations and means for storing in the memory a dictionary in the form of a search tree of symbols, the processor being arranged to build up the search tree from the compressed data and to utilise the search tree to translate the compressed data to decoded data, stored symbols in the search tree being linked by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries and wherein, in use, the processor is arranged to detect when received compressed data corresponds to empty or free memory locations and to generate a corresponding output signal for transmission to an associated encoder.</div>
    </div>
    </div> <div class="claim"> <div num="66" class="claim">
      <div class="claim-text">66. A decoder for decoding compressed data comprising a processor capable of receiving successive symbols of compressed data, a memory having indexed memory locations and means for storing in the memory a dictionary in the form of a search tree of symbols, the processor being arranged to build up the search tree from the compressed data and to utilise the search tree to translate the compressed data to decoded data, stored symbols in the search tree being linked by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries and wherein the dictionary is retained for further use and the processor is arranged to perform a checksum calculation on the dictionary prior to any such further use and to generate a corresponding output signal for transmission to an associated encoder, to compare this checksum with a corresponding checksum received, in use, from said encoder, and to reinitialise the dictionary if the checksums are not identical.</div>
    </div>
    </div> <div class="claim"> <div num="67" class="claim">
      <div class="claim-text">67. Data processing apparatus comprising an encoder comprising a processor capable of receiving successive symbols of input data, a memory having indexed memory locations, means for storing in the memory a search tree of symbols which has paths representative of strings of symbols in the input data, and means for matching symbol strings in the input data with previously stored paths in the search tree and for generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries, a corresponding decoder comprising a processor capable of receiving successive symbols of compressed data, a memory having indexed memory locations and means for storing in the memory a dictionary in the form of a search tree of symbols, the processor being arranged to build up the search tree from the compressed data and to utilise the search tree to translate the compressed data to decoded data, stored symbols in the search tree being linked by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries and a data link for transmitting the compressed data between the encoder and decoder.</div>
    </div>
    </div> <div class="claim"> <div num="68" class="claim">
      <div class="claim-text">68. Data processing apparatus comprising an encoder comprising a processor capable of receiving successive symbols of input data, a memory having indexed memory locations, means for storing in the memory a search tree of symbols which has paths representative of strings of symbols in the input data, and means for matching symbol strings in the input data with previously stored paths in the search tree and for generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries, a corresponding decoder comprising a processor capable of receiving successive symbols of compressed data, a memory having indexed memory locations and means for storing in the memory a dictionary in the form of a search tree of symbols, the processor being arranged to build up the search tree from the compressed data and to utilise the search tree to translate the compressed data to decoded data, stored symbols in the search tree being linked by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols said processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, and to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node so as to make the resulting freed memory locations available for new dictionary entries and a mass storage medium accessible by the encoder and decoder.</div>
    </div>
  </div> </div></div></div><div class="patent-section patent-description-section"><div class="patent-section-header"><span class="patent-section-title">Description</span></div><div class="patent-text"><div mxw-id="PDES66235143" lang="EN" load-source="patent-office" class="description">
    <heading>FIELD OF THE INVENTION</heading> <p>The present invention relates to methods and apparatus for compressing data, methods and apparatus for decoding the compressed data, a method of transmitting data and data processing apparatus utilising compressed data. The above methods and apparatus all utilise an adaptive string encoding technique which involves a dictionary having a search tree and means for maintaining this search tree. The invention is applicable particularly but not exclusively to adaptive string encoding utilising the Ziv-Lempel algorithm. The basic form of this algorithm is described in IEEE Transactions IT-23, May 3rd 1977 pp337-343 "A Universal Algorithm for Sequential Data Compression"--J. Ziv and A. Lempel.</p>
    <heading>BACKGROUND OF THE INVENTION</heading> <p>The basic Ziv-Lempel encoder has a dictionary, in which each entry has an associated index number. Initially the dictionary contains only the basic alphabet of the source. During the encoding process, new dictionary entries are formed by appending single symbols to existing entries. The dictionary may be considered to be in the form of a search tree of connected symbols of the source alphabet. Nodes in the tree correspond to specific sequences of symbols which begin at the root of the tree and the data is compressed by recognising strings of symbols in the uncompressed input data which correspond to nodes in the tree, and transmitting the index of the memory location corresponding to the matched node. A corresponding search tree is provided in the decoder which receives the index representing the compressed data and the reverse process is performed by the decoder to recover the compressed data in its original form. The search tree of the encoder gradually grows during the encoding process as further strings of symbols are identified in the input data and in order to enable the decoder to decode the compressed data, its search tree must be updated to correspond with the search tree of the encoder.</p>
    <p>The Ziv-Lempel algorithm has been found difficult to implement in practice, since it requires an indefinitely large memory to store the search tree in its basic form. The use of data structures such as the "trie" structure disclosed by Sussenguth (ACM Sort Symposium 1962) can however greatly improve the storage efficiency and search time associated with text strings. EPA127,815 (Miller and Wegman) and EPA129439 (Welch) disclose similar implementations of the Ziv Lempel algorithm based on the use of a trie structure.</p>
    <p>In EPA127,815 (Miller and Wegman) improvements are described to the Ziv-Lempel algorithm which enhance the memory efficiency and speed up the encoding process. The dictionary is held in the form of a tree, with each node containing a single character and a pointer to the parent node which represents the prefix string. A hash table is used to determine, given a matched sub-string and the next input character, whether the extended sub-string is in the dictionary. However, the hash table requires a significant amount of memory and processing time in addition to that needed for the storage of the basic tree structure used to encode the dictionary.</p>
    <p>EPA129,439 (Welch) discloses a high speed data compression and decompression apparatus and method in which strings of symbols in the input message are recognised and stored. Strings are entered into a string table and are searched for in the string table by means of a hashing function which utilises a hash key comprising a prior code signal and an extension character to provide a set of N hash table addresses where N is typically 1 to 4. The N RAM locations are sequentially searched and if the item is not in the N locations, it is considered not to be in the table. This procedure is stated to reduce compression efficiency but to simplify substantially the implementation.</p>
    <p>U.S. Pat. No. 4,612,532 (Bacon et al) discloses a system, not based on the Ziv-Lempel algorithm, for the dynamic encoding of a stream of characters in which each character is associated with a "follow set" table of characters which usually follow it, in order of the frequency with which they occur. These tables are of a pre-determined length and therefore the degree of branching of the tree is inevitably restricted.</p>
    <p>U.S. Pat. No. 4,464,650 (Eastman et al) discloses a method based on the Ziv-Lempel algorithm of compressing input data comprising feeding successive symbols of the data into a processor provided with a memory, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory which has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data. However the data structure utilised for the circuitry is highly complex and furthermore a hashing function is required.</p>
    <p>A particular problem inherent in the implementation of an encoder of the type described occurs when the search tree grows to the limit of the memory space available. It is necessary to reduce the size of (i.e. "prune") the search tree in order to recover memory space for the storage of new strings. A number of well known methods exist for performing this type of function, which are reviewed in Computer Architecture and Parallel Processing (Hwang and Briggs, McGraw Hill 1985). The commonly used techniques are LRU--Least Recently Used, applied to the Ziv Lempel algorithm by Miller and Wegman (EPA127815), LFU--Least Frequently Used, applied to a similar string encoding algorithm by Mayne and James (Information Compression by Factorising Common strings, Computer Journal, 18,2 pp 157-160, 1975), FIFO--First In First Out, LIFO--Last In First Out, the CLOCK algorithm, and Random replacement, the last four techniques cited have not been applied to the Ziv Lempel algorithm. In addition, it is known to reset the search tree back to the initial state which bears a penalty in terms of compression performance, and also to cease adding new strings when the memory capacity is exhausted which will give poor performance if the characteristics of the data change.</p>
    <heading>SUMMARY OF THE INVENTION</heading> <p>An object of the present invention is to provide an improvement with regard to these prior art techniques. Accordingly in one aspect the invention provides a method of compressing input data comprising reading successive symbols of the data with a processor provided with a memory having indexed memory locations, generating from strings of symbols in the input data a dictionary in the form of a search tree of symbols in the memory, which search tree has paths representative of said strings, matching symbol strings in the input data with previously stored paths in the search tree and generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence: characterised in that when the memory is full, sequential indexed memory locations of the search tree are tested and deleted if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node and the resulting freed memory locations are made available for new dictionary entries.</p>
    <p>In the abovementioned one aspect, the testing and deletions of indexed memory locations of the search tree corresponds to the deletion of some or all of those strings represented by the tree that do not form prefixes of other strings. This feature enables highly complex search trees to be stored in memories of limited size and provides a useful simplification in comparison with the arrangements of U.S. Pat. No. 4,464,650 (Eastman et al) and EPA 127,815 (Miller and Wegman).</p>
    <p>U.S. Pat. No. 4,464,650 also discloses a corresponding method of decoding compressed data comprising feeding successive symbols of the data into a processor provided with a memory, storing in the memory a dictionary in the form of a search tree of symbols, and utilising the search tree to translate the compressed data to decoded data.</p>
    <p>In another aspect, the invention provides a method of decoding compressed data which has been compressed by a method in accordance with the abovementioned one aspect of the present invention, comprising reading successive characters of the compressed data with a processor provided with a memory, storing in the memory a dictionary in the form of a search tree of symbols which is built up from the compressed data, and utilising the search tree to translate the compressed data to decoded data, stored symbols in the search tree being linked by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and the same prefix and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols: characterised in that when the memory is full, sequential indexed memory locations of the search tree are tested and deleted if they contain a node of the search tree which does not have a linking pointer of the second type pointing to another node and the resulting freed memory locations are made available for new dictionary entries.</p>
    <p>U.S. Pat. No. 4,464,650 also discloses an encoder for compressing input data comprising a processor capable of receiving successive symbols of input data, a memory, means for storing in the memory a search tree of symbols which has paths representative of strings of symbols in the input data, and means for matching symbol strings in the input data with previously stored paths in the search tree and for generating from the stored paths compressed output data corresponding to the input data.</p>
    <p>In another aspect the invention provides an encoder for compressing input data comprising a processor capable of receiving successive symbols of input data, a memory having indexed memory locations, means for storing in the memory a search tree of symbols which has paths representative of strings of symbols in the input data, and means for matching symbol strings in the input data with previously stored paths in the search tree and for generating from the stored paths compressed output data corresponding to the input data, stored symbols in the search tree being linked to form said paths by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those stored symbols are alternative possible symbols at a given position in an input symbol sequence and a pointer of the second type between stored symbols indicating that those stored symbols both occur, in order, in a possible input symbol sequence: characterised in that, in use, the processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node and to make the resulting freed memory locations available for new dictionary entries.</p>
    <p>U.S. Pat. No. 4,464,650 also discloses a decoder for decoding compressed data comprising a processor capable of receiving successive symbols of compressed data, a memory and means for storing in the memory a dictionary in the form of a search tree of symbols, the processor being arranged to utilise the search tree to translate the compressed data to decoded data.</p>
    <p>In another aspect, the invention provides a decoder for decoding compressed data comprising a processor capable of receiving successive symbols of compressed data, a memory having indexed memory locations and means for storing in the memory a dictionary in the form of a search tree of symbols, the processor being arranged to build up the search tree from the compressed data and to utilise the search tree to translate the compressed data to decoded data, stored symbols in the search tree being linked by linking pointers of two distinct types; a pointer of the first type between stored symbols indicating that those symbols are associated with different decoded strings of symbols having the same number of symbols and are the respective last symbols of such different strings and a pointer of the second type between stored symbols indicating that those symbols are successive symbols in a string of decoded output symbols: characterised in that, in use, the processor is arranged to determine when the memory is full, to test sequential indexed memory locations of the search tree, to delete a memory location if it contains a node of the search tree which does not have a linking pointer of the second type pointing to another node and to make the resulting freed memory locations available for new dictionary entries.</p>
    <p>Further preferred features of the invention are claimed in the dependent claims.</p>
    <p>A further preferred feature which may be utilised in the present invention is described by Welch in the article "A Technique for High-Performance Data Compression" in Computer--June 1984 pp8-19. This article is incorporated herein by reference and describes a method of improving the initial performance of the Ziv-Lempel algorithm. Initially, the dictionary is almost empty and a small number of bits suffice to encode the symbol strings of the input data. As the dictionary grows, the code word size is increased up to a predetermined maximum. This improves performance during the first ten to 20 thousand symbols encoded, but at the cost of increased complexity.</p>
    <heading>BRIEF DESCRIPTION OF THE INVENTION</heading> <p>Embodiments of the invention are described below by way of example only with reference to FIGS. 1 to 13 of the accompanying drawings, of which:</p>
    <p>FIG. 1a shows one possible search tree structure for use in the invention;</p>
    <p>FIG. 1b shows a list of free memory locations associated with the search tree structure of FIG. 1a.</p>
    <p>FIG. 2a shows another, preferred structure of a search tree for use in the invention;</p>
    <p>FIG. 2b shows a list of free memory locations associated with the search tree structure of FIG. 2a.</p>
    <p>FIGS. 3a to 3f show sequential stages in the evolution of a search tree during a data compression process in accordance with the invention;</p>
    <p>FIG. 4 is a general flow diagram of an encoding algorithm which is utilised in the invention;</p>
    <p>FIG. 5 is a general flow diagram of a decoding algorithm which is utilised in the present invention;</p>
    <p>FIG. 6 is a diagram showing the insertion of a "leaf" of a search tree in a data compression process in accordance with the invention;</p>
    <p>FIG. 7 is a flow diagram showing an algorithm for updating the dictionary of the present invention;</p>
    <p>FIG. 8a shows the state of the search tree of FIG. 3f following a pruning process.</p>
    <p>FIG. 8b shows the resulting search tree and its associated list of four pruned symbols.</p>
    <p>FIG. 9 is a flow diagram of an algorithm for pruning the dictionary of the invention;</p>
    <p>FIG. 10 is a schematic diagram of a data processing system utilising an encoder in accordance with the present invention;</p>
    <p>FIG. 11 is a schematic diagram of a data processing system utilising a decoder in accordance with the present invention;</p>
    <p>FIG. 12 is a schematic diagram of part of a communications system incorporating an encoder and decoder in accordance with the present invention, and</p>
    <p>FIG. 13 is a diagram showing the arrangement of the indexed memory locations of the memory.</p>
    <heading>DETAILED DESCRIPTION OF THE DRAWINGS</heading> <p>Referring to FIG. 1a, the simplified search tree shown comprises a symbol S1 which may be followed by any one of three different symbols S2, S3 and S4. As an example, symbols S1 to S4 have been assigned the values `c`, `a`, `e` and `h`, respectively, and the tree thus represents the four strings `c`, `ca`, `ce` and `ch`. Accordingly symbol S1 is linked to symbol S2 by a linking pointer "of the second type" as referred to herein above, namely a down pointer D. Since symbols S2, S3 and S4 are different possible symbols which may occur in a string in the input data after S1, they are linked by pointers "of the first type" as referred to herein above, namely right hand pointers R and left hand pointers L. Note that similar technology is used in the representation of binary trees (refer to, for example, "The Art of Computer Programming", Volume 1 and 3, by D. Knuth); this data structure is however being used to represent an m-ary search tree.</p>
    <p>It is possible to search through the search tree from symbol S1 to any of symbols S2, S3 and S4 by using the linking pointers D and R and to search to the left of symbol S4 by following the left hand pointers L. In FIG. 1(b) two symbol locations are shown linked by a pointer and these constitute a list of free memory locations. This list is separate from the search tree but memory locations may be transferred between the free list and the search tree, the total memory capacity for symbols of the input data consisting of the memory locations in the search tree and the memory locations in the free list. In order to identify any of these symbols S1 to S4 it is necessary to know the "parent" of that symbol, namely the symbol connected to the immediately preceding down pointer D. This is indicated in each case by a parent indicator P for example, if the letter `c` was stored as symbol S1, it would be the parent of S2, S3 and S4 and their parent indicators P would indicate the memory location of `c`. In the embodiment of FIG. 1a , the parent indicators P are required in the search tree of the decoder only, and not in the search tree of the encoder. Otherwise the search trees of the encoder and decoder are identical.</p>
    <p>The nodes within the search tree of which node S is a parent will be termed dependent nodes of S, or dependants of S. A dependent node of S represents a string constructed by appending a single character to the string represented by S. There can be as many dependent nodes of some node as exist symbols in the source alphabet.</p>
    <p>FIG. 2 shows a more preferred variant in which the left hand pointers L are dispensed with and the parent indicators P occur in the search tree of both the encoder and the decoder. Otherwise the search tree structure is identical to that shown in FIG. 1. Again a free list of symbol locations is maintained in the memory as shown in FIG. 2(b).</p>
    <p>The dictionary or search tree will normally be initialised to include only the basic set of source symbols, subsequent entries or nodes representing strings of two or more symbols in length. In many practical applications it is desirable to provide additional symbols outside the normal source alphabet. These may represent for example a means for encoding repeated occurrences of a character (run length encoding) or indicating abnormal termination of the string matching process. (see FIG. 13).</p>
    <p>The encoding of the sequence abcababcabc is described below with reference to FIG. 3 which shows the evolution of the search tree during the encoding process and also table I which shows the actual contents of the dictionary which represent the search tree shown in FIG. 3. As is shown below, the search tree is expanded by setting the pointers D R and P of dictionary entries l to M, the maximum permitted by the memory available.</p>
    <p>
      </p> <pre xml:space="preserve" listing-type="tabular">              TABLE I(a)______________________________________                              StringIndex   Symbol     D     R     P   Represented______________________________________1       a                (2)       a2       b                (3)       b3       c                          c______________________________________</pre>
    
    <p>As shown in Table I(a) and FIG. 3(a) the dictionary initially contains only symbols a, b and c which are stored in dictionary entries 1, 2, and 3 respectively. They may be stored in a predetermined order and accordingly dictionary entry 1 is linked to dictionary entry 2 by a right hand linking pointer 2 which is located at dictionary entry 1 and dictionary entry 2 is linked to dictionary entry 3 by a right hand linking pointer 3 which is stored in dictionary entry 2. A preferred method is to equate the ordinal value of each symbol to its position in the table. Thus the set of N symbols would be assigned ordinal values in the range 0 to N-1 or 1 to N. This assignment may involve simply regarding the binary pattern representing the symbol as a number. These contents of the memory imply a structure as shown in FIG. 3(a).</p>
    <p>In many applications only some of the possible symbols occur, in which case the first of these structures would be preferable. In those applications in which most of the possible symbols occur, the second method will reduce the initial character search time, accordingly the second method will be assumed below.</p>
    <p>The first symbol of the sequence is input to the encoder, in this example `a`. As the symbol represents the first character in a string the encoder uses the ordinal value of the character, in this example 1, to access directly the node within the search tree corresponding to the character. This node forms the root of a tree representing all strings known to the encoder that begin with the character.</p>
    <p>The next symbol of the sequence is accepted by the encoder, and the D pointer of the current node used to locate the list of dependent nodes. The encoder would in general attempt to match the next symbol to one of those contained in the dependent nodes. If the attempt fails, as in this instance because node 1 does not yet have any dependants, a codeword representing the index of the current node/dictionary entry is transmitted, in this example some representation of the numeral 1. The unmatched symbol will be used to form the start of a new string.</p>
    <p>The encoder is now able to add the string `ab` to its search tree, in order that the string may be more efficiently encoded when encountered again. This is accomplished by creating a new node (entry) numbered 4 in this example, in the search tree (dictionary). The node contains the character, `b`, a D pointer to dependent nodes, initially set to null, an R pointer to other nodes in the list of dependents of the node's parent, in this instance set to null, and a pointer to the parent, set in this example to 1, as shown in Table I(b) and FIG. 3(b).</p>
    <p>
      </p> <pre xml:space="preserve" listing-type="tabular">              TABLE I(b)______________________________________                              StringIndex   Symbol     D     R     P   Represented______________________________________1       a          4               a2       b                          b3       c                          c4       b                      1   ab______________________________________</pre>
    
    <p>The process is repeated, with `b` used as the first character of a new string. The next symbol of the sequence is `c` hence the encoder will attempt, using the process outlined above, to find the string `bc` in the tree. This sequence is not yet known to the encoder, hence the index of the node representing the string `b` will be communicated to the decoder, and the string `bc` added to the search tree. The character `c` is used to form the start of a new string. The updated dictionary is shown in Table I(c) and the corresponding search tree in FIG. 3(c).</p>
    <p>
      </p> <pre xml:space="preserve" listing-type="tabular">              TABLE I(c)______________________________________                              StringIndex   Symbol     D     R     P   Represented______________________________________1       a          4               a2       b          5               b3       c                          c4       b                      1   ab5       c                      2   bc______________________________________</pre>
    
    <p>The next symbol `a` is now read, being in this instance the fourth symbol in the sequence, and appended to the search string. The encoder now attempts to locate the string `ca` in its dictionary. As this string is not yet present, the index of the dictionary entry corresponding to `c` will be communicated to the decoder and the string `ca`, which may also be considered as an index/character pair (3, `a`) added to its dictionary (search tree). This produces the dictionary shown in Table I(d) and search tree shown in FIG. 3(d). The unmatched character `a` is used to start a new search string.</p>
    <p>
      </p> <pre xml:space="preserve" listing-type="tabular">              TABLE I(d)______________________________________                              StringIndex   Symbol     D     R     P   Represented______________________________________1       a          4                a2       b          5                b3       c          6                c4       b                      1   ab5       c                      2   bc6       a                      3   ca______________________________________</pre>
    
    <p>The next symbol `b` is now read and appended to the search string, forming the string `ab`. The D pointer corresponding to `a` is used to locate the list of `a`'s dependants; this pointer has the value 4 in this example. The encoder now searches for the last character in the search string amongst the list of dependants, using the R pointer. In this example the first dictionary entry examined, with index 4, contains the character `b` and hence the encoder has matched the search string with a dictionary entry.</p>
    <p>The next symbol `a`, being the sixth character in the input sequence, is read by the encoder and appended to the search string forming the string `aba`. The encoder uses the D pointer of the last matched dictionary entry, numbered 4 in this example, to locate the list of dependants of the string `ab`. As yet no dependants are known to the dictionary, hence the new string `aba` or (4, `a`) is added to the dictionary, as shown in Table I(e) and FIG. 3(e). The index 4 is communicated to the decoder, and the unmatched character `a` used to start a new search string.</p>
    <p>
      </p> <pre xml:space="preserve" listing-type="tabular">              TABLE I(e)______________________________________                              StringIndex   Symbol     D     R     P   Represented______________________________________1       a          4                a2       b          5                b3       c          6                c4       b          7           1   ab5       c                      2   bc6       a                      3   ca7       a                      4   aba______________________________________</pre>
    
    <p>This corresponds to FIG. 3(e).</p>
    <p>The encoder reads the next symbol and appends it to the search string, forming the new search string `ab`. The encoder searches in the dictionary for this string, using the procedures outlined above, and matches it with dictionary entry 4. The next symbol `c` is read and appended to the search string, forming `abc`. The encoder attempts to locate this string, by searching through the dependant list of `ab`, but fails to find `abc`. The index for `ab`, namely 4, is communicated to the decoder, and the new string (4, `c`) added to the dictionary as entry number 8, as shown in Table I(f) and FIG. 3(f).</p>
    <p>
      </p> <pre xml:space="preserve" listing-type="tabular">              TABLE I(f)______________________________________                              StringIndex   Symbol     D     R     P   Represented______________________________________1       a          4                a2       b          5                b3       c          6                c4       b          7           1   ab5       c                      2   bc6       a                      3   ca7       a                8     4   aba8       c                      4   abc______________________________________</pre>
    
    <p>During the next string encoding cycle the encoder would match the string `ca` with entry 6 in the dictionary, and transmit 6 to the decoder, and add `cab` or (6, `b`) to the dictionary. During the following cycle, the encoder would match the string `bc` with entry 5 in the dictionary, and add (5, x) to the dictionary, where x is the character following the last in the sequence shown.</p>
    <p>The sequence `abcababcabc` would thus have been encoded using the list of index values 1234465, which provides a small degree of compression. If however the same sequence were encountered again by the encoder it would be encoded as `abc` (dictionary entry 8), `aba` (dictionary entry 7), `bc` (dictionary entry 5), and `abc` (dictionary entry 8), resulting in the transmitted sequence 8758. If the sequence of symbols occurred at least twelve times the encoder may represent it by a single index value, thereby obtaining a high degree of compression.</p>
    <p>The encoding algorithm is illustrated more formally in FIG. 4. In step i the variables are initialised and then, repeatedly, the longest possible sequence of characters in the input message is mapped onto a string of the search tree in step ii, for example the sequence bc at the end of the input message is mapped onto the string bc in FIG. 3(f). In step iii the index of the terminal node corresponding to the matched string (e.g. bc) or some further encoded representation thereof, is sent, and the search string set to the following character of the input message (step iv).</p>
    <p>The process of string matching would normally be terminated when the string with the next character appended is not in the dictionary. There are however other instances in which string matching may be terminated exceptionally, for example if no character is received from the source within some specified time interval from the last character, or if the string length reaches some maximum beyond which a buffer limit may be exceeded, or if some specified time interval has occurred since the encoder began encoding the string. In the second of these examples the decoder could deduce that exceptional termination had occurred. In the first and third examples it is necessary for the encoder to transmit an indication, following transmission of the index representing the terminated string; this indication may be an additional control symbol outside the ordinal value range of the source alphabet, and would be encoded as a single codeword.</p>
    <p>The index of the matched string and the next unmatched character must be added to the dictionary. If however, they are immediately added to the dictionary, the encoder could start using the new entry before the decoder has received sufficient information to construct an equivalent dictionary entry. Thus the previous index/character pair are added to the dictionary (v) and the present index/character pair stored (vi). If the dictionary is full it may be processed to recover some storage space. The process of adding a new dictionary entry and recovering space are further described below. In order that the dictionary entry referenced by the stored index/character pair is not deleted before being used in the updating process, the dictionary entry is marked as `new` using the procedure further described below.</p>
    <p>FIG. 5 shows the corresponding decoding algorithm. The variables are initialised in step i. A received codeword is initially decoded in step ii to recover the transmitted index, J, representing the encoded string. The value of J allows the decoder to access directly the dictionary entry corresponding to the encoded string. The tree is then re-traced from entry J back to the root of the string, and the string is read out in step iii. For example if the value 8 were received by a decoder having the search tree of FIG. 3(f) it would find the symbol c at the "leaf" of the tree at dictionary entry 8 and would re-trace the P pointers 7 and 4 to the root a and would therefore read out the sequence cba. This sequence is then reversed in the subsequent step iv to regenerate the original sequence abc and the decoder algorithm then proceeds to update the dictionary provided it is not inhibited by a control character in step v.</p>
    <p>An example of updating the search tree is shown in FIG. 6 and the corresponding memory contents are shown in Table II.</p>
    <p>
      </p> <pre xml:space="preserve" listing-type="tabular">              TABLE II______________________________________                           New    StringIndex  Character  D     R   P   Entry  Represented______________________________________1      a          4             0       a2      b          5             0       b3      c          6             0       c4      b          7         1   0      ab5      c                    2   0      bc6      a                    3   0      ca7      a                 -n 4   0      aba8      c                    4   0      abcn       -b               -8  -4  -1    abb______________________________________</pre>
    
    <p>It will be seen that Table II corresponds to Table I(f) but with the addition of the sequence abb at dictionary entry n. In order to insert this sequence in the search tree, the link between nodes 7 and 8 is broken, and the new node connected between these, as shown in Table II and FIG. 6. The new right hand linking pointers R having the values n and 8 are shown underlined in FIG. 6, together with the new symbol b (also underlined). The change to the search tree illustrated conceptually in FIG. 6 is actually performed by changing the value of the R pointer at dictionary entry 7 in Table II from 8 to n and by inserting new R and P pointers 8 and 4 at dictionary entry n.</p>
    <p>The updating algorithm is shown formally in the flow diagram of FIG. 7. This applies to both the encoder and decoder. Firstly, it is determined whether the dictionary is full in step i. If the dictionary is full, the search tree must be pruned and this procedure is described below with reference to FIG. 9. However, assuming that this is not the case, a blank memory slot is obtained from the free list (shown in FIG. 2(b)) in step ii. The new symbol (b in the case of Table II) is then written into the memory slot (n in the case of Table II) and the necessary pointers (R at dictionary entry 7 in the case of Table II) are re-set in step iii. In step iv the parent node of the new entry is examined to see if it has any existing dependants. If there are existing dependants, then in step v the new entry is inserted into the dependant list as in the example above. If there are no existing dependants, then in step vi the new entry is connected to the parent node, setting the D pointer of the parent to the memory reference of the new entry, and the P pointer of the new entry to the memory reference of the parent node.</p>
    <p>Referring first to FIG. 8, FIG. 8(a) shows the state of the search tree following the updating procedure illustrated in Table II and FIG. 6. Those symbols of the search tree which do not have D linking pointers extending downwardly from (and which therefore occur at the end of matched symbol sequences) are considered to be unlikely to be useful if the search tree is not growing at those points. Such "dead leaves" of the search tree are illustrated in FIG. 8(a) in dashed lines and the new entry b which was added in the updating procedure illustrated in FIG. 6 is marked as such in order to indicate that it is a "new leaf" from which further growth of the search tree might be expected.</p>
    <p>Accordingly it is protected from pruning. It is envisaged that other leaves of the tree which were added in previous recent iterations might also be protected.</p>
    <p>The symbols of the search tree shown in dashed lines in FIG. 8(a) are pruned, resulting in the new search tree of FIG. 8(b) and a free list of four pruned symbols. The new entry b is preserved. For the sake of clarity, the actual symbol sequences corresponding to the various symbols of the search tree are indicated in FIG. 8b and it will be seen that the symbol sequences bc, ca, aba, and abc have been deleted whereas the symbol sequence abb which was added in the updating procedure of FIG. 6 has been preserved.</p>
    <p>The pruning procedure is shown formally in FIG. 9. In step i it is checked whether the dictionary is full and ready to prune, and if so the pointer of the memory is set to the dictionary entry following the beginning of the string, namely entry 4 corresponding to symbol b Table II and FIG. 8(a). In step iii it is determined whether this entry has a down pointer extending therefrom and in the case of FIG. 8(a) it will be seen that symbol b has the down pointer 7. Accordingly this entry is not an end node and the algorithm proceeds to advance the pointer to the next entry in step vi (which also clears any new flag) and hence via step vii to the next entry, namely symbol a of the sequence aba which is an end node. Accordingly the algorithm then checks whether this is protected against pruning by a new entry flag and since it is not it deletes the entry in step v, adds the corresponding memory location to the free list and re-sets the pointers. The re-setting of the pointers can easily be deduced from FIG. 8 by analogy with Table II and FIG. 6.</p>
    <p>This procedure eventually results in the deletion of all "end nodes" (i.e. those having no down pointers D extending from them to other symbols) other than those protected by a new entry flag. This completes the updating of the dictionary and the algorithm can then proceed to step vi of FIG. 4 in the case of the encoding algorithm and step ii of FIG. 5 in the case of the decoding algorithm. It is emphasised that the updating and pruning of the dictionary takes place identically in the search tree of both the encoder and decoder. Whereas this pruning procedure tests all memory locations of the dictionary in a single procedure, pruning may be done in stages which can be determined in a number of ways, e.g. number of memory locations per stage, number of freed memory locations per stage.</p>
    <p>As an additional procedure, which may improve the performance of the compression algorithm at the expense of increased memory and processing requirement, the codewords output from the encoder may be assigned lengths which depend in some manner on the frequency with which they are used. Two methods are described below for accomplishing this, which would apply to the element shown in FIG. 4 (iii) which generates codewords representing the dictionary index to be transmitted.</p>
    <p>The first method relies on the well known prior art described in "A Method for the Construction of Minimum Redundancy Codes" by D A Huffman, Proc IRE Vol 40,9, 1952 and in "A Mathematical Theory of Communication" by C E Shannon, Bell Systems Technical Journal, Vol 27, 1948, and in "An Introduction to Arithmetic Coding" by G Langdon, IBM Journal of Research and Development, Vol 28,2, 1984. A frequency count is associated with each dictionary entry, and is incremented each time the entry is used. This frequency is used to compute the probability of occurence of the string represented by the dictionary entry, and the codeword assigned according to the procedures defined in the prior art. The codeword length Ls associated with a string of probability Ps is</p>
    <p>
      </p> <pre xml:space="preserve" listing-type="equation">-log<sub>2</sub> (Ps)&lt;Ls&lt;1-log<sub>2</sub> (Ps)</pre>
    
    <p>The second method would in general be less effective than the first method, but is simpler to implement. An additional U pointer is associated with each dictionary entry, and is used to form a linked (least frequently used) LFU list of dictionary entries, not related to the structure of the search tree. This list is used to determine in an approximate fashion, the frequency order of the strings. Also associated with each dictionary entry is a length index.</p>
    <p>When a dictionary entry is used it is moved up the LFU list, by using the U pointer to locate the dictionary entry above the current entry, and exchanging the U pointers and length indices of the two entries. Thus more frequently used entries will move towards the start of the LFU list. The length index will be associated with the order of elements in the list, i.e. the most frequently used dictionary entry will have a length index of 1. A code may be generated on a fixed or dynamic basis, and codewords assigned on the basis of length index, shorter codewords being assigned to dictionary entries with a low length index. This second method would be suitable for application to the compression algorithm described by Miller and Wegman in EPA 127 815, as they provide a similar list; it would be necessary to add a length index to their data structure however.</p>
    <p>Instead of using the U pointer to exchange the currently used dictionary entry with the entry immediately above it in the linked list, an alternative procedure would be to move the currently used dictionary entry to the top position in the linked list, the entry previously in the top position being moved to the second position and so on. The linked list is now approximately representative of a Least Recently Used function whereby entries that have not been used for some time will be pushed down to the bottom of the list, and frequently used entries will reside in the top portion of the list.</p>
    <p>As an additional procedure which may improve the performance of the encoder at the expense of additional initialisation time, the dictionary may initially contain certain strings known to occur regularly, for example `th`, `tha`, `the`, `Th`, `The`, . . .</p>
    <p>As an additional procedure which is possible if the memory in which the dictionary is stored is capable of retaining information between the transmission of subsequent messages, as is commonly the case when a mass storage device is present or when the memory is non-volatile, the dictionary may initially contain the set of strings learnt during encoding/decoding of the previous message. As an example, a communication device may call a second communications device, which it may have previously communicated with. The respective encoder and decoder pairs may compare their dictionaries by generating some simple checksum, according to principles well known, and comparing said checksums. If the dictionaries are not equivalent they may be reset to some known initial state.</p>
    <p>As an additional procedure which will improve the reliability of the algorithm in the presence of errors on the link between encoder and decoder, although these would normally be infrequent due to the common use of error detection procedures such as Automatic Repeat Request, the decoder may regard received codewords corresponding to empty or full dictionary entries as indication of error and request the encoder to reset or reinitialise its dictionary. Alternatively, a checksum may periodically be calculated by the encoder and communicated to the decoder; the decoder calculating an equivalent function and comparing it to the received checksum.</p>
    <p>FIG. 10 shows a data processing arrangement for converting uncompressed stored data which is stored in a mass storage device 1 (e.g. a disc store) into corresponding compressed data, thereby releasing memory from the mass storage device. An encoder 2 incorporating a microprocessor μP is provided with a memory 3 in which is stored and generated a search tree by means of an algorithm as described above. A delay circuit 4 ensures that the dictionary is updated before a new symbol is received from the mass storage device.</p>
    <p>FIG. 11 shows a decoder arrangement for converting compressed data in the mass storage device 1 to uncompressed data and comprises a decoder 5 provided with a memory 3 in which a search tree is maintained and updated in accordance with the algorithms described above.</p>
    <p>FIG. 12 shows a terminal 6 provided with a terminal interface 7 which is arranged to transmit and receive data along a communications link by means of an encoder 2 provided with a memory 3 and delay device 4 and a decoder 5 provided with a memory 3. A dictionary is maintained in memory 3 of the encoder and decoder by means of the algorithms described above. The arrangement shown in FIG. 12 can communicate with a corresponding arrangement connected to the other end of the communication link (not shown).</p>
    <p>In designing source encoders, it is usually assumed that the input to the encoder consists of discrete symbols from the source alphabet, and hence that the symbol size is known. Many modern communication systems employ synchronous transmission, in which data is treated as a continuous bit stream rather than individual characters.</p>
    <p>When designing a source encoder for a synchronous source which outputs non-binary symbols in binary form, several approaches may be taken. If the symbol size is constant but unknown, the character length that results in optimum source code performance can be found by search. For example, a sample of data can be taken, the assumed character size stepped from one to some maximum number of bits, and the information content estimated for each case; the ratio of information content to character size should be minimal for the best compression ratio to be achieved. The probability of occurence P<sub>j</sub> of each symbol j is estimated and said number of bits per sequence n is varied so as to increase the information content ##EQU1## of the symbols.</p>
    <p>An alternative approach is possible if a string encoding is used. A symbol size is selected arbitrarily, the assumption being that frequent strings of source symbols will not lose their identity when parsed into bit strings of different lengths. There are various points to consider when selecting the segment size (where a segment is an assumed symbol).</p>
    <p>For a segment of length C, as there is no synchronisation between the position in the source bit stream of segments and of symbols, any regular string of symbols may coincide with any of the C bit positions in the segment. This implies that, for any frequent string of symbols, at least C variations of the string are possible, and hence short segments are likely to result in more economical use of the dictionary space.</p>
    <p>As the encoded binary string length is proportional to the segment size, but the codeword length is proportional to the logarithm of the number of known strings, short segments will make less efficient use of the dictionary space than long segments. This is particularly relevant to the Ziv-Lempel algorithm, in which a large proportion of the memory space is devoted to pointers rather than symbol storage.</p>
    <p>Accordingly, in a preferred method in accordance with the invention wherein the input data consists of a stream of binary digits (bits) representing characters, and the symbols stored in the search tree are each made up of sequences of binary digits (bits), the number of bits per sequence is selected by the processor (which may be in response to an external command signal from a user), the number of bits per symbol of the input data either being unknown or being different from the number of bits per sequence selected by the processor.</p>
    <p>In a variant of this method the number of bits per sequence is initially varied and the resulting compression ratio between the input data and the output data is monitored before selecting the number of bits per sequence for the stored symbols of the search tree.</p>
    <p>Thus it is possible to optimise the number of bits per sequence selected by the processor in order to maximise the compression ratio. However, other factors such as memory capacity or processing speed may affect the optimum number of bits per sequence to be selected by the processor.</p>
    <p>The above described embodiments employ a method of deletion which is highly efficient in terms of memory utilization and execution speed although it is slightly sub-optimal in terms of compression efficiency. The embodiments are formed from the two data structures used to build a dictionary, the systematic search tree structure used to represent strings and the systematic tabular representation of the dictionary used to store the elements of the search tree (as discussed by Sussenguth), the order in which elements of the search tree are stored being effectively random. The method approximates to the Random deletion strategy, in the sense that the selection of portions of the search tree to be deleted does not depend on the ordering of the selected portions within the tree, however it is not truly random as the algorithm for selecting candidates for deletion involves stepping through the tabular representation of the dictionary. This has some similarity with the CLOCK approximation, however it differs in that the selection of candidate elements for deletion made on the basis of position in the tabular representation is qualified by the position of the element within the search tree.</p>
    <p>While the invention has been described in connection with what is presently considered to be the most practical and preferred embodiment, it is to be understood that the invention is not to be limited to the disclosed embodiment, but on the contrary, is intended to cover various modifications and equivalent arrangements included within the spirit and scope of the appended claims.</p>
    </div></div></div><div class="patent-section patent-tabular-section"><a id="backward-citations"></a><div class="patent-section-header"><span class="patent-section-title">Patent Citations</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th">Cited Patent</th><th class="patent-data-table-th">Filing date</th><th class="patent-data-table-th">Publication date</th><th class="patent-data-table-th">Applicant</th><th class="patent-data-table-th">Title</th></tr></thead><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4464650">US4464650</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Aug 10, 1981</td><td class="patent-data-table-td patent-date-value">Aug 7, 1984</td><td class="patent-data-table-td ">Sperry Corporation</td><td class="patent-data-table-td ">Apparatus and method for compressing data signals and restoring the compressed data signals</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4906991">US4906991</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Apr 29, 1988</td><td class="patent-data-table-td patent-date-value">Mar 6, 1990</td><td class="patent-data-table-td ">Xerox Corporation</td><td class="patent-data-table-td ">Textual substitution data compression with finite length search windows</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US4990910">US4990910</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Feb 15, 1990</td><td class="patent-data-table-td patent-date-value">Feb 5, 1991</td><td class="patent-data-table-td ">Kokusai Denshin Denwa Co., Ltd.</td><td class="patent-data-table-td ">Variable length code conversion system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5003307">US5003307</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Oct 6, 1989</td><td class="patent-data-table-td patent-date-value">Mar 26, 1991</td><td class="patent-data-table-td ">Stac, Inc.</td><td class="patent-data-table-td ">Data compression apparatus with shift register search means</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/EP0127815A2?cl=en">EP0127815A2</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">May 16, 1984</td><td class="patent-data-table-td patent-date-value">Dec 12, 1984</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">Data compression method</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/EP0148008A2?cl=en">EP0148008A2</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Dec 20, 1984</td><td class="patent-data-table-td patent-date-value">Jul 10, 1985</td><td class="patent-data-table-td ">Sharp Kabushiki Kaisha</td><td class="patent-data-table-td ">Word spelling correlatively-storing method and its circuit</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/WO1986000479A1?cl=en">WO1986000479A1</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jun 14, 1985</td><td class="patent-data-table-td patent-date-value">Jan 16, 1986</td><td class="patent-data-table-td ">Telebyte Corp</td><td class="patent-data-table-td ">Data compression apparatus and method</td></tr></table><div class="patent-section-footer">* Cited by examiner</div></div><div class="patent-section patent-tabular-section"><a id="npl-citations"></a><div class="patent-section-header"><span class="patent-section-title">Non-Patent Citations</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th colspan="3"class="patent-data-table-th">Reference</th></tr></thead><tr><td class="patent-data-table-td ">1</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">IBM Technical Disclosure Bulletin, vol. 14, No. 11, Apr. 1972, Koch, "<a href='http://scholar.google.com/scholar?q="Representation+of+Tree+Data+Structures+for+Manipulation+and+Search+Operation+Data"'>Representation of Tree Data Structures for Manipulation and Search Operation Data</a>", pp. 3521-3522.</td></tr><tr><td class="patent-data-table-td ">2</td><td class="patent-data-table-td "><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td ">IBM Technical Disclosure Bulletin, vol. 14, No. 11, Apr. 1972, Koch, Representation of Tree Data Structures for Manipulation and Search Operation Data , pp. 3521 3522.</td></tr><tr><td class="patent-data-table-td ">3</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">IBM Technical Disclosure Bulletin, vol. 20, No. 8, Jan. 1978, Winterbottom, "<a href='http://scholar.google.com/scholar?q="General+Purpose+Database+Structure"'>General Purpose Database Structure</a>", pp. 3320-3323.</td></tr><tr><td class="patent-data-table-td ">4</td><td class="patent-data-table-td "><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td ">IBM Technical Disclosure Bulletin, vol. 20, No. 8, Jan. 1978, Winterbottom, General Purpose Database Structure , pp. 3320 3323.</td></tr><tr><td class="patent-data-table-td ">5</td><td class="patent-data-table-td "></td><td class="patent-data-table-td ">IBM Technical Disclosure Bulletin, vol. 25, No. 11B, Apr. 1983, Crus et al, "<a href='http://scholar.google.com/scholar?q="Method+for+Deleting+Records+from+a+Hierarchical+Data+Base"'>Method for Deleting Records from a Hierarchical Data Base</a>", pp. 5886-5888.</td></tr><tr><td class="patent-data-table-td ">6</td><td class="patent-data-table-td "><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td ">IBM Technical Disclosure Bulletin, vol. 25, No. 11B, Apr. 1983, Crus et al, Method for Deleting Records from a Hierarchical Data Base , pp. 5886 5888.</td></tr></table><div class="patent-section-footer">* Cited by examiner</div></div><div class="patent-section patent-tabular-section"><a id="forward-citations"></a><div class="patent-section-header"><span class="patent-section-title">Referenced by</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th">Citing Patent</th><th class="patent-data-table-th">Filing date</th><th class="patent-data-table-th">Publication date</th><th class="patent-data-table-th">Applicant</th><th class="patent-data-table-th">Title</th></tr></thead><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5253325">US5253325</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Dec 8, 1989</td><td class="patent-data-table-td patent-date-value">Oct 12, 1993</td><td class="patent-data-table-td ">British Telecommunications Public Limited Company</td><td class="patent-data-table-td ">Data compression with dynamically compiled dictionary</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5299519">US5299519</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">May 21, 1992</td><td class="patent-data-table-td patent-date-value">Apr 5, 1994</td><td class="patent-data-table-td ">Brother Kogyo Kabushiki Kaisha</td><td class="patent-data-table-td ">External memory for electronically controlled sewing machine</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5406281">US5406281</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Oct 12, 1993</td><td class="patent-data-table-td patent-date-value">Apr 11, 1995</td><td class="patent-data-table-td ">Codex Corporation</td><td class="patent-data-table-td ">Encoder/decoder and method for efficient string handling in data compression</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5412384">US5412384</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Aug 10, 1994</td><td class="patent-data-table-td patent-date-value">May 2, 1995</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">In a computer-implemented system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5424732">US5424732</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Feb 8, 1994</td><td class="patent-data-table-td patent-date-value">Jun 13, 1995</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">Transmission compatibility using custom compression method and hardware</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5426779">US5426779</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Feb 21, 1992</td><td class="patent-data-table-td patent-date-value">Jun 20, 1995</td><td class="patent-data-table-td ">Salient Software, Inc.</td><td class="patent-data-table-td ">Method and apparatus for locating longest prior target string matching current string in buffer</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5455943">US5455943</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Oct 8, 1992</td><td class="patent-data-table-td patent-date-value">Oct 3, 1995</td><td class="patent-data-table-td ">Salient Software, Inc.</td><td class="patent-data-table-td ">Method and apparatus for finding longest and closest matching string in history buffer prior to current string</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5463389">US5463389</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Sep 24, 1993</td><td class="patent-data-table-td patent-date-value">Oct 31, 1995</td><td class="patent-data-table-td ">Motorola, Inc.</td><td class="patent-data-table-td ">Data compression method and device utilizing children arrays</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5485526">US5485526</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jan 14, 1994</td><td class="patent-data-table-td patent-date-value">Jan 16, 1996</td><td class="patent-data-table-td ">Hewlett-Packard Corporation</td><td class="patent-data-table-td ">Memory circuit for lossless data compression/decompression dictionary storage</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5488717">US5488717</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jul 6, 1992</td><td class="patent-data-table-td patent-date-value">Jan 30, 1996</td><td class="patent-data-table-td ">1St Desk Systems, Inc.</td><td class="patent-data-table-td ">MTree data structure for storage, indexing and retrieval of information</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5502439">US5502439</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">May 16, 1994</td><td class="patent-data-table-td patent-date-value">Mar 26, 1996</td><td class="patent-data-table-td ">The United States Of America As Represented By The United States Department Of Energy</td><td class="patent-data-table-td ">Method for compression of binary data</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5530957">US5530957</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Aug 7, 1992</td><td class="patent-data-table-td patent-date-value">Jun 25, 1996</td><td class="patent-data-table-td ">At&amp;T Corp.</td><td class="patent-data-table-td ">Storing trees in navigable form</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5534861">US5534861</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Mar 8, 1995</td><td class="patent-data-table-td patent-date-value">Jul 9, 1996</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">Method and system for adaptively building a static Ziv-Lempel dictionary for database compression</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5572209">US5572209</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Aug 16, 1994</td><td class="patent-data-table-td patent-date-value">Nov 5, 1996</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">Method and apparatus for compressing and decompressing data</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5577248">US5577248</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jun 6, 1995</td><td class="patent-data-table-td patent-date-value">Nov 19, 1996</td><td class="patent-data-table-td ">Salient Software, Inc.</td><td class="patent-data-table-td ">Method and apparatus for finding longest and closest matching string in history buffer prior to current string</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5592667">US5592667</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Nov 10, 1994</td><td class="patent-data-table-td patent-date-value">Jan 7, 1997</td><td class="patent-data-table-td ">Triada, Ltd.</td><td class="patent-data-table-td ">Method of storing compressed data for accelerated interrogation</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5604495">US5604495</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Apr 21, 1995</td><td class="patent-data-table-td patent-date-value">Feb 18, 1997</td><td class="patent-data-table-td ">Seta Co., Ltd.</td><td class="patent-data-table-td ">Data compression method and system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5608396">US5608396</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Feb 28, 1995</td><td class="patent-data-table-td patent-date-value">Mar 4, 1997</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">Efficient Ziv-Lempel LZI data compression system using variable code fields</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5617552">US5617552</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Feb 29, 1996</td><td class="patent-data-table-td patent-date-value">Apr 1, 1997</td><td class="patent-data-table-td ">Connectix Corporation</td><td class="patent-data-table-td ">Lossless data compression system and method</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5619199">US5619199</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">May 4, 1995</td><td class="patent-data-table-td patent-date-value">Apr 8, 1997</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">Order preserving run length encoding with compression codeword extraction for comparisons</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5629695">US5629695</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jun 6, 1995</td><td class="patent-data-table-td patent-date-value">May 13, 1997</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">Order preserving run length encoding with compression codeword extraction for comparisons</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5649181">US5649181</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Apr 3, 1996</td><td class="patent-data-table-td patent-date-value">Jul 15, 1997</td><td class="patent-data-table-td ">Sybase, Inc.</td><td class="patent-data-table-td ">Method and apparatus for indexing database columns with bit vectors</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5689255">US5689255</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Aug 22, 1995</td><td class="patent-data-table-td patent-date-value">Nov 18, 1997</td><td class="patent-data-table-td ">Hewlett-Packard Company</td><td class="patent-data-table-td ">Method and apparatus for compressing and decompressing image data</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5737732">US5737732</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jan 25, 1996</td><td class="patent-data-table-td patent-date-value">Apr 7, 1998</td><td class="patent-data-table-td ">1St Desk Systems, Inc.</td><td class="patent-data-table-td ">In a computation means</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5771010">US5771010</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Mar 22, 1995</td><td class="patent-data-table-td patent-date-value">Jun 23, 1998</td><td class="patent-data-table-td ">Ibm Corporation</td><td class="patent-data-table-td ">Apparatus for compressing data using a Lempel-Ziv-type algorithm</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5778371">US5778371</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Sep 12, 1995</td><td class="patent-data-table-td patent-date-value">Jul 7, 1998</td><td class="patent-data-table-td ">Kabushiki Kaisha Toshiba</td><td class="patent-data-table-td ">Code string processing system and method using intervals</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5787430">US5787430</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jun 30, 1994</td><td class="patent-data-table-td patent-date-value">Jul 28, 1998</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">Variable length data sequence backtracking a trie structure</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5794228">US5794228</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Dec 11, 1995</td><td class="patent-data-table-td patent-date-value">Aug 11, 1998</td><td class="patent-data-table-td ">Sybase, Inc.</td><td class="patent-data-table-td ">Database system with buffer manager providing per page native data compression and decompression</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5794229">US5794229</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Dec 11, 1995</td><td class="patent-data-table-td patent-date-value">Aug 11, 1998</td><td class="patent-data-table-td ">Sybase, Inc.</td><td class="patent-data-table-td ">In a computer system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5809168">US5809168</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Dec 27, 1994</td><td class="patent-data-table-td patent-date-value">Sep 15, 1998</td><td class="patent-data-table-td ">Nec Corporation</td><td class="patent-data-table-td ">Method and apparatus for estimating a character size of an alphanumeric subject copy in a facimile system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5812072">US5812072</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jun 2, 1995</td><td class="patent-data-table-td patent-date-value">Sep 22, 1998</td><td class="patent-data-table-td ">Masters; John</td><td class="patent-data-table-td ">Data conversion technique</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5852821">US5852821</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jun 25, 1997</td><td class="patent-data-table-td patent-date-value">Dec 22, 1998</td><td class="patent-data-table-td ">Sybase, Inc.</td><td class="patent-data-table-td ">High-speed data base query method and apparatus</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5861827">US5861827</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Dec 3, 1996</td><td class="patent-data-table-td patent-date-value">Jan 19, 1999</td><td class="patent-data-table-td ">Unisys Corporation</td><td class="patent-data-table-td ">Data compression and decompression system with immediate dictionary updating interleaved with string search</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5893103">US5893103</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">May 9, 1997</td><td class="patent-data-table-td patent-date-value">Apr 6, 1999</td><td class="patent-data-table-td ">Motorola, Inc.</td><td class="patent-data-table-td ">Method of reconstructing a managed information tree</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5918225">US5918225</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Mar 20, 1997</td><td class="patent-data-table-td patent-date-value">Jun 29, 1999</td><td class="patent-data-table-td ">Sybase, Inc.</td><td class="patent-data-table-td ">SQL-based database system with improved indexing methodology</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US5951623">US5951623</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Aug 6, 1996</td><td class="patent-data-table-td patent-date-value">Sep 14, 1999</td><td class="patent-data-table-td ">Reynar; Jeffrey C.</td><td class="patent-data-table-td ">Lempel- Ziv data compression technique utilizing a dictionary pre-filled with frequent letter combinations, words and/or phrases</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6088699">US6088699</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Apr 22, 1998</td><td class="patent-data-table-td patent-date-value">Jul 11, 2000</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">System for exchanging compressed data according to predetermined dictionary codes</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6121901">US6121901</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Dec 30, 1998</td><td class="patent-data-table-td patent-date-value">Sep 19, 2000</td><td class="patent-data-table-td ">Unisys Corporation</td><td class="patent-data-table-td ">Data compression and decompression system with immediate dictionary updating interleaved with string search</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6199064">US6199064</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Nov 14, 1997</td><td class="patent-data-table-td patent-date-value">Mar 6, 2001</td><td class="patent-data-table-td ">Michael Schindler</td><td class="patent-data-table-td ">Method and apparatus for sorting data blocks</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6225922">US6225922</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Mar 16, 1998</td><td class="patent-data-table-td patent-date-value">May 1, 2001</td><td class="patent-data-table-td ">Hewlett-Packard Company</td><td class="patent-data-table-td ">System and method for compressing data using adaptive field encoding</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6297771">US6297771</a></td><td class="patent-data-table-td patent-date-value">Jun 7, 2000</td><td class="patent-data-table-td patent-date-value">Oct 2, 2001</td><td class="patent-data-table-td ">Conexant Systems, Inc.</td><td class="patent-data-table-td ">Signal detector employing coherent integration</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6304216">US6304216</a></td><td class="patent-data-table-td patent-date-value">Mar 30, 1999</td><td class="patent-data-table-td patent-date-value">Oct 16, 2001</td><td class="patent-data-table-td ">Conexant Systems, Inc.</td><td class="patent-data-table-td ">Signal detector employing correlation analysis of non-uniform and disjoint sample segments</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6307489">US6307489</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Mar 15, 2000</td><td class="patent-data-table-td patent-date-value">Oct 23, 2001</td><td class="patent-data-table-td ">Robert Allen Freking</td><td class="patent-data-table-td ">Fast and small serial huffman decoder for decoding at an optimally high rate</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6327471">US6327471</a></td><td class="patent-data-table-td patent-date-value">Feb 19, 1998</td><td class="patent-data-table-td patent-date-value">Dec 4, 2001</td><td class="patent-data-table-td ">Conexant Systems, Inc.</td><td class="patent-data-table-td ">Method and an apparatus for positioning system assisted cellular radiotelephone handoff and dropoff</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6348744">US6348744</a></td><td class="patent-data-table-td patent-date-value">Apr 14, 1998</td><td class="patent-data-table-td patent-date-value">Feb 19, 2002</td><td class="patent-data-table-td ">Conexant Systems, Inc.</td><td class="patent-data-table-td ">Integrated power management module</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6400286">US6400286</a></td><td class="patent-data-table-td patent-date-value">Jun 20, 2001</td><td class="patent-data-table-td patent-date-value">Jun 4, 2002</td><td class="patent-data-table-td ">Unisys Corporation</td><td class="patent-data-table-td ">Data compression method and apparatus implemented with limited length character tables</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6426711">US6426711</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">May 14, 2001</td><td class="patent-data-table-td patent-date-value">Jul 30, 2002</td><td class="patent-data-table-td ">Unisys Corporation</td><td class="patent-data-table-td ">Character table implemented data compression method and apparatus</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6448925">US6448925</a></td><td class="patent-data-table-td patent-date-value">Feb 4, 1999</td><td class="patent-data-table-td patent-date-value">Sep 10, 2002</td><td class="patent-data-table-td ">Conexant Systems, Inc.</td><td class="patent-data-table-td ">Jamming detection and blanking for GPS receivers</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6470347">US6470347</a></td><td class="patent-data-table-td patent-date-value">Sep 1, 1999</td><td class="patent-data-table-td patent-date-value">Oct 22, 2002</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">Method, system, program, and data structure for a dense array storing character strings</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6496145">US6496145</a></td><td class="patent-data-table-td patent-date-value">Oct 4, 2001</td><td class="patent-data-table-td patent-date-value">Dec 17, 2002</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">Signal detector employing coherent integration</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6519277">US6519277</a></td><td class="patent-data-table-td patent-date-value">Oct 16, 2001</td><td class="patent-data-table-td patent-date-value">Feb 11, 2003</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">Accelerated selection of a base station in a wireless communication system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6531982">US6531982</a></td><td class="patent-data-table-td patent-date-value">Sep 30, 1997</td><td class="patent-data-table-td patent-date-value">Mar 11, 2003</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">Field unit for use in a GPS system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6577271">US6577271</a></td><td class="patent-data-table-td patent-date-value">Mar 30, 1999</td><td class="patent-data-table-td patent-date-value">Jun 10, 2003</td><td class="patent-data-table-td ">Sirf Technology, Inc</td><td class="patent-data-table-td ">Signal detector employing coherent integration</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6581183">US6581183</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Mar 30, 2000</td><td class="patent-data-table-td patent-date-value">Jun 17, 2003</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">System and method for resynchronization of transmit and receive compression dictionaries</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6606349">US6606349</a></td><td class="patent-data-table-td patent-date-value">Feb 4, 1999</td><td class="patent-data-table-td patent-date-value">Aug 12, 2003</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">Spread spectrum receiver performance improvement</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6628211">US6628211</a></td><td class="patent-data-table-td patent-date-value">Mar 19, 2002</td><td class="patent-data-table-td patent-date-value">Sep 30, 2003</td><td class="patent-data-table-td ">Unisys Corporation</td><td class="patent-data-table-td ">Prefix table implemented data compression method and apparatus</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6633244">US6633244</a></td><td class="patent-data-table-td patent-date-value">Dec 29, 2000</td><td class="patent-data-table-td patent-date-value">Oct 14, 2003</td><td class="patent-data-table-td ">Efeckta Technologies Corporation</td><td class="patent-data-table-td ">Efficient and lossless conversion for transmission or storage of data</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6636178">US6636178</a></td><td class="patent-data-table-td patent-date-value">Oct 4, 2001</td><td class="patent-data-table-td patent-date-value">Oct 21, 2003</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">Signal detector employing correlation analysis of non-uniform and disjoint sample segments</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6683547">US6683547</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Apr 22, 2002</td><td class="patent-data-table-td patent-date-value">Jan 27, 2004</td><td class="patent-data-table-td ">Hughes Electronics Corporation</td><td class="patent-data-table-td ">Method and system for data compession with dictionary pre-load of a set of expected character strings</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6693953">US6693953</a></td><td class="patent-data-table-td patent-date-value">Sep 30, 1998</td><td class="patent-data-table-td patent-date-value">Feb 17, 2004</td><td class="patent-data-table-td ">Skyworks Solutions, Inc.</td><td class="patent-data-table-td ">Adaptive wireless communication receiver</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6714158">US6714158</a></td><td class="patent-data-table-td patent-date-value">Apr 18, 2000</td><td class="patent-data-table-td patent-date-value">Mar 30, 2004</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">Method and system for data detection in a global positioning system satellite receiver</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6724330">US6724330</a></td><td class="patent-data-table-td patent-date-value">Dec 7, 2002</td><td class="patent-data-table-td patent-date-value">Apr 20, 2004</td><td class="patent-data-table-td ">Unisys Corporation</td><td class="patent-data-table-td ">Prefix table implemented data compression method and apparatus utilizing string code reassignment</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6778136">US6778136</a></td><td class="patent-data-table-td patent-date-value">Dec 13, 2001</td><td class="patent-data-table-td patent-date-value">Aug 17, 2004</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">Fast acquisition of GPS signal</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6788655">US6788655</a></td><td class="patent-data-table-td patent-date-value">Apr 18, 2000</td><td class="patent-data-table-td patent-date-value">Sep 7, 2004</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">Personal communications device with ratio counter</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6931055">US6931055</a></td><td class="patent-data-table-td patent-date-value">Apr 18, 2000</td><td class="patent-data-table-td patent-date-value">Aug 16, 2005</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">Signal detector employing a doppler phase correction system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6952440">US6952440</a></td><td class="patent-data-table-td patent-date-value">Apr 18, 2000</td><td class="patent-data-table-td patent-date-value">Oct 4, 2005</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">Signal detector employing a Doppler phase correction system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6961660">US6961660</a></td><td class="patent-data-table-td patent-date-value">Mar 3, 2004</td><td class="patent-data-table-td patent-date-value">Nov 1, 2005</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">Method and system for data detection in a global positioning system satellite receiver</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US6980957">US6980957</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Dec 14, 1999</td><td class="patent-data-table-td patent-date-value">Dec 27, 2005</td><td class="patent-data-table-td ">International Business Machines Corporation</td><td class="patent-data-table-td ">Audio transmission system with reduced bandwidth consumption</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7002516">US7002516</a></td><td class="patent-data-table-td patent-date-value">Aug 19, 2003</td><td class="patent-data-table-td patent-date-value">Feb 21, 2006</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">Signal detector employing correlation analysis of non-uniform and disjoint sample segments</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7079051">US7079051</a></td><td class="patent-data-table-td patent-date-value">Mar 18, 2004</td><td class="patent-data-table-td patent-date-value">Jul 18, 2006</td><td class="patent-data-table-td ">James Andrew Storer</td><td class="patent-data-table-td ">In-place differential compression</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7164370">US7164370</a></td><td class="patent-data-table-td patent-date-value">Oct 6, 2005</td><td class="patent-data-table-td patent-date-value">Jan 16, 2007</td><td class="patent-data-table-td ">Analog Devices, Inc.</td><td class="patent-data-table-td ">System and method for decoding data compressed in accordance with dictionary-based compression schemes</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7167115">US7167115</a></td><td class="patent-data-table-td patent-date-value">Aug 26, 2005</td><td class="patent-data-table-td patent-date-value">Jan 23, 2007</td><td class="patent-data-table-td ">American Megatrends, Inc.</td><td class="patent-data-table-td ">Method, apparatus, and computer-readable medium for data compression and decompression utilizing multiple dictionaries</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7225219">US7225219</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Nov 29, 2000</td><td class="patent-data-table-td patent-date-value">May 29, 2007</td><td class="patent-data-table-td ">Broadspider Networks, Inc.</td><td class="patent-data-table-td ">Distributed caching architecture for computer networks</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7269511">US7269511</a></td><td class="patent-data-table-td patent-date-value">Jul 6, 2005</td><td class="patent-data-table-td patent-date-value">Sep 11, 2007</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">Method and system for data detection in a global positioning system satellite receiver</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7330854">US7330854</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Oct 30, 2003</td><td class="patent-data-table-td patent-date-value">Feb 12, 2008</td><td class="patent-data-table-td ">Siemens Aktiengesellschaft</td><td class="patent-data-table-td ">Generating a bit stream from an indexing tree</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7444141">US7444141</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jun 12, 2003</td><td class="patent-data-table-td patent-date-value">Oct 28, 2008</td><td class="patent-data-table-td ">Sergio Rivera</td><td class="patent-data-table-td ">Method and system for programmable control of mobile communications units</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7483871">US7483871</a></td><td class="patent-data-table-td patent-date-value">Oct 1, 2002</td><td class="patent-data-table-td patent-date-value">Jan 27, 2009</td><td class="patent-data-table-td ">Pinpoint Incorporated</td><td class="patent-data-table-td ">Customized electronic newspapers and advertisements</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7493463">US7493463</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jul 27, 2005</td><td class="patent-data-table-td patent-date-value">Feb 17, 2009</td><td class="patent-data-table-td ">Samsung Electronics Co., Ltd.</td><td class="patent-data-table-td ">Code size reduction method through multiple load/store instructions</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7506256">US7506256</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">May 1, 2003</td><td class="patent-data-table-td patent-date-value">Mar 17, 2009</td><td class="patent-data-table-td ">Semantic Compaction Systems</td><td class="patent-data-table-td ">Device and method for previewing themes and categories of sequenced symbols</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7545854">US7545854</a></td><td class="patent-data-table-td patent-date-value">Feb 7, 2000</td><td class="patent-data-table-td patent-date-value">Jun 9, 2009</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">Doppler corrected spread spectrum matched filter</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7580429">US7580429</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Sep 5, 2002</td><td class="patent-data-table-td patent-date-value">Aug 25, 2009</td><td class="patent-data-table-td ">U.S. Robotics</td><td class="patent-data-table-td ">System and methods for improving data compression</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7630986">US7630986</a></td><td class="patent-data-table-td patent-date-value">Oct 27, 2000</td><td class="patent-data-table-td patent-date-value">Dec 8, 2009</td><td class="patent-data-table-td ">Pinpoint, Incorporated</td><td class="patent-data-table-td ">Secure data interchange</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7633413">US7633413</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Aug 20, 2007</td><td class="patent-data-table-td patent-date-value">Dec 15, 2009</td><td class="patent-data-table-td ">Qualcomm Incorporated</td><td class="patent-data-table-td ">Systems and processes for decoding a chain reaction code through inactivation</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7640362">US7640362</a></td><td class="patent-data-table-td patent-date-value">Jan 31, 2001</td><td class="patent-data-table-td patent-date-value">Dec 29, 2009</td><td class="patent-data-table-td ">Interdigital Technology Corporation</td><td class="patent-data-table-td ">Adaptive compression in an edge router</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7711038">US7711038</a></td><td class="patent-data-table-td patent-date-value">Jun 27, 2000</td><td class="patent-data-table-td patent-date-value">May 4, 2010</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">System and method for despreading in a spread spectrum matched filter</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7852905">US7852905</a></td><td class="patent-data-table-td patent-date-value">Jun 16, 2004</td><td class="patent-data-table-td patent-date-value">Dec 14, 2010</td><td class="patent-data-table-td ">Sirf Technology, Inc.</td><td class="patent-data-table-td ">System and method for despreading in a spread spectrum matched filter</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7853600">US7853600</a></td><td class="patent-data-table-td patent-date-value">May 20, 2005</td><td class="patent-data-table-td patent-date-value">Dec 14, 2010</td><td class="patent-data-table-td ">Pinpoint, Incorporated</td><td class="patent-data-table-td ">System and method for providing access to video programs and other data using customer profiles</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7885314">US7885314</a></td><td class="patent-data-table-td patent-date-value">May 2, 2000</td><td class="patent-data-table-td patent-date-value">Feb 8, 2011</td><td class="patent-data-table-td ">Kenneth Scott Walley</td><td class="patent-data-table-td ">Cancellation system and method for a wireless positioning system</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US7999733">US7999733</a></td><td class="patent-data-table-td patent-date-value">Feb 19, 2007</td><td class="patent-data-table-td patent-date-value">Aug 16, 2011</td><td class="patent-data-table-td ">Sirf Technology Inc.</td><td class="patent-data-table-td ">Fast reacquisition of a GPS signal</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8019952">US8019952</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jan 11, 2005</td><td class="patent-data-table-td patent-date-value">Sep 13, 2011</td><td class="patent-data-table-td ">Fujitsu Limited</td><td class="patent-data-table-td ">Storage device for storing data while compressing same value input data</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8056100">US8056100</a></td><td class="patent-data-table-td patent-date-value">May 20, 2005</td><td class="patent-data-table-td patent-date-value">Nov 8, 2011</td><td class="patent-data-table-td ">Pinpoint, Incorporated</td><td class="patent-data-table-td ">System and method for providing access to data using customer profiles</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8171032">US8171032</a></td><td class="patent-data-table-td patent-date-value">Aug 4, 2008</td><td class="patent-data-table-td patent-date-value">May 1, 2012</td><td class="patent-data-table-td ">Pinpoint, Incorporated</td><td class="patent-data-table-td ">Providing customized electronic information</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US8234589">US8234589</a></td><td class="patent-data-table-td patent-date-value">Feb 9, 2009</td><td class="patent-data-table-td patent-date-value">Jul 31, 2012</td><td class="patent-data-table-td ">Semantic Compaction Systems, Inc.</td><td class="patent-data-table-td ">Device and method for previewing themes and categories of sequenced symbols</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/US20100274786">US20100274786</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Apr 9, 2010</td><td class="patent-data-table-td patent-date-value">Oct 28, 2010</td><td class="patent-data-table-td ">Brightcloud Inc.</td><td class="patent-data-table-td ">System And Method For Performing Longest Common Prefix Strings Searches</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/USRE41152">USRE41152</a></td><td class="patent-data-table-td patent-date-value">Sep 14, 2001</td><td class="patent-data-table-td patent-date-value">Feb 23, 2010</td><td class="patent-data-table-td ">Pinpoint Incorporated</td><td class="patent-data-table-td ">Lempel-Ziv data compression technique utilizing a dictionary pre-filled with frequent letter combinations, words and/or phrases</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/USRE43741">USRE43741</a></td><td class="patent-data-table-td patent-date-value">Nov 17, 2011</td><td class="patent-data-table-td patent-date-value">Oct 16, 2012</td><td class="patent-data-table-td ">Qualcomm Incorporated</td><td class="patent-data-table-td ">Systematic encoding and decoding of chain reaction codes</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/CN100595596C?cl=en">CN100595596C</a></td><td class="patent-data-table-td patent-date-value">Dec 12, 2007</td><td class="patent-data-table-td patent-date-value">Mar 24, 2010</td><td class="patent-data-table-td ">北京四方继保自动化股份有限公司</td><td class="patent-data-table-td ">Dynamic data compression storage method in electric network wide-area measuring systems (WAMS)</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/DE19702553C1?cl=en">DE19702553C1</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jan 24, 1997</td><td class="patent-data-table-td patent-date-value">Nov 13, 1997</td><td class="patent-data-table-td ">Siemens Ag</td><td class="patent-data-table-td ">Data encoding and decoding method</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/EP0721699A1?cl=en">EP0721699A1</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">May 22, 1995</td><td class="patent-data-table-td patent-date-value">Jul 17, 1996</td><td class="patent-data-table-td ">Motorola, Inc.</td><td class="patent-data-table-td ">Method and apparatus for a unique and efficient use of a data structure for compressing data</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/WO1993017378A2?cl=en">WO1993017378A2</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Feb 19, 1993</td><td class="patent-data-table-td patent-date-value">Sep 2, 1993</td><td class="patent-data-table-td ">Salient Software Inc</td><td class="patent-data-table-td ">Method and apparatus for locating longest prior target string matching current string in buffer</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/WO1995001677A1?cl=en">WO1995001677A1</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Jun 6, 1994</td><td class="patent-data-table-td patent-date-value">Jan 12, 1995</td><td class="patent-data-table-td ">Codex Inc</td><td class="patent-data-table-td ">Method and apparatus for encoding and decoding compressed data in data communication</td></tr><tr><td class="patent-data-table-td citation-patent"><a href="/patents/WO1995008873A1?cl=en">WO1995008873A1</a><span class='patent-tooltip-anchor' data-tooltip-text="Cited by examiner"> *</span></td><td class="patent-data-table-td patent-date-value">Aug 8, 1994</td><td class="patent-data-table-td patent-date-value">Mar 30, 1995</td><td class="patent-data-table-td ">Codex Corp</td><td class="patent-data-table-td ">Data compression method and device utilizing children arrays</td></tr></table><div class="patent-section-footer">* Cited by examiner</div></div><div class="patent-section patent-tabular-section"><a id="classifications"></a><div class="patent-section-header"><span class="patent-section-title">Classifications</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th"> </th><th class="patent-data-table-th"> </th></tr></thead><tr><td class="patent-data-table-td ">U.S. Classification</td><td class="patent-data-table-td "><span class="nested-value"><a href="http://www.google.com/url?id=fEY0BAABERAJ&q=http://www.uspto.gov/web/patents/classification/uspc341/defs341.htm&usg=AFQjCNEghHxwAVDJQysUGYYEnJx0U-6WAA#C341S051000">341/51</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=fEY0BAABERAJ&q=http://www.uspto.gov/web/patents/classification/uspc341/defs341.htm&usg=AFQjCNEghHxwAVDJQysUGYYEnJx0U-6WAA#C341S067000">341/67</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=fEY0BAABERAJ&q=http://www.uspto.gov/web/patents/classification/uspc341/defs341.htm&usg=AFQjCNEghHxwAVDJQysUGYYEnJx0U-6WAA#C341S079000">341/79</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=fEY0BAABERAJ&q=http://www.uspto.gov/web/patents/classification/uspc707/defs707.htm&usg=AFQjCNE7Q7Bg2eD2wcE_fXEcdOe7Yesevw#C707SE17012">707/E17.012</a></span></td></tr><tr><td class="patent-data-table-td ">International Classification</td><td class="patent-data-table-td "><span class="nested-value"><a href="http://www.google.com/url?id=fEY0BAABERAJ&q=http://web2.wipo.int/ipcpub/&usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&notion=scheme&version=20130101&symbol=G06F0005000000">G06F5/00</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=fEY0BAABERAJ&q=http://web2.wipo.int/ipcpub/&usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&notion=scheme&version=20130101&symbol=G06F0017300000">G06F17/30</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=fEY0BAABERAJ&q=http://web2.wipo.int/ipcpub/&usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&notion=scheme&version=20130101&symbol=G06T0009000000">G06T9/00</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=fEY0BAABERAJ&q=http://web2.wipo.int/ipcpub/&usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&notion=scheme&version=20130101&symbol=H03M0007300000">H03M7/30</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=fEY0BAABERAJ&q=http://web2.wipo.int/ipcpub/&usg=AFQjCNER44F5jlVoswCkvW3YEcB5lW4moA#refresh=page&notion=scheme&version=20130101&symbol=H03M0007460000">H03M7/46</a></span></td></tr><tr><td class="patent-data-table-td ">Cooperative Classification</td><td class="patent-data-table-td "><span class="nested-value"><a href="http://www.google.com/url?id=fEY0BAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=H03M7/3088">H03M7/3088</a></span>, <span class="nested-value"><a href="http://www.google.com/url?id=fEY0BAABERAJ&q=http://worldwide.espacenet.com/classification&usg=AFQjCNGs5WqSrPE3A4ZP63zGuM6PRNfEFA#!/CPC=G06T9/005">G06T9/005</a></span></td></tr><tr><td class="patent-data-table-td ">European Classification</td><td class="patent-data-table-td "><span class="nested-value">G06F17/30Z1T</span>, <span class="nested-value">G06T9/00S</span>, <span class="nested-value">H03M7/30Z2</span></td></tr></table><div class="patent-section-footer"></div></div><div class="patent-section patent-tabular-section"><a id="legal-events"></a><div class="patent-section-header"><span class="patent-section-title">Legal Events</span></div><table class="patent-data-table"><thead class="patent-data-table-thead"><tr class="patent-data-table"><th class="patent-data-table-th">Date</th><th class="patent-data-table-th">Code</th><th class="patent-data-table-th">Event</th><th class="patent-data-table-th">Description</th></tr></thead><tr><td class="patent-data-table-td patent-date-value">Mar 30, 2010</td><td class="patent-data-table-td ">B1</td><td class="patent-data-table-td ">Reexamination certificate first reexamination</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Free format text: </span><span class="nested-value">THE PATENTABILITY OF CLAIMS 1-5, 7-8, 36-40 AND 42 IS CONFIRMED. CLAIMS 6, 9-35, 41 AND 43-68 WERE NOT REEXAMINED.</span></div></td></tr><tr><td class="patent-data-table-td patent-date-value">Nov 18, 2008</td><td class="patent-data-table-td ">RR</td><td class="patent-data-table-td ">Request for reexamination filed</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Effective date: </span><span class="nested-value">20081006</span></div></td></tr><tr><td class="patent-data-table-td patent-date-value">Mar 18, 2004</td><td class="patent-data-table-td ">FPAY</td><td class="patent-data-table-td ">Fee payment</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Year of fee payment: </span><span class="nested-value">12</span></div></td></tr><tr><td class="patent-data-table-td patent-date-value">Mar 20, 2000</td><td class="patent-data-table-td ">FPAY</td><td class="patent-data-table-td ">Fee payment</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Year of fee payment: </span><span class="nested-value">8</span></div></td></tr><tr><td class="patent-data-table-td patent-date-value">Mar 13, 1996</td><td class="patent-data-table-td ">FPAY</td><td class="patent-data-table-td ">Fee payment</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Year of fee payment: </span><span class="nested-value">4</span></div></td></tr><tr><td class="patent-data-table-td patent-date-value">Dec 27, 1990</td><td class="patent-data-table-td ">AS</td><td class="patent-data-table-td ">Assignment</td><td class="patent-data-table-td "><div class="nested-key-value"><span class="nested-key">Owner name: </span><span class="nested-value">BRITISH TELECOMMUNICATIONS PUBLIC LIMITED COMPANY,</span></div><div class="nested-key-value"><span class="nested-key">Free format text: </span><span class="nested-value">ASSIGNMENT OF ASSIGNORS INTEREST.;ASSIGNOR:CLARK, ALAN D.;REEL/FRAME:005625/0688</span></div><div class="nested-key-value"><span class="nested-key">Effective date: </span><span class="nested-value">19890712</span></div></td></tr></table><div class="patent-section-footer"></div></div><div class="modal-dialog" id="patent-images-lightbox"><div class="patent-lightbox-controls"><div class="patent-lightbox-rotate-controls"><div class="patent-lightbox-rotation-text">Rotate</div><div class="rotate-icon rotate-ccw-icon"></div><div class="rotate-icon rotate-cw-icon"></div></div><div class="patent-lightbox-index-counter"></div><a class="patent-lightbox-fullsize-link" target="_blank">Original Image</a><div class="patent-drawings-control patent-drawings-next"><img class="patent-drawings-button-img"src="/googlebooks/images/kennedy/page_right.png" alt="Next page"width="21" height="21" /></div><div class="patent-drawings-control patent-drawings-prev"><img class="patent-drawings-button-img"src="/googlebooks/images/kennedy/page_left.png" alt="Previous page"width="21" height="21" /></div></div><div class="modal-dialog-content"><div class="patent-lightbox-image-holder"><div class="patent-lightbox-placeholder"></div></div></div></div><script>_OC_initPatentsAtb({image_not_available_html: " Image not available"});</script></div></div></div></td></tr></table><script>(function() {var href = window.location.href;if (href.indexOf('?') !== -1) {var parameters = href.split('?')[1].split('&');for (var i = 0; i < parameters.length; i++) {var param = parameters[i].split('=');if (param[0] == 'focus') {var elem = document.getElementById(param[1]);if (elem) {elem.focus();}}}}})();</script><script>_OC_addFlags({LockSrc:"/books/javascript/lock_8a2b04e7bf975d5171d8e4c0b6365c7a.js", Host:"http://www.google.com/", IsBooksRentalEnabled:1, IsWebstoreDisplayCaseEnabled:1, IsObfuscationEnabled:1, IsBrowsingHistoryEnabled:1, IsWebReaderSvgEnabled:0, IsGeoLayerEnabled:1, IsImageModeNotesEnabled:1, IsCopyMenuItemEnabled:1, IsGiftingEnabled:0, IsWebReaderUniversalPaginatorEnabled:0, IsOfflineBubbleEnabled:1, IsReaderEnabledForPlayRequests:1, IsFutureOnSaleVolumesEnabled:1, IsOfflineRestrictedCopyEnabled:1, IsBooksUnifiedLeftNavEnabled:1, IsRestrictedCopyEnabled:1, IsZipitFolderCollectionEnabled:1, IsEndOfSampleRecommendationsEnabled:1, IsRatingsOnBookcardsEnabled:1, IsAdsDisabled:0, IsIframePageDisplayEnabled:0, IsEmbeddedMediaEnabled:1, IsImageModeAnnotationsEnabled:1, IsMyLibraryGooglePlusEnabled:1, IsImagePageProviderEnabled:0, IsBookcardListPriceSmall:0, IsInternalUser:0, IsBooksShareButtonEnabled:0, IsPreOrdersEnabled:0, IsDisabledRandomBookshelves:0, WebstoreDisplayCasePosition:3});_OC_Run({"enable_p13n":false,"add_vol_to_collection_base_url":"http://www.google.com/patents?op=add\u0026sig=ACfU3U3vHtW68C5hYBtNUelmNv6e0meUTA\u0026id=fEY0BAABERAJ","remove_vol_from_collection_base_url":"http://www.google.com/patents?op=remove\u0026sig=ACfU3U0QINK9mgk6IV80lz7Gn3TAqQ5Oag\u0026id=fEY0BAABERAJ","logged_in":false,"p13n_save_user_settings_url":"http://www.google.com/patents?op=edit_user_settings\u0026sig=ACfU3U0ZmFEVE8M1V-CuYd1xNHvu9HTQ9A","is_cobrand":false,"sign_in_url":"https://www.google.com/accounts/Login?service=\u0026continue=http://www.google.com/patents%3Fhl%3Den\u0026hl=en","is_play_enabled":true}, {"volume_id":"","is_ebook":true,"volumeresult":{"has_flowing_text":false,"has_scanned_text":true,"can_download_pdf":false,"can_download_epub":false,"is_pdf_drm_enabled":false,"is_epub_drm_enabled":false,"download_pdf_url":"http://www.google.com/patents/download/Method_and_apparatus_for_encoding_decodi.pdf?id=fEY0BAABERAJ\u0026output=pdf\u0026sig=ACfU3U0oFTNyGg9_5kK9g2QN0QluaoPEMw"},"sample_url":"http://www.google.com/patents/reader?id=fEY0BAABERAJ\u0026printsec=frontcover\u0026output=reader\u0026source=gbs_atb_hover","is_browsable":true,"is_public_domain":true}, {});</script><div id="footer_table" style="font-size:83%;text-align:center;position:relative;top:20px;height:4.5em;margin-top:2em"><div style="margin-bottom:8px"><a href=http://www.google.com/><nobr>Google&nbsp;Home</nobr></a> - <a href=//www.google.com/patents/sitemap/><nobr>Sitemap</nobr></a> - <a href=http://www.google.com/googlebooks/uspto.html><nobr>USPTO Bulk Downloads</nobr></a> - <a href=/intl/en/privacy/><nobr>Privacy Policy</nobr></a> - <a href=/intl/en/policies/terms/><nobr>Terms of Service</nobr></a> - <a href=https://support.google.com/faqs/answer/2539193?hl=en><nobr>About Google Patents</nobr></a> - <a href="http://www.google.com/tools/feedback/intl/en/error.html" onclick="try{_OC_startFeedback({productId: '72792',locale: 'en'});return false;}catch(e){}"><nobr>Send Feedback</nobr></a></div><span>Data provided by IFI CLAIMS Patent Services</span><br><span >&copy;2012 Google</span></div> <script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-27188110-1");pageTracker._setCookiePath("/patents/");pageTracker._trackPageview();</script> </body></html>